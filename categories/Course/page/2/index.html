<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: Course - MatteoYang&#039;s Space</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MatteoYang&#039;s Space"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MatteoYang&#039;s Space"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="A personal blog for Tianao Yang"><meta property="og:type" content="blog"><meta property="og:title" content="MatteoYang&#039;s Space"><meta property="og:url" content="matteoyang.space"><meta property="og:site_name" content="MatteoYang&#039;s Space"><meta property="og:description" content="A personal blog for Tianao Yang"><meta property="og:locale" content="en_US"><meta property="og:image" content="/img/og_image.png"><meta property="article:author" content="Matteo Yang"><meta property="article:tag" content="Blog"><meta property="article:tag" content="Computer Science"><meta property="article:tag" content="Technology"><meta property="article:tag" content="Daily Life"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://matteoyang.space"},"headline":"MatteoYang's Space","image":["https://matteoyang.space/img/og_image.png"],"author":{"@type":"Person","name":"Matteo Yang"},"publisher":{"@type":"Organization","name":"MatteoYang's Space","logo":{"@type":"ImageObject","url":"https://matteoyang.space/img/avatar.jpg"}},"description":"A personal blog for Tianao Yang"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="MatteoYang&#039;s Space" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about_Englishss">About</a><a class="navbar-item" href="/about_Chinese">关于</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Course</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-06-10T10:38:00.000Z" title="2021/6/10 18:38:00">2021-06-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-01T11:01:40.487Z" title="2024/10/1 19:01:40">2024-10-01</time></span><span class="level-item"><a class="link-muted" href="/categories/Course/">Course</a></span><span class="level-item">32 minutes read (About 4765 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/10/2021Spring-OOP-review/">2021春季学期 面向对象程序设计基础 期末复习笔记</a></p><div class="content"><h4 id="My-Object-Oriented-Programming-Habits"><a href="#My-Object-Oriented-Programming-Habits" class="headerlink" title="My Object Oriented Programming Habits"></a>My Object Oriented Programming Habits</h4><ul>
<li>class中的数据变量英文命名写全并且每个单词首字母大写，构造函数传参数时参数名称全大写</li>
<li>private数据成员在public中获得函数用get_Data（）命名</li>
</ul>
<h3 id="记录期末之前上课-题目"><a href="#记录期末之前上课-题目" class="headerlink" title="记录期末之前上课&amp;题目"></a>记录期末之前上课&amp;题目</h3><h5 id="5-24-W14-1-1"><a href="#5-24-W14-1-1" class="headerlink" title="5.24 W14 1-1"></a>5.24 W14 1-1</h5><ul>
<li>function&lt;returntype(parameters)&gt; 类型可以统一函数指针和函数对象，如果将function&lt;int(int)&gt;作为函数参数则可以将所有以int返回值int参数的函数或者int返回值int参数的对象都可以传入并不违法【&#x2F;<em>统一了函数对象和函数指针</em>&#x2F;】</li>
</ul>
<h5 id="5-29-HW14-15"><a href="#5-29-HW14-15" class="headerlink" title="5.29 HW14-15"></a>5.29 HW14-15</h5><ul>
<li>string.c_str() 返回一个<code>const char*</code>为string内部存储的数组结尾是<code>\0</code>，为了保证不用外部char指针修改string这个const无法初始化<code>char*</code>类型。将string转换成<code>char*</code>应该用<code>int copy(char* tar,int lenth,int pos=0)</code>返回实际拷贝的字符数目。</li>
<li>string类的拼接操作<code>+</code>时间复杂度为生成的字符串长度，用<code>+=</code>更快</li>
</ul>
<h5 id="5-31-W15-1-1"><a href="#5-31-W15-1-1" class="headerlink" title="5.31 W15 1-1"></a>5.31 W15 1-1</h5><ul>
<li>string拼接操作速度：+&#x3D; &gt; string.append( string) &gt; stringstream &gt; +</li>
</ul>
<h5 id="5-31-Review-L1-L3"><a href="#5-31-Review-L1-L3" class="headerlink" title="5.31 Review L1-L3"></a>5.31 Review L1-L3</h5><ul>
<li>带缺省值参数函数不算参数个数，去掉缺省值参数后如果其他参数都一样会产生歧义被拒绝</li>
<li>auto后面定义的变量要同一类型</li>
<li><code>auto i=0;  and  decltype(i) b;</code> 即decltype（） xxx为类型说明符，后面可以带个参数为“定义一个和这个参数一样类型的变量xxx”</li>
<li>auto作为函数返回值类型要在参数列表后面加<code>-&gt;decltype(returnvalue表达式)</code></li>
<li>NULL是int型常量0 nullptr是严格空指针</li>
<li>Function <code>f1(int a,int b=1)</code>and <code>f1(int a=2)</code>即使一个是private不许访问但是仍然会ambiguous二义性错误。</li>
<li>inline ReturnType Function();</li>
<li>遍历某个范围的for循环</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> e : arr) <span class="comment">// auto e:arr 也可以</span></span><br><span class="line">			cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">如下程序无法过编译会导致二义性</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i=<span class="number">2</span>)</span> </span>&#123; a = i; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j=<span class="number">2</span>)</span> </span>&#123; a = i + j; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_a</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A aa;</span><br><span class="line">    aa.<span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; aa.<span class="built_in">get_a</span>() &lt;&lt; endl;<span class="comment">//二义性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-31-Review-L4"><a href="#5-31-Review-L4" class="headerlink" title="5.31 Review L4"></a>5.31 Review L4</h5><ul>
<li><p>初始化列表顺序并不是初始化顺序，初始化列表时应用声明顺序进行初始化</p>
</li>
<li><p>后缀运算符++需要哑元dummy，要把原本的数据增加之后返回的值仍然是增加前的，可以先复制原对象然后给原对象++，最后返回原对象的复制。</p>
</li>
<li><p>&#x3D;，【】，（），-&gt;这些只能通过成员函数来重载</p>
</li>
<li><p>流运算符重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; in, Obj&amp; dst );</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="type">const</span> Obj&amp; src );</span><br><span class="line">需要声明为类的友元以便访问私有对象，在类外（全局）进行重载的定义</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, Obj&amp; dst);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-31-Review-L5"><a href="#5-31-Review-L5" class="headerlink" title="5.31 Review L5"></a>5.31 Review L5</h5><ul>
<li><p>友元函数可以是其他类的构造、析构函数，也可以是其他类，也可以是全局函数</p>
</li>
<li><p>static普通静态变量与函数：初定义要初始化仅一次，内部可链接，作用域仅限声明文件cpp不能被其他cpp所用</p>
</li>
<li><p>static静态成员变量：归属于类而不是具体对象，所有对象可共享。通过<code>obj.var</code>和<code>classname::var</code>均可访问。在实现文件赋初值<code>VarType ClassName::static_var=Value</code>.</p>
<p>需要在h中声明cpp中定义，h定义会导致包含h后重复定义</p>
</li>
<li><p>static静态成员函数：static关键字在ReturnType前，类和obj都可以访问，<strong>不能访问非静态成员</strong>，即<strong>属于整个类的函数只能访问类变量</strong></p>
</li>
<li><p>常量数据成员：初始化后在该obj整个生命周期中不能改变</p>
</li>
<li><p>常量成员函数：<code>const</code>关键字在函数体前<code>Function（） const&#123;...&#125;</code>不能修改class的成员，只读而不可写入，常量对象只能调用const成员函数</p>
</li>
<li><p>拷贝（传递参数）时如果有指针成员容易出错，直接位拷贝指针不变而同一块内存会释放两次</p>
</li>
</ul>
<h5 id="5-31-Review-L6"><a href="#5-31-Review-L6" class="headerlink" title="5.31 Review L6"></a>5.31 Review L6</h5><ul>
<li><p>不想给某个函数修改值的权限则使用const参数</p>
</li>
<li><p><strong>拷贝构造函数</strong>参数：同类对象的常量引用 自动合成为Bitwise Copy遇指针出错</p>
</li>
<li><p>常（左值）引用可以绑定右值，引用本身为左值</p>
</li>
<li><p>右值引用在延续即将销毁变量的声明，提升处理效率，即把本要销毁的变量引用了变成了不销毁的左值——移动构造函数参数：同类右值引用</p>
<p>移动构造函数需要：<strong>1.复制指针地址或者值 2.将原指针地址改0避免释放</strong></p>
<p>使得生成的临时对象被保留下来，本该释放（析构）时发现指针为空，不能释放内存，而真正有意义的指针（数据）被移动保留了下来</p>
<p>原则：<strong>不浪费任何右值</strong>（创造右值之后不销毁，及时利用）</p>
</li>
<li><p>std::move(左值)，把左值当做右值用，需要<strong>这个左值不再被使用</strong>或者<strong>即将被改</strong>（swap）</p>
</li>
<li><p>类型转换函数的自定义 从Src到Dst类</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Src</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Dst</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">或者在目标Dst类中定义常量引用为参数的构造函数</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dst</span>&#123;</span><br><span class="line"><span class="built_in">Dst</span>(<span class="type">const</span> Src&amp; s)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-31-Review-L7"><a href="#5-31-Review-L7" class="headerlink" title="5.31 Review L7"></a>5.31 Review L7</h5><ul>
<li>构造函数和析构函数，复制运算、友元不能被继承</li>
<li>use <code>using</code>关键字来使用基类的（所有）构造函数</li>
<li>基类的私有成员在派生类函数中也不能访问，只有基类的成员函数中被访问。而公有成员成为派生类共有成员可以被访问。<strong>protected成员可以在派生类成员函数中访问但不能在外部函数访问</strong></li>
<li>重载Overload，函数名必须相同，函数参数必须不同，作用域相同。（编译多态或者属于静多态）</li>
<li>重写隐藏其实就是Redefining，重新定义基类函数实现特殊功能，屏蔽了所有同名函数，参数可以同可以不同（运行时多态、动态多态）using 类::成员函数来解除屏蔽）</li>
</ul>
<h5 id="6-1-Review-L8"><a href="#6-1-Review-L8" class="headerlink" title="6.1 Review L8"></a>6.1 Review L8</h5><ul>
<li>凡是可以接受基类ptr或obj，都可以直接接受派生类，会自动切片</li>
<li>通过对象的向上类型转换可以访问private继承无法访问的基类成员变量coz<strong>向上类型转换只可以Public继承</strong>，不允许私有继承向上转换</li>
<li>带有虚函数的class，对象大小会加上一个指针（8），多个虚函数也只有一个Vptr指向vtable</li>
<li>虚函数机制在构造、析构函数中不工作，构造不能虚而析构经常是虚的<strong>总是将基类的析构函数设置为虚</strong></li>
<li>虚函数Feature重写覆盖必须要函数名参数表一模一样，这样会根据运行时实际类型进行动态晚绑定</li>
<li>在函数体前面加override关键字检查是否成功重写覆盖</li>
<li>函数体前加final关键字——禁止继承后再覆盖，已经是最终版本的函数实现</li>
</ul>
<h5 id="6-1-Review-L9"><a href="#6-1-Review-L9" class="headerlink" title="6.1 Review L9"></a>6.1 Review L9</h5><ul>
<li>（形参）之后加<code>=0</code>声明为纯虚函数，含有一个纯虚即为抽象类无法具象化出对象，只为了之后的继承类实现共性“接口”或者“方法”。一般是<strong>没有实际物理意义的抽象</strong>（shape，creature）</li>
<li>纯虚函数必须被之后要使用的继承类重写覆盖，不然仍然是纯虚函数而该类为抽象类，即必须<strong>把所有纯虚函数实现一遍</strong></li>
<li>纯虚析构函数仍需要函数体，即声明纯虚<code>=0</code>之后还要写一个空实现函数体，后面不用显式地重写覆盖</li>
<li>使用基类指针数组管理具体派生类对象，具体处理时转化成专用指针调用专用接口</li>
<li>使用<code>dynamic_cast&lt;tar*or&amp;&gt;(obj_p or obj_r)</code>如果失败返回nullptr，<strong>用来判断实际类型</strong></li>
<li><code>static_cast</code>不检查实际类型，只要有继承关系就转，dynamic会动态检查，慢但是安全</li>
<li>向上类型转换：指针和引用时不改变虚函数表（晚绑定，仍按实际类型调用继承重写函数）而直接切片为基类对象会丢失增加数据和方法</li>
<li>dynamic_cast正是通过虚函数表判断是否安全地进行向下类型转换</li>
<li>多重继承：Best Practice 最多继承一个非抽象类，可以继承多个抽象类（接口）</li>
<li>多态（接口函数根据实际派生类而不同表现）效果条件：继承&amp;&amp;虚函数&amp;&amp;（引用or指针）</li>
<li>模板：算法实现与参数类型无关，则将<strong>函数的参数类型</strong>定义为一种特殊的“参数”</li>
<li>调用函数模板时，可以手动输入“模板参数”也可以让编译器自己认。实现原理：编译期将模板替换为需要的类型生成一份对应的函数代码，需要多少不同的就生成多少</li>
<li>模板使用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmplate &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">tmplate &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">ReturnType <span class="title">Function</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类模板中成员函数类外定义前要声明一下同样的模板，模板参数编译期确定不可使用变量</li>
<li>模板也是同一段代码实现不同的相似功能，但是在编译期处理为“静多态”</li>
<li><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601195810985.png" alt="image-20210601195810985"></li>
</ul>
<p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601195823314.png" alt="image-20210601195823314"></p>
<p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601195839453.png" alt="image-20210601195839453"></p>
<p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601195846178.png" alt="image-20210601195846178"></p>
<p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601195853777.png" alt="image-20210601195853777"></p>
<h5 id="6-1-Review-L10"><a href="#6-1-Review-L10" class="headerlink" title="6.1 Review L10"></a>6.1 Review L10</h5><ul>
<li>标准C++库所有内容都在标准命名空间std里，包括stl标准库</li>
<li>不同命名空间中的同名函数、变量等命名不会互相冲突</li>
<li>自定义命名空间<code>namespace A&#123;int x,y;&#125;</code>使用时<code>A::x and A::y</code>，用using namespace直接使用这个命名空间的所有成员，也可以using namespace::var or ::func 直接使用某几个函数</li>
<li>Containers: 简单、序列vec,list、关系set,map</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">T1 first;</span><br><span class="line">T2 second;</span><br><span class="line"><span class="comment">//若干其它函数</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>支持 .first .second make_pair(  ,  )  &lt; &gt; 按照第一第二比较</p>
</li>
<li><p>tuple：类似pair，无限长，使用v0&#x3D;get<pos>(tuple_var)且pos需要编译确定，不能使用变量</p>
<p>支持make_tuple(,,,)  tie(x,y,z)&#x3D;make_tuple(xx,yy,zz)即tie返回左值引用的元组，可以利用右侧的tuple来一次性多重赋值</p>
</li>
<li><p>vector支持：vec[pos]   vector<T> vec0  .size()  .clear()  .push_back( xx) .pop_back(xx)  use iterator to .erase(x.begin()+1,num) .insert(iterator)而iterator支持*，可以直接sort，支持++ – +&#x3D; -&#x3D;支持减法运算</p>
</li>
<li><p>迭代器失效：insert和erase，和改变大小时可能会扩展capacity而整体迁移所有it失效，<strong>修改过容器后不使用之前的迭代器</strong></p>
</li>
<li><p>list：快速的增减push_front() push_back() find(l.begin(),l.end(),tar)  l.insert(it,tar) 不支持下标，插入和删除时不相关迭代器不失效</p>
</li>
<li><p>set：不重复元素构成的无序集合，只是不保持加入顺序，内部按大小排列</p>
<p>支持insert（） 查询find（）返回迭代器 erase（s.find(val)） count(val)只有0或1</p>
</li>
<li><p>map：关联映射 其实为&lt;Key，T&gt; Key必须互不相同 通过下标map[key]访问val如果不存在则创建对应映射   支持insert(pair)插入  查询find(key)返回it  统计count(key)要么0要么1  支持erase(it)</p>
</li>
</ul>
<h5 id="6-1-Review-L12"><a href="#6-1-Review-L12" class="headerlink" title="6.1 Review L12"></a>6.1 Review L12</h5><ul>
<li>构造方式s3(“string”,num)num为截取的长度（num,’x‘）赋值num个x，（it1，it2）迭代器</li>
<li>string.c_str()返回一个<code>const char*</code>不能修改，涉及底层实现，不能赋值给<code>char*</code>需要copy(ptr,n,pos&#x3D;0)</li>
<li>size()orlength()  clear()  empty()  push_back(‘a’) or append(s2)  字典序比较</li>
<li>cin&gt;&gt;读到空格 getline（cin，str）读一行不包括&#x2F;n  getline(cin,str,’#’)可以读换行一直到终止符#</li>
<li>stoi（“2001”）  stoi（“50 cats”，&amp;sz）sz为读入长度  stoi（string，nullptr，进制&#x3D;0）默认自动检查进制，可以stod转化double</li>
<li><iomanip>库中格式控制函数fixed scientific  setprecision（2）  oct  dec  setw（3） setfill（’<em>‘）设置对齐长度为3且填充字符</em></li>
<li>使用stringstream拼接字符串，也是stream可以赋值于var ss&gt;&gt;a&gt;&gt;b</li>
<li><strong>正则表达式</strong><a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-intro.html%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8Bhttps://blog.csdn.net/bgzclxqq/article/details/90262904">https://www.runoob.com/regexp/regexp-intro.html菜鸟教程https://blog.csdn.net/bgzclxqq/article/details/90262904</a> CSDN关于C++的正则式</li>
</ul>
<h5 id="6-1-Review-L13"><a href="#6-1-Review-L13" class="headerlink" title="6.1 Review L13"></a>6.1 Review L13</h5><ul>
<li><p>声明函数指针 <code>ReturnType (*ptrvar)(parameters)</code>，可以直接赋值，甚至可以直接auto指定类型</p>
</li>
<li><p>less<int>()和greater<int>()为自带的比较函数,其实是个对象，长得像个函数</p>
</li>
<li><p>greater是一个模板类</p>
<p>greater<int> 用int实例化的类</p>
<p>greater<int>() 该类的一个对象</p>
</li>
<li><p>函数对象需要public重载()运算符</p>
</li>
<li><p>把函数当参数需要声明：<code>template &lt;class Compare&gt; void sort(Compare comp)</code>可以接受函数指针和函数对象</p>
</li>
<li><p>智能指针<code>shared_ptr&lt;T&gt; p1(new int (1))</code>也可以make_shared<T>(2) 或者拷贝构造同类</p>
<p>重载了*运算符直接访问对象 也可以-&gt;访问成员</p>
</li>
<li><p>自带引用计数use_count()引用全归0才自动销毁对象</p>
</li>
<li><p>实现原理：<img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601211114941.png" alt="image-20210601211114941"></p>
</li>
<li><p>获取常规指针.get()  清楚并减少引用.reset（） 可以用static或dynamic_cast&lt;&gt;(p)</p>
</li>
<li><p>不<strong>能使用同一个裸指针初始化多个智能指针</strong> 即<strong>辅助指针U_ptr只能有一个</strong>不然<strong>多次释放</strong></p>
</li>
<li><p>存在循环引用永不析构问题weak_ptr指向对象但是不计数wp.lock()转换智能指针</p>
</li>
<li><p>unique_ptr确保一个对象只能被一个指针指向（引用） 不能赋值指针，可以移动up2&#x3D;std::move(up1) 使用release放弃up控制权并返回裸指针</p>
</li>
</ul>
<h5 id="6-1-Review-L14"><a href="#6-1-Review-L14" class="headerlink" title="6.1 Review L14"></a>6.1 Review L14</h5><ul>
<li><p>模板方法：抽象出不同具体类的骨架，写出通用的基类并且将步骤的实现延迟到子类中（设置为纯虚函数）。不改变算法结构而重新定义一些实现步骤。</p>
</li>
<li><p>父类定义骨架，子类实现细节，需要新的实现重新继承即可</p>
</li>
<li><p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601214723704.png" alt="image-20210601214723704"></p>
</li>
<li><p>策略模式（strategy）：定义一系列算法并封装，可以互相替换</p>
</li>
</ul>
<p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601215008527.png" alt="image-20210601215008527"></p>
<p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210601215017697.png" alt="image-20210601215017697"></p>
<ul>
<li>对不同的每个子任务（方法）都写出基类Strategy然后继承出具体实现类，实际调用的框架中只需要管理（存储）这些方法的基类Strategy指针即可</li>
<li>策略模式符合“单一责任”原则：一个类or接口只负责一项职责，功能层面解耦</li>
<li>.迭代器模式：基于Iterator基类，实现不同聚合对象的顺序访问，使得接口统一而使用方法统一</li>
</ul>
<h5 id="6-8-Review-L15"><a href="#6-8-Review-L15" class="headerlink" title="6.8 Review L15"></a>6.8 Review L15</h5><ul>
<li><p>结构性模式——适配器Adapter、代理委托Proxy、装饰器Decorator</p>
</li>
<li><p><strong>适配器模式</strong>：客户期待接口基类Stack中有各种接口，现在有一个写好的类似功能类Vector，想加一层Adaptec使得代码继续复用</p>
<p>Adaptee——Adapter——Target——Client</p>
<p>实现：</p>
<p>组合——把Adaptee放到Adapter中当成员，继承Tar基类，挨个实现要求的函数</p>
<p>继承——公有继承Tar和私有继承Adaptee类，即er类就是ee和tar类，实现函数时直接调用ee中继承过来的函数即可</p>
</li>
<li><p><strong>代理委托Proxy</strong>：客户要求的基类接口，有一个RealSubject继承了基类接口可以满足需求，但是需要更多功能和控制操作</p>
<p>Client—BaseSub—Realsub&lt;—Proxy：BaseSub</p>
<p>Programer—ProxySub（derived from BaseSub）has a RealSubPtr</p>
<p>实现BaseSub中的函数，函数体{Ptr-&gt;Request; other commands;}实现了包装并增加。</p>
</li>
<li><p><strong>装饰器Decorator</strong>：无限的增加新功能，每次增加几个功能并可以无限进行这个装饰的过程。装饰器是定义一种递归模式，方便之后的功能继承这种模式</p>
<p>实现：装饰器:public  Base 私有基类指针，构造函数接受一个基类指针（这一层装饰之前的类的指针）并存储。定义虚函数addon（）为每一层装饰的新功能，定义常规需求函数Draw{add（），ptr-&gt;draw（）}。具体增加功能的时候需要功能类继承装饰器类然后实现add函数为新功能</p>
<p>魔兽争霸学技能：学技能类（Decorator） 具体学了什么（继承Decorator的类）构造，一级级学技能上去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span>::<span class="keyword">public</span> base&#123;</span><br><span class="line">	base* upper;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">addon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function">ReturnType <span class="title">Request</span><span class="params">(parameters)</span></span>&#123;</span><br><span class="line">        <span class="built_in">addon</span>();</span><br><span class="line">        upper-&gt;Request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//crearte a decorator pattern</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>构造：基类—装饰递归结构—装饰1—装饰12—装饰123</p>
<p>调用过程（解嵌套）：装饰123—3Draw，指针变为装饰12—2Draw指针变为1—1Draw，指针变为基类Draw</p>
</li>
</ul>
<h5 id="6-10-FinalExample："><a href="#6-10-FinalExample：" class="headerlink" title="6.10 FinalExample："></a>6.10 FinalExample：</h5><ul>
<li><p>不能继续使用（using）纯虚基类的构造函数</p>
</li>
<li><p>使用虚函数机制时把基类析构函数生命为virtual</p>
</li>
<li><p>list的迭代器是双向的，甚至可以反向迭代。反向迭代器rbegin（）和rend（）其自增运算++为向头变换</p>
</li>
<li><p>迭代器失效仅有erase操作的迭代器，其他任何迭代器不受影响。而且list迭代器太牛了，锁定自己的元素不变，也就是说指向链表中的某一个元素。头迭代器和尾迭代器在中间插入元素后依然是头尾不需要改变。</p>
</li>
<li><p>list中的insert是在迭代器it之前的位置插入元素，并且迭代器仍然指向原来元素（链表特性）</p>
</li>
<li><p>list为空时，用insert比较危险——头尾迭代器相等并且会一起指向尾空元素。不要把list想象成动态数组，还是想象成链表安全些。</p>
</li>
<li><p>关于<strong>Strategy模式</strong>：管理一堆Strategy_x基类，每个决定单独的x1、x2、x3</p>
</li>
<li><p>关于map类，声明：typedef map&lt;int,string&gt; num2name; 使用时可以用数组符号修改key值也可insert（），但是insert不支持已经存在的key，数组下标[]会覆盖。</p>
</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Course/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/categories/Course/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Course/">1</a></li><li><a class="pagination-link is-current" href="/categories/Course/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="MatteoYang 杨天傲"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">MatteoYang 杨天傲</p><p class="is-size-6 is-block">Undergraduate Student of CST</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/matteoyang2002" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/matteoyang2002"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="bilibili" href="https://space.bilibili.com/28551965"><i class="fab fa-bilibili"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Zhihu" href="https://www.zhihu.com/people/matteoyang"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeChat" href="/contact_wechat"><i class="fab fa-weixin"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.tsinghua.edu.cn" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">University</span></span><span class="level-right"><span class="level-item tag">www.tsinghua.edu.cn</span></span></a></li><li><a class="level is-mobile" href="https://www.cs.tsinghua.edu.cn" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Department</span></span><span class="level-right"><span class="level-item tag">www.cs.tsinghua.edu.cn</span></span></a></li><li><a class="level is-mobile" href="https://storage.cs.tsinghua.edu.cn" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Research Group</span></span><span class="level-right"><span class="level-item tag">storage.cs.tsinghua.edu.cn</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Auto/"><span class="level-start"><span class="level-item">Auto</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Course/"><span class="level-start"><span class="level-item">Course</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/Daily/"><span class="level-start"><span class="level-item">Daily</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-03T11:06:30.000Z">2023-09-03</time></p><p class="title"><a href="/2023/09/03/202305DLTCache/">2023年9月记</a></p><p class="categories"><a href="/categories/Daily/">Daily</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-03T11:06:30.000Z">2023-09-03</time></p><p class="title"><a href="/2023/09/03/202309-Diary/">2023年9月记</a></p><p class="categories"><a href="/categories/Daily/">Daily</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-02T08:01:36.000Z">2023-09-02</time></p><p class="title"><a href="/2023/09/02/hello-world/">Hello World</a></p><p class="categories"><a href="/categories/Daily/">Daily</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-15T02:33:36.000Z">2023-06-15</time></p><p class="title"><a href="/2023/06/15/2023Spring-ca-final/">2023春季学期 计算机系统结构 期末复习笔记</a></p><p class="categories"><a href="/categories/Course/">Course</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-13T04:01:36.000Z">2023-06-13</time></p><p class="title"><a href="/2023/06/13/2023Spring-os-final/">2023春季学期 操作系统 期中期末复习笔记</a></p><p class="categories"><a href="/categories/Course/">Course</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/1970/"><span class="level-start"><span class="level-item">1970</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="MatteoYang&#039;s Space" height="28"></a><p class="is-size-7"><span>&copy; 2025 Matteo Yang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2002-2023 From Birth To Present</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/matteoyang2002"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>