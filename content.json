{"posts":[{"title":"2021秋季学期 数据结构与算法 Cheat Sheet","text":"word三栏复制到markdown很乱，渲染后的pdf版 正确性：保持某性质，单调能中止 CH1最大子段和——从后剪负和更新 公共子序列——DP打表 渐进复杂度——够大，平均（期望复杂度）： 独立考察、各种操作概率加权 &amp; 分摊复杂度：连续足够多操作后，总体成本摊还给单次操作 CH2 二分while(lo&lt;hi){mi=/2; e&lt;S[mi]?hi=mi:lo=mi+1; ret lo-1; 插值最慢On 字长到n^1/2后为loglogn Bubble优化：大趟无误停止；大趟中表明last（最后逆序对可能出现的位置，后面一定有序，hi更新为last Bitmap 掩码位置0x80&gt;&gt;(k&amp;0x07) 校验环 等长intF[]和一个stack，使得stack添加的时候辅助F记录位置，del：交换为栈顶，懒惰删除 Read:k==T[F[k]] 列表去重：相邻对相同删除后者 选择排序稳定性:选择大于等于保证稳定性，后者优先 循环节 A[k] A[r(k)] A[r(r(k))]回到A[k]互不交 不超n 交换法使M脱离原循环节自成且原来减小1 无需交换次数等效于最初的循环节个数 插入排序 就地在线输入敏感 最坏n^2 [3-10] 归并排序 适于并行外部 逆序对：上界On^2 冒泡交换逆序减一 归并可计数 游标列表 一组数据等长游标，空数据指向下一个可插入位置，非空指向下一个可删除位置（头方向） CH4 Stack尾递归进制转换：while{模入栈，数/=进制} D括号匹配：规定通用，不能失配，最后为空 E 栈混洗：只允许原入辅助，辅助入目标。本质是等量PopPush序列，等价于括号匹配。混洗数卡特兰（S第一次变空的时候——A首元素S弹出）(2n)!/(n+1)!n!，SPn=sum(1kn)（SP（k-1）*SP(n-k)） 充要：没有312，没有j+1,i,j，模拟验证：从另一个栈底开始匹配，对上了就pop，否则push成功则对。 F 中缀表达式求值：维护数和符号栈，读符号若读入高push，栈顶高开算直到栈顶低，相等（右括号或\\0）脱括号进入下一字符;左括号全&lt; 右括号全&gt;从来不入栈 G RPN 数压入，符直接算 生成：操作数直接接入RPN，也放到栈中；运算符执行计算时接入RPN。 J 双栈当队 裹进两个底对底的栈，enq压入R，deq弹出F，若无F则把所有R都装过来。分摊分析针对每一个输入对他们的不同状态提出不同的开销，再根据假设情况计算上界最后总开销摊还给这种假设情况 d次deq和e次enq之后。。势能：原开销+动态势能=定 K Steap Queap Def辅助序列：每一个元素都是原序列中后缀最大者——从尾端扫描“顶”起非降。栈push新元素与辅助栈顶较大的。队列push要向前撑到够不到为止。优化：只计那几个撑起来的index 直方图最大矩形 for&lt;n{while(!empty&amp;&amp;H[top]&gt;=H[r]) S.pop(); //until H[top]&lt;H[r] S[r]=empty? 0:1+H[top]; push(r); }pop all..栈顶小于扫描就入栈，栈顶大时就一直POP+计算更新直到栈顶小。继续扫描。分摊O（n）？ CH5 A 空树H取-1，RB取0 真:全二度 完全只剩最后一层不满 满为全满 长子左孩与兄弟右孩—多叉树 E 先序：维护栈while: pop访问+push rc lc while{访问左藤（loop: visit x+push x-&gt;rc+x=x-&gt;lc until !x），栈空退出，否则弹出子树循环.} F中序：深入左藤（从上到下依次入栈），栈空退出，否则pop一个节点visit后转向其右子树..节点出栈时左子树不存在或完成，右子树未入栈。是否O（n） Succ()：有右孩子，右孩子一路向左深入。否则一路作为右孩子(向左上)找爹，停止后再找一个爹。 G后序：若栈顶不是x的爹，就去找其子树中最左的叶子（while栈顶x非空(if lc，（if rc,push rc）push lc) else(push rc).返回前pop()）。Pop and visit 每个节点出栈时以它为根的子树已经遍历，且右兄弟如果存在一定在栈顶。正可以遍历右兄弟。验证复杂度？ 等价于表达式树的计算~RPN H 层次遍历：deq visit enq lc rc，其中队列最大规模n/2的ceiling。前面都出1入2.向量紧凑表示完全树 I重构 中序+先序|后序 or先序+后序&amp;&amp;真 增强序列allNULL输出 PFC 文件长度正比于平均带权深度wald。必有叶子在底两层 不断贪心合并最小树直到只剩一棵 正确：内节点必双子、兄弟可换、层次 归纳 定差 CH6 图 A 简单图：无自环重边 简单路径没有重点 带权网络即各边带权重的图 B 邻接矩阵 nn记录边 关联矩阵ne structV中有出入度、状态、dftime、遍历树parent、priority structE中有type（undetermined、tree、cross\\forward\\backward） 实现：线性Vs、双vec嵌套构成二维边指针集合。枚举所有邻居O(n) 邻接表为Ooutdeg+1 addedge：new 表并更新关联点的出入度。Deledge类似 addvertex：Vs push新、每个已有的外层vec都要push一个null并且加一个整个的外层vec。删除：del出边（入度）和那一列vec，删除顶点后再删除所有的入边（出度）。 性能分析 适稠密图 θn^2空间 用vec后透明地处理空间溢出等 平面图有点-边+区域-连通支=1 C 邻接表 每个点作表头连接自己所有邻居（所有后继），有向图只记录作为前驱\\后继的边，适稀疏 空间On+e 平面图On 时间：构造n+e 枚举所有以v为尾（头）的弧1+degv （n+e，可建立逆邻接表改进） 维护后查deg+-都是O1 但exists需要搜索Oe，选用散列可期望O1 适遍历、顶点数目不定，算deg相关 D bfs 树的层次遍历 维护Queue，每次dTime=++clock，对于所有邻居开始处理{如果尚未发现则改为发现并加入Q中，标记为Tree边和parent，如果已经被发现标记为跨边}标记访问完毕 用于：寻找连通支和可达分量，对连通支的遍历包一层小写的bfs，reset并重置clock，对所有节点做遍历一旦未发现就做BFS(v,clock)。 复杂度：无向图reset n+e 每个顶点内枚举邻居需要1+deg，共需要n+2e 性质应用：最短路径即为深度 周星驰数 ​ E dfs 先序遍历支撑树 DFS{标记开始时钟; 发现当前v 考察每个邻居{未被发现：标树，递归DFS它；dis—指向了祖先，backward；visited—比较发现时间，自己早则forward 否则cross} v已经访问完毕；标记结束时钟} 无向图中只有TREE和BACKWARD 有向图 也包装 遍历树所有边取反向 括号引理：后代活跃期包含于祖先，无关则不相交，没有别的情况。Backward一定有回路但！=回路forward是我的孩子，cross和我无关。有向图环路检测dfs 欧拉回路拓扑排序双联通分量dfs F 拓扑排序DAG有向无环图 构造与偏序相容的全序 可以拓扑排序一定无环，无环一定可拓扑排序。因为“有向无环图中必有零入度节点不唯一m”若去掉m可排序则加入m的排序为m在最前 m。 顺序：所有零入度入Stack，取空Q，while S不空{栈顶入Q，如果v邻接u入度1则入栈，并删除v及其关联}最后G删空当且仅当成功拓扑排序 逆序：DFS中每当visited加入S，有backward not dag。结束后顺序弹出S已经ftime由大到小 CH7APP A 双连通分量 关节点删了之后连通分量增多，无关节点为双连通图，极大的双连通子图为双连通分量BCC 找关节点？—通过dfs根至少两子树，内部节点有某个孩子u且这颗子树不能由任何backward连接到v的真祖先（可以backward到v）。这时BCC父亲和BCCu的关节点。记录Highest Connected Ancestor：hca(v) = subtree(v) 经过backward连接的最高祖先。DFS中一旦发现backward v,u，取hca v=min(hca(v),dtime(u))最后标记的是dtime。如果dfsu完成返回v时若有hcau&lt;dtimev则hca(v)=min(hca(v),hca(u))。否则u子树的最高祖先不超过v即可断定v是关节点。而v+子树u为一个BCC Dfs找bcc：额外围护Stack，将当前v入栈。枚举邻居{未发现Evu—标树边，递归遍历u、讨论hca关系确定关节点后持续弹出S直到u弹出这些就是一个BCC；见上}同O(n+e) 推广到强联通分量？618 B pfs 存放顶点并维护priority(v)越小越先 框架{枚举邻居更新优先级和父节点；从undis节点中挑出pri最小的点作为下一个s；标记为访问以及标记好树边（特别的，s的爹已确定） C Dijkstra 均正最短路径树!=MST 更新时发现比较路径长度松弛长的（by set new parent） D prim—MST 允负0 Cayley完全图有n^(n-2) uv是该割的一条极短跨边则一定存在包含uv的MST。反证证明。任何MST都通过极短跨边连接割。若支撑树添一条边的环路中存在其他边为极长边。则原T-f+e为新图的MST。构造中把当前树看成割。正确性：每一条都属于某一MST 6-28？ 实现：比较老pri和权重，后者小则更新pri和parent E Kruskal MST 每个节点都是一棵树，按照边权排序依次尝试使森林变为一棵树。找e来自不同树时可以合并。Proof 引入的每条边都属于某颗MST e一定是割 T的极短跨边。归纳证明。。 并查集union-find问题：维护group[]所属子集快找慢合并。维护parent法：合并时指向新爹即可680？ F Floydwarshall 允负边但不能负环路。For k for u for v A[u][v]=min(A[u][v],A[u][k]+A[k][v]) 8****二叉搜索树 A 中序有序 归纳树高可证中序遍历单调 B 查找—返回引用，可能为空节点表示该插入的位置 插入—查找确定位置，插入后向上更新高度 删除—分类删除{单分支时删除自身让孩子替换，双分支与直接后继交换数值！删除其直接后继}向上更新高度 C 期望树高 全随机排列的平均高度θlognBST越低的权重越大 n个互异节点的不同BST共有catalan(n)棵=sum(S(k-1)*S(n-k)=(2n)!/(n+1)!n! BST等概率θsqrtn 理想平衡：n个节点高度在log2n 渐进平衡—渐进不超过Ologn即为BBST 等价BST可On互转 D AVL树渐进平衡 定义平衡因子=H(lc)-H(rc)&lt;=1 h高度至少包含S(h)=fib(h+3)-1个节点此为最瘦的情况 S(h)=1+S(h-1)+S(h-2)配成fib 插入可能从祖父向上一整路失衡，找到最低失衡节点(一边updH)和儿孙考虑。同向一次zigzag用34实现,异向两次等价于34重构。高度复原，全树复衡。 删除：单旋、双旋情况可能祖先继续失衡高度减小，可能需要logn次调整、 可能全树高度下降 kunth: 0.21次 1D****查区间 二分查右边界后向前检查+输出Or+logn 2D：利用容斥原理n方时间的预处理，矩阵每个点中包含其左下的点的个数，答案正对角线-反对角线 预处理和空间为n^2，每次queryOlogn B kdtree1D—完全二叉each key=Minkey in Rsubtree，即右边区间的左端点。仅最底两层的叶节点是1D点集 2D 每个region左下开右上闭 等价于四叉树划分 递归建树P：如果只剩一个，创造叶节点返回; Root=createKdNode();splitDirection=even(d)? ver|hori; root-&gt;splitline=findmedian(direction,P); 分隔开子点集，并左右递归建树 所属region往左下移 Query：如果是叶区间，判断是否在；左右分别{整个region都在搜索中，report，否则如果有交集则继续递归搜索} 复杂度：预处理Onlogn 储存On 查询Or+sqrtn Q(1)=O1; Q(n)=2+2Q(n/4) 节点的四个孙子不超过两个会继续递归。更高维度？O(r+n^(1-1/d)) C MultiLevelSearchTree 按维度搜索范围，最坏——x搜出了所有点但y拒绝了所有点 On 嵌套树实现 O(r+(logn)^2) 二维建树时空Onlogn 二维以上建树储存都是nlog（d-1）n 查询为r+logdn A 逐层伸展 对v的父亲做zigzag，最坏时分摊Ωn 双层伸展 向上追溯两层， 在双zig或zag时先转祖父再转父亲。使最坏情况的单条路径也能收缩一半。【8-2】分摊Ologn每次旋转之后都要对三代updH 搜索：标准搜索+splay+返回根 插入：搜索后决定在根的左上还是右上插入新根 删除：搜索后删除，在R里面做失败查找Rmin来当根 评价：无需高度和平衡，分摊Ologn近AVL且反复顺序访问子集分摊仅常数 分摊分析：定义势能φT=sum(log(sizev))平衡小倾侧大 单链logn!=Onlogn 满树On 不妨仅考察search 连续m&gt;&gt;n次访问，记Ak=Tk+△φk 则显然T=A-△φ在A+-Onlogn区间内若能证明 A=Omlogn则一定有T=Omlogn ​ 讨论A在单zig/zag中Ai&lt;1+rankiV-randi-1V B BTree d代合并 m=2^d出路和2^d-1个关键码 多级存储中减少外部查找的IO，批量访问一组关键码 外部节点深度相等为树高，叶节点为h-1，内部节点关键码&lt;=m-1&amp;&amp;分支出路：ceiling m/2&lt;=n+1&lt;=m（root&gt;=2）成为(m/2，m)-树 典型(2,4)-树 内部都是vec装关键码和孩子 查找 vec，不成功标记_hot，v=v-&gt;child[r+1]每一深度最多一次IO运行时间Ologn 插入上溢 在_hot中插关键码和空指针，检查上溢：上溢节点中位数归入父节点的子树位置并分裂指针分别指向中位数左边右边，仍然可继续分裂。。到根仍上溢则提升中位数为新根，是B树增高唯一途径 O（h） 删除下溢：如果不是叶子，在右子树中找直接后继交换 1.若有左兄弟且够大，则p节点分界key作为最小，左兄弟最小作为p节点分界。2.右兄弟借父亲旋转修复 3.左右兄弟必有其一但不够用则把父亲的分解key降下来粘接自己与兄弟。但父亲仍继续下溢，不超过Oh Max Height时内部节点尽量瘦logmN+1 &lt;= h&lt;= 1+ log (ceiling(m/2), grounding ((N+1)/2)) C 红黑树 减少结构变化，相邻版本差不超过O1 1树根和外节点为黑 2.红节点只有黑孩子父亲 3.外部节点黑深度相等 即根的黑高度 等价于2,4 B树证明其平衡h&lt;=R+H&lt;=2H 黑高度上界log2,n+1故Ologn 插入：红节点黑高度0修双红{爹是红则一定有黑祖父，1.叔父黑，则局部34重构+染色RBR 2.叔父红，pu转黑（BH++）g转红。分裂节点g上移但g仍可能双红 若已经抵达树根则强行转黑、黑高度++} 删除：仅分析实际删除的，单分支被接替的情况。删除者和接替者一个红时，接替者染黑即可。 ​ 删除者接替者都黑需修正 如果删除根则新根置黑，更新高度即可。若父亲平衡则好，替代节点为红染黑即可，接替和删除均黑（此时接替者为null）{接替者父亲p和兄弟s ​ BB-1兄弟黑且至少有一个红孩子t{ s继承pcolor, tp to black} 等效于关键码旋转消除下溢 转下p转上s ​ BB2-R s黑且两个孩子都黑p红 下溢节点与兄弟合并顺便向父节点借了一个红色 ​ BB2-B s黑两个孩子都黑 p黑 合并兄弟和空空的自己和爹，父节点变空继续上溢 solve（p） BB-3S 红孩子必黑 绕p单旋继续solve （r）下一步必恢复 1~2旋转 3染色/2染色/1染色上升一层/1转2染色 A hash() key-&gt;&amp;entry 期望O1不是O1 B 散列函数 确定快速(期望O1)满射均匀少聚集取质 数模：不动点0，相关性(相邻映射也相邻) MAD (ax+b)%primeM 还有数字分析、平方取中间几位，折叠取和、按位异或、伪随机数、多项式{循环移位异或之后相加，最后模表长} C 冲突排解 开放散列 多槽位、独立链空间不连续无法缓存、公共溢出区处理冲突正比于溢出区规模 封闭散列+开放定址可出借 线性试探：非同义词也会冲突，数据堆积严重、局部性良好。标记以懒惰删除—后查找时为不匹配的非空桶，插入时为空桶 平方试探：表长素数且装填因子小于0.5一定能找到出空桶——n方%M取值为ceiling(M/2)且前面就能取遍 双向平方试探 表长取4n+3素数就不重不漏 素数p表示为平方和等价4k+1 自然数表示成平方和等价于每一个4k+3素因子都是偶次方 再散列：约定冲突后再hash一次为每次的偏移增量 重散列：懒惰标记过多或者装填因子太大 桶排序 初始化置0，扫描标记Om、顺序输出On。允许重复时桶里维护链表和表长空间变Om+n N个互异点在实轴上的最大缝隙？1.找出最左最有并划分n-1个桶 2.模余归入对应的桶并在每个桶中动态记录最左最右点（可相同可没有） 3.计算相邻非空桶的距离 Proof Maxgap至少跨过两桶 但mingap？ 基数排序 从低位开始分别桶排序 Proof会保持前i-1趟的顺序复杂度为O(t*(m+n))m为取值范围，t为数域位数 且有稳定性。。二进制时1扔到尾巴0不管 整数排序 n进制d位 比如六十四位整数的n&gt;2^16即可 在0~n^d中n个数转换进制后排序时间为Odn 转换进制的复杂度。。？ 计数排序 大数据小取值——已经按数字排序的牌再按花色排序：归到四个花色桶中，得到各个桶内的最大rank（向后累加桶内个数）。从后向前扫描原序列并相应桶的–最大rank即为位置。。 跳转表 期望塔高2解决空间On 查找：每一层向后到更大的key or溢出，命中则返回否则向下一层继续。。纵向跳转不超过期望Ologn 横向跳转一定抵达塔顶Thm Ey=(1-p)/p=1次，同层不超过两次，每次查找都在期望2h即Ologn内 插入：查找位置（雷同降落）插入底层后后扔硬币长高 删除时从高到低拆塔 A 支持取删插(sorted) vector list BBST都可实现 B 完全二叉堆借助Vector 插入：末尾插入后逐层上滤，大了就换，不需则停 删除：删头补脚后逐层下滤，找堪为父者交换或停止 建堆：按个上滤时最坏Onlogn-&gt;自下而上的下滤Floyd 从n/2-1开始向上的下滤 C 堆排序 改进selecttion的发动机选最大值，就地算法{建堆后swap头元素和elem[n–]，下滤堆头} D 胜者树 叶节点待排序内部为胜者 createOn removeOlogn insertOlogn 树根是全局冠军。用于排序时建堆后排一个数就下去删除然后向上重赛。。Onlogn 选取最小的k个 n+klogn 败者树：根的父节点是冠军，重构时和败者比赢得向上输的留下。构造时相当于n次重构 E 优先级队列 堆装满顶点 delmax nlogn increase更新关联顶点距离需要elogn d****叉par**:**k-1/d， child=kd+i 上滤logdn 下滤dlogdn 运行时间为ndlogdn+elogdn 取d=e/n+2时达到O(elog((e/n+2),n))自适应达到最优 左式堆后O(e+nlogn) 插入合并inc接口分摊O1 F 左式堆(knuth修订命名) 沿藤合并 基于二叉树 引入all外部节点 定义NPL为到外节点的最近距离且规定npl左孩子&gt;=npl右孩子 自己npl=1+npl(rc) 根右侧链(长度d)的终点为最浅外部节点，存在以r为根高度为d的满子树 至少有2^d-1个内部节点和2^(d+1)-1个节点 反之n节点左式堆一定小于grounding（log(2n+1)）=Ologn 合并：{把较大的堆的右子堆与另一堆合并后连接到较大的堆顶，并根据npl可能交换左右子堆，更新npl1116 插入 merge原树和新节点 删除 merge左右子树 B 暴力 i(原串) j都要回退 C KMP(Knuth+Morris+Parrt) i永不回退 失败时j变小并继续，记录j回到的next表：前缀=后缀的最大前缀右点 while(j&lt;m&amp;&amp;i&lt;n){ if (j&lt;0||T[i]==p[j]) i,j++ else j=next[j]} 分摊分析：K=2*i-j 成功失败k都会至少加1，结束时k&lt;=2n+1 Next表：失败前的后缀=原串前缀len mamammia-10012310 -1 0 -1 1 0 -1 3 1 0 Boyer &amp; Moore****算法BC从末字符开始比对，BC怀字符，遍历Pstr标记字符的最右出现 偏好概率小P长字母表大 策略移动到那里/没出现整个移过去/出现太靠右移动一个 最好n/m 最坏n*m worst: 100in000000？ Gs表好后缀 最好n/m最差n+m 改良kmp反过来找P[j:m]=P[k:m-j]把j-k记录在j里 构造：MS/ss=P[0:j]的某个后缀==P的某个后缀&lt;=j+1 Ssj=j+1: gs[i]=m-j-1任i&lt;m-j-1/gs[m-ss[j]-1]=m-j-1 ms[n-1] = n; int lower = n-1, upper = n-1; KarpRabin d进制数编号 匹配则一定子串相等 将指纹用散列压缩（相邻两次散列，O1内获得下一个指纹） 哈希值相等后仍需精确比对 A 快排mi**=**Partition(lo,hi),递归快排两边 LUG版 随机选一个轴点swap到lo并备份，向内交替移动hi lo 把有效的指向空的后变为空的。最后轴点归位 期望logn 取消递归时维护栈小贪心，大任务优先入栈。保证递归深度不超过logn 落在λn试试，一条递归路径最多log(2/(1+λ),n)个准居中，λ&gt;1/3时有1-1/pown的概率深度不超3log3/2,n 比较次数1.386 LUG‘解决重复，if(lo&lt;hi)elem[lo++]=elem[hi]; DUP’版 松LUG’的交换条件，多交换轴点居中 DUP LGU稳定：从第二个往后如果小于轴点就与++mi交换 众数for{ifc==0 maj=A[i];c=1;else maj==A[i]?c++:c–} Median(vec &amp;S1,int lo1,Vec &amp;S2,int lo2,int n){ If(n&lt;3)return trivialmedian(~~~~~) Int mi1=lo1+n/2;mi2=lo2+(n-1)/2; If(S1[mi1]&lt;S2[mi2])return median(mi1,lo2,n+lo1-mi1) Else if{} else return S1[mi1] 任意子向量Ologmin(n1,n2) 第k+1小 选pivot进行LUG后缩小范围继续猜 Linearselect:Q是小常量，如果序列小于Q为trivial，划分子序列；各自On*n排序找到中位数；递归找到全局中位数；划分LEQ计数；每轮缩减到3/4子问题 ​ 希尔排序 矩阵变窄，每次对各列排序。对希尔序列的最坏情况 6 7 8 52 3 1 4 g有序在h排序后仍g有序 当gh互质时，最小组不出来为gh-g+h 则gh有序后其线性组合依然有序 gh互质时for all elems: i-j&gt;x(g,h) only if S[j]&lt;=S[i] 不超过n*x(g,h)个inversions","link":"/2022/01/02/2021Fall-DSA-cheatsheet/"},{"title":"2021秋季学期 形式语言与自动机 期末复习","text":"丢失图片，没有渲染后的pdf版。。。 FLA Final ReviewSlides Reviewlect1 字母表，形式符号的非空有限集合 字符串或字 字母表的0次方为{epsilon}，递推定义 语言：任何字母表星闭包的子集 证明：逆否证明，反证、互归纳，提出多个原子命题互相证明，一般具有某正对称性和推论关系 归纳定义：基础、归纳递推规则、极小声明 lect2 上下文无关文法 T V S P 自下而上递归推理叫归约，自上而下叫推导 推导传递闭包，通过归纳定义，递归基是自己推自己 最左：总是替换最左非终结符，推导加* 句型：能够由S推出来的状态，有左右句型之分，全是终结符叫句子 def 上下文无关文法的语言为上下文无关语言 构造：对称拆分不等关系变大于小于 控制范围的可以两边夹 计数题：找唯一分割点 count a=b S-&gt;aSbS|bSaS|epsilon 差2的找轴点切分 计数不等于：第一次a比b多停下，前面相等，中间a，后面a不少于b（通过可以单增a实现 证明文法和语言等价：归纳w的长度和推导步数（讨论第一步所使用的产生式） 经常互归纳一些中间状态的含义。。 chomsky 0：图灵机 α推β α中至少一个非终结符 1 α长度小于等于β（可以S推epsilon） S不出现在任何P右边 上下文有关 线性有界自动机 2 一个非终结符号推β 上下文无关 下推自动机 3 A推aB 或者A推a 正规文法 正规语言 有限状态自动机 语法分析树，内部非终结 叶子可终结可不终结or空 产生式是父子关系 果实是连接叶子的句型 可归约 存在推导 存在最左 存在最右 存在根节点A分析树果实为w 等价 归约：归纳步数讨论其最后一步产生式（其实为推导的第一个产生式） 归纳分析树的高度，递归的时候归纳第一层的产生式 证明推导到归约 归纳于步数 二义性文法：对某个w存在两颗不同的分析树or存在两个不同的最左推导，二者等价 不可判定的，不存在算法 如果语言的所有文法都是二义的，则L是固有二义的 什么是最左推导？ lect3 正规表达式的语言是正规语言 可以联合并集+ 连接· 星闭包 定义正规表达式集合：字母表都是，空字符和空集都是，变量（可以包含任意的其他变量和递归基础符号和字母）都是 归纳：可+ 接 星闭包和括号 ？是空+L L零次方为空字符 定义正规语言 {epsilon}和空语言是正规的，单字母正规，正规之间的并 接和星闭包正规 设计时一定考虑边界情况，讨论结尾，关注长度限制！空，单0单1等等 利用空字符达成位置的位移“前x位至少包含x个1” 代数定律：语言之间的运算可以直接全部替换成简单符号表达式。 应该不考的证明。。 推论： 应用：证明语言运算之间的代数定律直接用具体字符替换之后证明即可 lect4 有限状态自动机PDA 状态集、输入符号集、转移函数、开始态、终态集合 记得转移图、转移表上标Start、箭头，终态双圈、星号 对每个状态都要有全部的接受符号转移 这里的转移函数只有q和a=新q，拓展到多步a变w。定义拓展时候w=xa拆开的最后一个符号 可以证明DFA的语言是正规语言：一般可以互归纳证明中间状态的含义，从初态到某个状态当且仅当转移函数的w包含，需要证两个方向。。 构造PDA：不包含就把包含的终态调换，箭头调换为回文，设置垃圾桶节点 非确定自动机NFA，可以转多个或不转，转移函数的值是状态集合，扩展转移函数是所有可能在的状态尝试转移之后再并集。所以w转移之后与F交不为空即可接受。 设计：随时都可以尝试xxx NFA DFA的等价性：D转N把每个转移函数的结果都加上{}变成集合 两者都是归纳于字长 N转D 子集构造法 一定想着标记开始和结束。从起始状态开始走到哪写哪。意义在于可能到达的状态，正确性证明：任意w代入初态开始的转移函数在两个自动机中得到的值都一样。最坏2^n个状态 文本搜索的NFA和转DFA规则？？借题复习 带空转移的NDA，可以用转移图、转移表表示 特殊的空闭包ECLOSE就是自己和自己空转移的可达状态，转移函数则为每一步都要ECLOSE闭包，算的时候闭包和转移间隔着算 语言：仍然和DFA等价：DFA转空NFA—没有空转移则但可接受空字符到自己，每一个转移函数结果变为集合 空NFA转DFA：自己构造法，每一步都需要做闭包。证明正确性归纳于字长： 构造空NFA处理那种“前几个里面至少有一个x” 合理运用空转移等价于(0+1+epsi)^x 特定子串情况时尤其考虑好子串的重叠 填表法确定状态偶对，如果状态可区别则其共同前驱可区别，先区别所有终态非终态。之后看表的疏密程度选择由转移表填图还是按图找转移表。在题目里面复习 优化DFA：删除不可达，填表找偶对，删除该删除的等价类只保留一个，构造 lect5 证明DFA是正规语言：给DFA转re和RE转空NFA Thompson构造：相加：左边两空右边两空，新增两个状态四条边 拼接：新增一条空转移边 星闭包：画飞碟上回下进，新增四条空转移和两个新状态 DFA转RE：KLEENE构造和路径消去 Kleene：计算Rkij，k=0为中间不经过任何节点，不同节点没弧线为空集，有弧线为a，多条相加 ij相同空加所有a 迭代Rkij在k！=0时候：一步过不经过k和经过k转几圈再过去 状态消去：消去两入两出带自环的中间态：到该节点转几圈过去，对每一个终态都消到只剩下该终态以及初态。最后要么剩两个要么剩一个。剩一个就是自环的星闭包，剩两个就是（自转+过去转几圈回来）*过去在终态转圈* 这两种都是n^3 * 4^n的复杂度 Lect6 Pumping 用来证明不是正规语言 pumping特性，任何一个长度不小于状态数目的字符串所标记的路径上必然出现重复状态，n长度涉及n次转移共n+1个状态。 引理：正规语言L，存在常数n&gt;=1，使得任意长度不小于n的字符串w在L中，都可以分成三个部分满足以下条件：y不是空，xy小于等于n，对任何k&gt;=0都有xykz在L中 证明不是正规语言：如果是正规语言，则存在一个n，随便取一个长度大于等于n的串，证明其任意符合y非空，xy&lt;=n的分割，都没有xykz一定属于L 一些判定算法 判定是否非空：DFA递推求出所有可达状态，若包含任何终态则非空 RE 特殊的空语言的0次方应该是空语言 根据正规的四种运算从小的判定起，复杂度On 判断是否包含特定字符串：DFA：处理看在不在终态，NFA转化DFAor处理看集合中有没有终态 RE：转化空NFA执行 判定两个正规语言相等：都转DFA之后重命名使之不重名，两个相并，终态仍终态，转移边不变。取任何状态为初态？？填表算法看原来的初态是否可区别 On4可降On2 正规封闭运算：并星闭包连接都可以由RE证明 补：也是正规语言，DFA的所有终态和非终态对调即可 交：也是正规语言，就是L补并上M补再整体取补orDFA：使用状态的笛卡尔二元积， 差：也是正规语言，是M取补再和L交 反向：也是正规语言：分别对RE中的三个基础（空语言 空字符和单字符）四种运算证明or构造DFA把转移弧反向，初态为终态，所有终态空字符连接至超起点 同态：正规语言同态后依然是正规语言 这个T*是嘛玩意？ 归纳证明于RE的三个基础与四种运算 反同态w为什么不直接是字母表而是星闭包？？仍然也是正规语言，用DFA证明： 构造一个状态集合以及始末都相同的DFA B，字母表改成h的定义域表，转移函数为这边的a是那边的h（a）构造好DFA即可，可以归纳与w字长证明正确性 q0经过w==q0经过h（w) 构造反同态dfa相当于构造原集合的转移，先按字母表讨论再去DFAA中找这条路径能到哪 Lect7 Push Down Automaton PDA带有堆栈的有限状态自动机 七元组{状态集合，接受字符，堆栈符号，转移函数，起始状态，开始堆栈符号，终态集合} 其中状态转移可以接受epsilon，不用给全所有可能（默认不写的转移函数值为空集），但栈顶和输入符号确定时值唯一 状态转移函数接受δ（状态、字符、栈顶）=状态+栈顶 新压入的放左边（左边栈顶） ID表达格局（q，w，γ）状态，剩余串和栈内容 定义ID推导关系 定义自反传递闭包* ，自己推自己，且可传递。。 这里可以归纳于步数证明，自反传递闭包的推导中字符后面带东西和栈底有东西都不影响 终态接受语言：ID处理完w后能到终态，栈无所谓 空战接受语言：ID处理完能到空栈，可以不规定终态 从空栈到终态：新增栈底元素X0，增加超起点用来压入原空栈的栈底元素并进入空栈PDA的起始点。对空栈PDA的每个状态都增加一个空转移可以把新栈底元素无偿弹出成空连接到超收点。 相当于：在原来空栈接受的栈低下垫了一层新的栈底元素，原来的栈只要空了就有机会从任意状态直接弹出新栈底干到终态去。 从终态到空栈：同样增加新的栈底元素，新起点连接老起点负责压入原栈底，在每个终态都可以直接空转移弹出所有到超收点。超收点也是无条件空转移弹出所有栈元素 构造PDA：“任意前缀中a至少是2倍b：a压1个b弹两个才能回来 a数目和b数目的累计：记录栈中是a多还是b多多几个，a每多一个栈多一个X，b Y，b遇到X弹出…… 最后要求栈里面不空就空字符+X（Y)才能转到终态。 a=b且不含连续c：处理连续c—不入栈但把状态拐出去下一个一定得是a或者b 思考：对于计数来说多用栈解决，对于正规就能搞定的连续之类的问题多用状态（包括压栈时候的一些二倍关系）搞定。最后检测栈里面必须只剩下Z0 可以一次性压入两个但是不能弹出两个，因为只能更换栈顶那L7P23压两个不行吗？ 三个阶段的时候比如一定是若干a若干b若干c，阶段间转移建议用空字符+不变栈顶 为了表示“随时可以开始下一阶段”比如判断回文，不知道中点的时候需要尝试 lect08 从CFG到EPDA 一个状态，接受Terminals，栈里面非终结终结都有，开始符号就是栈底元素 所有的产生式都是空转移读栈顶替换成新的，所有的终结符都可以与栈顶对应之后消掉。非终结符只处理栈，终结符的处理字符串同时消栈直到非终结符在栈顶 “PDA的转移函数右端可以是个集合有多个不同结果吗？？？空字符看来一定可以，具体字符呢？” 证明正确性：归纳于最左推导的步数n ，讨论第一步所用的产生式 归纳于ID推导的步数n，讨论第一步产生式 从EPDA到CFG 初态能到任何[初态，栈底符号，any状态] 对原PDA中任何产生式，都有[p X pk]–&gt;a[q X1 any] [any X2 any]…… [any Xk pk] 每个转移函数对应：新栈顶*状态总数 特别的 弹出操作新栈顶为epsilon时only a on right 特别的 新栈为空+转移字符为空时候左边为空 证明正确性： LEct9 确定下推自动机 默认是终态接受的DPDA 确定的栈顶、字符转移函数的值只有一个元素即集合只有一个元素但仍为集合+如果有非空字符的转移则不能有相同状态相同栈顶的空转移 判断回文的经典自动机DPDA的话中间得有个标志，不然没法实现“随时都可以尝试进入下一阶段的处理”中的随时。但是虽然确定也不用每个状态写满 结论：正规语言一定存在DPDA的表示，从对应的DPA继承过来即可，可以对w的字长归纳证明 归纳时候拆成了w=x a ，先用归纳假设干掉x之后 根据继承产生式干掉a DPDA的能力强于DFA 如WcWR不是正规语言（by pumping） 前缀性质：不存在互异的x y串在L中且x是y的前缀 L$一定具有前缀性质 一个语言L是某个空栈接受的EDPDA P的语言 iff L具有前缀性质且是某个FDPDA P‘ 的语言？比如经典的回文，具有前缀性质且L是某个DPDA的语言，则L也一定是某个空战接受的EDPDA的语言 存在上下文无关语言不是任何DPDA的语言（确定的上下文无关语言）不需证明 例： WWR 语言是空栈接受的DPDA的语言时L存在一个无二义文法（参考空栈PDA构CFG的方法，且有唯一的最左推导。。） L是某个DPDA P的语言则L存在一个无二义的文法 Proof：使用L$构造一个具有前缀性质的语言，根据上一性质得到无二义的G’，把$作为非终结符加上产生式$推epsilon 由上两条：固有二义语言不是任何DPDA的语言 但是也有非固有二义语言不是任何DPDA的语言比如WWR Lect 10 CFG简化与chomsky范式 符号（包括V和T）：生成符号（能推出w）、可达符号 （能被S推出的一部分）在一起是有用符号？不一定，可能有一个生成又可达的但是和一个无用绑定在一起被生成，为无用符号 消去所有非生成 再消去所有非可达，就剩下都是有用且与原文法等价。计算生成，删除，计算可达，删除。 如何计算生成符号？所有T都是生成符号，如果右面都生成则前面的A一定生成。不重不漏Proof？ 计算可达？S可达，左面可达则右面所有皆可达 不重不漏 Proof？ 可以为了简洁把V换名字 消去epsilon产生式，可致空符号能推导出epsilon：基础，右边都是可致空则左边也是 不重不漏 先计算所有可致空符号 在可致空符号出现的地方讨论其出现或者不出现。特别的，单推空的直接删去。这样的与原来相比不能产生epsilon别的不受影响4 Unit产生式 A-》B unit偶对当且仅当A能在*步推出B且该推导只使用了unit产生式 需要计算所有unit偶对：每个字母和自己一定是unit偶对；如果AB是偶对，B-》C则AC也是偶对。不重不漏 计算偶对；对每个偶对找到最后那个非偶对的V比如A-》B B-》α 则加入A-》α删去unit产生式 但是保留B推α，可能产生不可达！ 最后在偶对的推导链上把前面的都连到最后一个 简化CFG：消除空产生式、消除Unit产生式、消除非生成符号、消除非可达符号。这样的与原G只差空字符 Chomsky范式：任何不含空字符的非空上下文无关语言都存在一个CFG G产生式只有两种：一推二非终结符、非终结符推终结符。这样的文法叫做。。。 对前文的工作（右边长度1的只有终结符）之后再： 如果有非终结符a出现在右边长度大于1的，则引入新的非终结符替换掉，并加上A-&gt;a 至此右边长度大于1的产生式只有非终结符 对于右边长度大于2的采用级连cascade方法转变为——对A推出k个，引入k-2个新V替换掉 实质上是对此在二叉化。。 与原L只差空字符 CKY算法：判断某个串 属于某个CFG和分析树 先左再上，手指指着更新的时候（紧下列向下滑，右下向左上滑） Lect 11 上下文无关语言的计算 Pumping引理：设非终结符数量m，取字长不小于n=2^m的字符串z，考察其分析树： CNF后为二叉，叶节点为n个，则h-1&gt;=log2,|z|&gt;=m，设从根节点S的一条最长路径S A1……Ak 至少为m+1 必有重复节点在A这条路中。划分为uvwxy，则一定可以pump v和x，其i次方都应该合格 理解为某个广义产生式（推导关系）可以递归 Lemma：存在正常数n，使得任意长度不小于n的字符串z在L内，都可以分成uvwxy五部分且满足：vx不空，|vwx|&lt;=n 对任何k&gt;=0 都可以pump v与x 用来否定 假设是CFG，则存在一个整数n满足pumping引理，取一个串&gt;n 讨论符合规则的五段划分，证明其都不能pump起来（都存在一个pump次数k使得串不再是L中） 判定CFL是否为空：计算生成符号之后看S在不在，On方降On 判定是否包含特定字符串：chomsky之后CKY On3 不可判定问题：无二义？固有二义？两个CFG相交为空？相等？给定CFG是否是字母表* 封闭运算 替换：如果任何字母表中的a，s（a）是CFL且L是CFL则替换后s（L）也是上下文无关。 证明：分析树每个叶节点a替换成s（a）的分析树 映射每一种字母表中字符到一个语言称为替换，可以替换a，w（拼接替换字符）甚至L（w的替换并集） 并：两个CFL并也是CFL 替换{0,1}中0为L1,1为L2 ，即得 *闭包和+闭包：都是CFL 也是替换掉{1*}中的1为L则得 连接：{01}分别替换为L1 L2 同态：替换s（a）={h（a}}，则s（L)=h（L) 反向：L是则LR也是（每一个都Reverse），证明：构造G后尝试构造G’ 产生式中每个右端都reverse掉，这样的G‘就是LR 归纳于推导长度证明？ 交 补 差 都不一定 交出0^n 1^n 2^n后不是CFL但是n n i 和 i n n都是 CFL与RL正规语言的交一定是CFL 、 根据DFA和FPDA构造 反同态仍然是CFL： Lect 12 Turing Machine 基本图灵机：带与带头，空白符B 七元组{状态集合，接受字符集合、带符号集合、转移函数集合、开始状态、空白符、终态集合} 转移函数为偏函数从状态和带符映射到状态、带符和方向 ID表达格局：带头表示为当前状态，后面是正在扫描的单元格cell 前后需要空白之中的符号串但是也可以有B串 ID推导，特殊的可以往两边推，如果带头到了B上则写B，如果把最右/左端写成B则可以省略 一般计数的思想为匹配：从左往右跑一趟就是匹配了一组数，再回去再跑。。 可被图灵机接受的是递归可枚举语言REL 定义TM的语言是使得q0w 推出 终态的串w集合 halt：不存在下一个移动，与原来的图灵机语言相通但是接受w之后停机不再移动。总是假定图灵机到达终态之后停机（对于可接受的w） 递归语言：当且仅当存在TM M使得LM=L且如果语言中的w，M接受自然会停机，非语言中的w输入M中也会停机（但是无法到达终态） ——对应的问题是可判定的 带存储区的状态：状态有有限个取值，其实是带头有个存储区可以在移动的时候改变。适用于一些分类的情况如 与经典图灵机等价（状态变成了二元组而已） 多道图灵机：也是基本图灵机但是纸带是原来的三倍宽，即每个带单元格可以表示为三元组 编程技巧：在图灵机中融入子例程干一件特定的事情 多带图灵机：初始输入符号串在第一条带上，其他所有带的单元格都是B；有限控制位于初态；第一条带头在输入串最左，其余不定。可以有3（多个）带头。每一个move中，控制进入新的状态，每条带上正在被扫描的符号被替换为新带符，每个带头独立的向左、右、不动。 其能力等价于单带图灵机：用2k道模拟k带图灵机。 非确定TM：转移函数右边是三元组的集合，仍与确定图灵机等价。双带图灵机可以模拟非确定。广度优先的方式模拟非确定性图灵机的整个ID‘s空间树 受限图灵机（都与基本TM等价）：半无穷带（双道半无穷即为双无穷）、多栈机（k个下推栈可以用k+1条带的多带TM模拟（一条扫描，剩下k条下推），两个下推栈就可以模拟一般图灵机，其中一个是带头左边单元格，另一个是当前以及右边单元格）、k计数器机（多个非负整数的计数器，控制时只知道是否非零——特殊k多栈机，一个计数器就是DPDA,两个以上就是TM 普通计算机模拟图灵机，说明计算机不弱于图灵 以多带图灵机模拟普通计算机（TM不弱于现行冯诺依曼计算机）： Lect 13 Computing Theory 图灵机与输入串的二进制编码：假定输入01串，有限状态1~k，规定始末态12，带符号X1到Xm且X1为0 X2为1 X3为B 假定带头移动为D1D2分别LR 单1间隔转移规则中的元素，双1间隔转移规则，三1前面是输入串编码（前面需要加个1？）后面是图灵机编码 编码01串：任何01串编码为1w比如 / 空：1/ 1:11 / 0:10 / 00:100 L13P6？ 对角语言——不是递归可枚举 按照上述编码每个TM对应整数i 即其二进制编码是第i个0 1字符串，但不是每个整数都有图灵机对应。认为第j个图灵机不接受任何串，这样定义对角语言： 递归语言补运算封闭，递归语言的补也是递归语言。 递归可枚举语言的补运算不封闭：反例：通用语言 如果语言和语言的补都是递归可枚举的，则一定都是递归的 通用语言——递归可枚举但是非递归， 语言对应的问题：“任意给一个串w在字母表*内，判定w是否是L内？” 通用语言对应的问题：“任给图灵机M和输入串w，判定w是否被M接受？“ 图灵机停机问题：任给TM M，以及输入串w试问对w，M是否停机？—— 如果问题所对应语言是递归的，则该问题可判定，否则不可判定。语言递归可枚举贼该问题部分可判定，否则非部分可判定 问题的归约？ TM的时间复杂度，最多T（n）步停机，无论是否有w是M的语言。则为Tn 非确定的时间复杂度：任何转移序列","link":"/2022/01/06/2021Fall-FLA-final/"},{"title":"2021春季学期 面向对象程序设计基础 期末复习笔记","text":"My Object Oriented Programming Habits class中的数据变量英文命名写全并且每个单词首字母大写，构造函数传参数时参数名称全大写 private数据成员在public中获得函数用get_Data（）命名 记录期末之前上课&amp;题目5.24 W14 1-1 function&lt;returntype(parameters)&gt; 类型可以统一函数指针和函数对象，如果将function&lt;int(int)&gt;作为函数参数则可以将所有以int返回值int参数的函数或者int返回值int参数的对象都可以传入并不违法【/统一了函数对象和函数指针/】 5.29 HW14-15 string.c_str() 返回一个const char*为string内部存储的数组结尾是\\0，为了保证不用外部char指针修改string这个const无法初始化char*类型。将string转换成char*应该用int copy(char* tar,int lenth,int pos=0)返回实际拷贝的字符数目。 string类的拼接操作+时间复杂度为生成的字符串长度，用+=更快 5.31 W15 1-1 string拼接操作速度：+= &gt; string.append( string) &gt; stringstream &gt; + 5.31 Review L1-L3 带缺省值参数函数不算参数个数，去掉缺省值参数后如果其他参数都一样会产生歧义被拒绝 auto后面定义的变量要同一类型 auto i=0; and decltype(i) b; 即decltype（） xxx为类型说明符，后面可以带个参数为“定义一个和这个参数一样类型的变量xxx” auto作为函数返回值类型要在参数列表后面加-&gt;decltype(returnvalue表达式) NULL是int型常量0 nullptr是严格空指针 Function f1(int a,int b=1)and f1(int a=2)即使一个是private不许访问但是仍然会ambiguous二义性错误。 inline ReturnType Function(); 遍历某个范围的for循环 12345678910111213141516171819202122int arr[3] = {1, 3, 9}; for (int e : arr) // auto e:arr 也可以 cout &lt;&lt; e &lt;&lt; endl;如下程序无法过编译会导致二义性#include &lt;iostream&gt;using namespace std;class A {private: int a; void f(int i=2) { a = i; }public: void f(int i, int j=2) { a = i + j; } int get_a() { return a; }};int main() { A aa; aa.f(1); cout &lt;&lt; aa.get_a() &lt;&lt; endl;//二义性 return 0;} 5.31 Review L4 初始化列表顺序并不是初始化顺序，初始化列表时应用声明顺序进行初始化 后缀运算符++需要哑元dummy，要把原本的数据增加之后返回的值仍然是增加前的，可以先复制原对象然后给原对象++，最后返回原对象的复制。 =，【】，（），-&gt;这些只能通过成员函数来重载 流运算符重载 1234istream&amp; operator&gt;&gt; (istream&amp; in, Obj&amp; dst );ostream&amp; operator&lt;&lt; (ostream&amp; out, const Obj&amp; src );需要声明为类的友元以便访问私有对象，在类外（全局）进行重载的定义friend istream&amp; operator&gt;&gt;(istream&amp; in, Obj&amp; dst); 5.31 Review L5 友元函数可以是其他类的构造、析构函数，也可以是其他类，也可以是全局函数 static普通静态变量与函数：初定义要初始化仅一次，内部可链接，作用域仅限声明文件cpp不能被其他cpp所用 static静态成员变量：归属于类而不是具体对象，所有对象可共享。通过obj.var和classname::var均可访问。在实现文件赋初值VarType ClassName::static_var=Value. 需要在h中声明cpp中定义，h定义会导致包含h后重复定义 static静态成员函数：static关键字在ReturnType前，类和obj都可以访问，不能访问非静态成员，即属于整个类的函数只能访问类变量 常量数据成员：初始化后在该obj整个生命周期中不能改变 常量成员函数：const关键字在函数体前Function（） const{...}不能修改class的成员，只读而不可写入，常量对象只能调用const成员函数 拷贝（传递参数）时如果有指针成员容易出错，直接位拷贝指针不变而同一块内存会释放两次 5.31 Review L6 不想给某个函数修改值的权限则使用const参数 拷贝构造函数参数：同类对象的常量引用 自动合成为Bitwise Copy遇指针出错 常（左值）引用可以绑定右值，引用本身为左值 右值引用在延续即将销毁变量的声明，提升处理效率，即把本要销毁的变量引用了变成了不销毁的左值——移动构造函数参数：同类右值引用 移动构造函数需要：1.复制指针地址或者值 2.将原指针地址改0避免释放 使得生成的临时对象被保留下来，本该释放（析构）时发现指针为空，不能释放内存，而真正有意义的指针（数据）被移动保留了下来 原则：不浪费任何右值（创造右值之后不销毁，及时利用） std::move(左值)，把左值当做右值用，需要这个左值不再被使用或者即将被改（swap） 类型转换函数的自定义 从Src到Dst类 1234567class Src{operator Dst() const {}}或者在目标Dst类中定义常量引用为参数的构造函数class Dst{Dst(const Src&amp; s){};} 5.31 Review L7 构造函数和析构函数，复制运算、友元不能被继承 use using关键字来使用基类的（所有）构造函数 基类的私有成员在派生类函数中也不能访问，只有基类的成员函数中被访问。而公有成员成为派生类共有成员可以被访问。protected成员可以在派生类成员函数中访问但不能在外部函数访问 重载Overload，函数名必须相同，函数参数必须不同，作用域相同。（编译多态或者属于静多态） 重写隐藏其实就是Redefining，重新定义基类函数实现特殊功能，屏蔽了所有同名函数，参数可以同可以不同（运行时多态、动态多态）using 类::成员函数来解除屏蔽） 6.1 Review L8 凡是可以接受基类ptr或obj，都可以直接接受派生类，会自动切片 通过对象的向上类型转换可以访问private继承无法访问的基类成员变量coz向上类型转换只可以Public继承，不允许私有继承向上转换 带有虚函数的class，对象大小会加上一个指针（8），多个虚函数也只有一个Vptr指向vtable 虚函数机制在构造、析构函数中不工作，构造不能虚而析构经常是虚的总是将基类的析构函数设置为虚 虚函数Feature重写覆盖必须要函数名参数表一模一样，这样会根据运行时实际类型进行动态晚绑定 在函数体前面加override关键字检查是否成功重写覆盖 函数体前加final关键字——禁止继承后再覆盖，已经是最终版本的函数实现 6.1 Review L9 （形参）之后加=0声明为纯虚函数，含有一个纯虚即为抽象类无法具象化出对象，只为了之后的继承类实现共性“接口”或者“方法”。一般是没有实际物理意义的抽象（shape，creature） 纯虚函数必须被之后要使用的继承类重写覆盖，不然仍然是纯虚函数而该类为抽象类，即必须把所有纯虚函数实现一遍 纯虚析构函数仍需要函数体，即声明纯虚=0之后还要写一个空实现函数体，后面不用显式地重写覆盖 使用基类指针数组管理具体派生类对象，具体处理时转化成专用指针调用专用接口 使用dynamic_cast&lt;tar*or&amp;&gt;(obj_p or obj_r)如果失败返回nullptr，用来判断实际类型 static_cast不检查实际类型，只要有继承关系就转，dynamic会动态检查，慢但是安全 向上类型转换：指针和引用时不改变虚函数表（晚绑定，仍按实际类型调用继承重写函数）而直接切片为基类对象会丢失增加数据和方法 dynamic_cast正是通过虚函数表判断是否安全地进行向下类型转换 多重继承：Best Practice 最多继承一个非抽象类，可以继承多个抽象类（接口） 多态（接口函数根据实际派生类而不同表现）效果条件：继承&amp;&amp;虚函数&amp;&amp;（引用or指针） 模板：算法实现与参数类型无关，则将函数的参数类型定义为一种特殊的“参数” 调用函数模板时，可以手动输入“模板参数”也可以让编译器自己认。实现原理：编译期将模板替换为需要的类型生成一份对应的函数代码，需要多少不同的就生成多少 模板使用： 12345tmplate &lt;typename T&gt;class A{};ortmplate &lt;class T&gt;ReturnType Function(){} 类模板中成员函数类外定义前要声明一下同样的模板，模板参数编译期确定不可使用变量 模板也是同一段代码实现不同的相似功能，但是在编译期处理为“静多态” 6.1 Review L10 标准C++库所有内容都在标准命名空间std里，包括stl标准库 不同命名空间中的同名函数、变量等命名不会互相冲突 自定义命名空间namespace A{int x,y;}使用时A::x and A::y，用using namespace直接使用这个命名空间的所有成员，也可以using namespace::var or ::func 直接使用某几个函数 Containers: 简单、序列vec,list、关系set,map 12345 template&lt;class T1, class T2&gt; struct pair{T1 first;T2 second;//若干其它函数 }; 支持 .first .second make_pair( , ) &lt; &gt; 按照第一第二比较 tuple：类似pair，无限长，使用v0=get(tuple_var)且pos需要编译确定，不能使用变量 支持make_tuple(,,,) tie(x,y,z)=make_tuple(xx,yy,zz)即tie返回左值引用的元组，可以利用右侧的tuple来一次性多重赋值 vector支持：vec[pos] vector vec0 .size() .clear() .push_back( xx) .pop_back(xx) use iterator to .erase(x.begin()+1,num) .insert(iterator)而iterator支持*，可以直接sort，支持++ – += -=支持减法运算 迭代器失效：insert和erase，和改变大小时可能会扩展capacity而整体迁移所有it失效，修改过容器后不使用之前的迭代器 list：快速的增减push_front() push_back() find(l.begin(),l.end(),tar) l.insert(it,tar) 不支持下标，插入和删除时不相关迭代器不失效 set：不重复元素构成的无序集合，只是不保持加入顺序，内部按大小排列 支持insert（） 查询find（）返回迭代器 erase（s.find(val)） count(val)只有0或1 map：关联映射 其实为&lt;Key，T&gt; Key必须互不相同 通过下标map[key]访问val如果不存在则创建对应映射 支持insert(pair)插入 查询find(key)返回it 统计count(key)要么0要么1 支持erase(it) 6.1 Review L12 构造方式s3(“string”,num)num为截取的长度（num,’x‘）赋值num个x，（it1，it2）迭代器 string.c_str()返回一个const char*不能修改，涉及底层实现，不能赋值给char*需要copy(ptr,n,pos=0) size()orlength() clear() empty() push_back(‘a’) or append(s2) 字典序比较 cin&gt;&gt;读到空格 getline（cin，str）读一行不包括/n getline(cin,str,’#’)可以读换行一直到终止符# stoi（“2001”） stoi（“50 cats”，&amp;sz）sz为读入长度 stoi（string，nullptr，进制=0）默认自动检查进制，可以stod转化double 库中格式控制函数fixed scientific setprecision（2） oct dec setw（3） setfill（’‘）设置对齐长度为3且填充字符 使用stringstream拼接字符串，也是stream可以赋值于var ss&gt;&gt;a&gt;&gt;b 正则表达式https://www.runoob.com/regexp/regexp-intro.html菜鸟教程https://blog.csdn.net/bgzclxqq/article/details/90262904 CSDN关于C++的正则式 6.1 Review L13 声明函数指针 ReturnType (*ptrvar)(parameters)，可以直接赋值，甚至可以直接auto指定类型 less()和greater()为自带的比较函数,其实是个对象，长得像个函数 greater是一个模板类 greater 用int实例化的类 greater() 该类的一个对象 函数对象需要public重载()运算符 把函数当参数需要声明：template &lt;class Compare&gt; void sort(Compare comp)可以接受函数指针和函数对象 智能指针shared_ptr&lt;T&gt; p1(new int (1))也可以make_shared(2) 或者拷贝构造同类 重载了*运算符直接访问对象 也可以-&gt;访问成员 自带引用计数use_count()引用全归0才自动销毁对象 实现原理： 获取常规指针.get() 清楚并减少引用.reset（） 可以用static或dynamic_cast&lt;&gt;(p) 不能使用同一个裸指针初始化多个智能指针 即辅助指针U_ptr只能有一个不然多次释放 存在循环引用永不析构问题weak_ptr指向对象但是不计数wp.lock()转换智能指针 unique_ptr确保一个对象只能被一个指针指向（引用） 不能赋值指针，可以移动up2=std::move(up1) 使用release放弃up控制权并返回裸指针 6.1 Review L14 模板方法：抽象出不同具体类的骨架，写出通用的基类并且将步骤的实现延迟到子类中（设置为纯虚函数）。不改变算法结构而重新定义一些实现步骤。 父类定义骨架，子类实现细节，需要新的实现重新继承即可 策略模式（strategy）：定义一系列算法并封装，可以互相替换 对不同的每个子任务（方法）都写出基类Strategy然后继承出具体实现类，实际调用的框架中只需要管理（存储）这些方法的基类Strategy指针即可 策略模式符合“单一责任”原则：一个类or接口只负责一项职责，功能层面解耦 .迭代器模式：基于Iterator基类，实现不同聚合对象的顺序访问，使得接口统一而使用方法统一 6.8 Review L15 结构性模式——适配器Adapter、代理委托Proxy、装饰器Decorator 适配器模式：客户期待接口基类Stack中有各种接口，现在有一个写好的类似功能类Vector，想加一层Adaptec使得代码继续复用 Adaptee——Adapter——Target——Client 实现： 组合——把Adaptee放到Adapter中当成员，继承Tar基类，挨个实现要求的函数 继承——公有继承Tar和私有继承Adaptee类，即er类就是ee和tar类，实现函数时直接调用ee中继承过来的函数即可 代理委托Proxy：客户要求的基类接口，有一个RealSubject继承了基类接口可以满足需求，但是需要更多功能和控制操作 Client—BaseSub—Realsub&lt;—Proxy：BaseSub Programer—ProxySub（derived from BaseSub）has a RealSubPtr 实现BaseSub中的函数，函数体{Ptr-&gt;Request; other commands;}实现了包装并增加。 装饰器Decorator：无限的增加新功能，每次增加几个功能并可以无限进行这个装饰的过程。装饰器是定义一种递归模式，方便之后的功能继承这种模式 实现：装饰器:public Base 私有基类指针，构造函数接受一个基类指针（这一层装饰之前的类的指针）并存储。定义虚函数addon（）为每一层装饰的新功能，定义常规需求函数Draw{add（），ptr-&gt;draw（）}。具体增加功能的时候需要功能类继承装饰器类然后实现add函数为新功能 魔兽争霸学技能：学技能类（Decorator） 具体学了什么（继承Decorator的类）构造，一级级学技能上去。 123456789101112class Decorator::public base{ base* upper;public: virtual ReturnType addon(){} ReturnType Request(parameters){ addon(); upper-&gt;Request; }};//crearte a decorator pattern 构造：基类—装饰递归结构—装饰1—装饰12—装饰123 调用过程（解嵌套）：装饰123—3Draw，指针变为装饰12—2Draw指针变为1—1Draw，指针变为基类Draw 6.10 FinalExample： 不能继续使用（using）纯虚基类的构造函数 使用虚函数机制时把基类析构函数生命为virtual list的迭代器是双向的，甚至可以反向迭代。反向迭代器rbegin（）和rend（）其自增运算++为向头变换 迭代器失效仅有erase操作的迭代器，其他任何迭代器不受影响。而且list迭代器太牛了，锁定自己的元素不变，也就是说指向链表中的某一个元素。头迭代器和尾迭代器在中间插入元素后依然是头尾不需要改变。 list中的insert是在迭代器it之前的位置插入元素，并且迭代器仍然指向原来元素（链表特性） list为空时，用insert比较危险——头尾迭代器相等并且会一起指向尾空元素。不要把list想象成动态数组，还是想象成链表安全些。 关于Strategy模式：管理一堆Strategy_x基类，每个决定单独的x1、x2、x3 关于map类，声明：typedef map&lt;int,string&gt; num2name; 使用时可以用数组符号修改key值也可insert（），但是insert不支持已经存在的key，数组下标[]会覆盖。","link":"/2021/06/10/2021Spring-OOP-review/"},{"title":"2022秋季学期 编译原理 期末复习笔记","text":"编译/assets/2022Fall-compile-final算法集合 自上而下LL 针对所有，求first · 范围：初始化 放空 分割 产生式检查 针对所有，求follow 初始化 右端A后缀first 可选左端follow 针对所有产生式，求PS预测集合 first右+可选follow左 消除直接、间接左递归（排序、对每个终结符替代比他序号小的左递归用产生式） 消除左公因子 根据预测集合判断是否是LL1文法 递归下降 ParseX 表驱动 借助栈，开口向左的栈，初始化放#。根据栈顶和向前查看来不断推导 错误处理——表驱动：跳过直到同步符号即followA，检测firstA出现的时候恢复分析A 递归下降：补救集合？？？ 符号表：哈希；全局符号表；作用域+单独符号表… 自下而上LR 短语、直接短语和句柄（rm），活前缀（句柄之前的所有前缀） 向右开口的栈（状态栈+符号栈），输入序列#，分析表，（分析引擎） 注意reduce的时候，弹出整个一层然后压入符号再压入状态。即被弹出的老状态无用。 LR0 增广文法 项目（归约、移进、接受、待归） 构造CLOSURE 构造LR0 FSM，通过转移边 构造分析表 ——归约就是一个归约，不含移进和其他归约 SLR1 解决一部分冲突，通过归约后VN的Follow来区分，移进就看移进什么东西，不相交就好 LR1 新项目 = 项目+搜索符 构造CLOSURE：搜索符的传递，是βa的first 构造LR1 FSM 通过转移边，初始化的搜索符为# 构造分析表，搜索符只在归约项目中使用 LALR1 没那么复杂，合并同芯状态 合并同芯状态的后继状态也同芯…合并之 二义文法限制给定优先级比较简单，如算符匹配 错误处理技巧 语义计算 属性文法：语义规则都在最后 树遍历 构造分析树 标记节点——节点是属性 标记依赖关系 拓扑排序 计算标注 借助语法分析的单遍 S属性文法：自下而上，在LR分析中增加语义栈，根据栈顶的几个元素计算。注意lexval L属性文法：要求综合属性+只使用产生式左边的继承属性。 深度后续遍历即可，dfs每个节点都先继承给孩子属性。然后访问每一个孩子。最后再从计算完的孩子身上获得综合属性。 翻译模式：语义规则在符号前，综合在P后。都是单遍 做限制： 类似S 全综合 类似L 继承属性使用的只能是左边的东西，且如果用左端则只能用继承。 自上而下：熟悉的parseX，通过参数传递继承属性，返回值传递综合属性。每个Parse内就按照产生式往下写就好。记得给好继承，保存好综合。 消除左递归，消除的同时需要变换语义规则集。 自下而上： 首先消除除了最后之外的奇奇怪怪东西，包括数字赋值，print，以及复杂函数。通过引入变量把他们都换成简单复写 然后在转化成栈形式，只转化句子末尾的综合属性。如果需要访问继承属性，就一直向前倒到综合属性。不一致就引入调整到一致。 注意数栈的时候的推空式，以及跨箭头top不变。 静态语义检查 中间代码生成 偏移量标注：width子树规模，综合上去；offset从头部继承下来；在底部声明的时候使用enter函数在符号表中标注偏移。函数局部标注也差不多，注意参数也占位置。 内情向量 静态数组放在符号表：每个维度上下界；类型；首地址；维数；C； 动态数组放在运行时组织栈|堆 地址计算：行优先时，从第一维开始往后乘…索引减去下标，乘后续维度的空间。addr - C + V TAC生成“声明数组”、翻译各种语句等等。 大致过程：place申请Temp；计算子语句；code = 子code||gen（某句Temp） 翻译TAC时候，本句Code可以并上需要的子句code place是存储位置 arglist 实参列表 makelist创建实参地址节点 append往这个列表中添加节点 布尔表达式翻译 直接求值 逻辑运算：先取子code，然后放上去 关系比较：用0和1表示取值，用goto nextstat+x表达跳几条语句 控制流语句中布尔的语义——短路 生成目标：按照or and等等往下顺序写，如果随时能判断整个正误就直接跳转。 相当于每个E都有true和false的继承属性。需要我们得到子表达式xxx就能马上判断父亲的正误。随时能判断就gengoto。 rop：两句，都是跳转 且：如果E1错就赶紧跳E错。所以E1错=E错，E1对=newlabel；E2错也可以跳E错，E2对才是E对。code部分，先E1，这样可能短路跳走了，然后E1truelabel，然后E2一定跳走 非：全相反 括号：不变 条件语句翻译 先条件code，再label，再中间code，再label… 顺序复合 用到next属性都表示整块紧邻的下一句 break continue 能产生break的地方，特意标注break。比如while中的内部S… 运行存储组织 默认float8 栈结构 临时单元 动态数组 动态数组（动态数组的存储位置，比如float的话就是2N的空间） 固定局部数据（动态数组：底下放内情向量4B，然后addr ptr4B指向上面的动态区） 过程参数（先参数个数） （reg保存） 控制数据（SL DL RA ） （返回值） 嵌套过程语言，区别于函数递归。 动态链：一定指向caller即上一层 静态链：指向嵌套过程的直接外层 Display 保存全部在栈帧中 保存被自己替换的那条 基本块流图和循环 划分基本块 三入三出条件 支配（必过） 回边——循环 数据流分析 经典方程 到达定值分析，方程 过程 活跃变量分析，方程 标记 UD和DU链 待用信息和活跃信息 DAG局部优化 三种子图 重复利用，可确定常数直接创建，不知道初值需要标0 拓扑排序翻译 寄存器分配 Ershov 和 Sethi：针对表达式，从底层往上标记 相干图 变量（伪寄存器）为节点 定值点紧随的活跃变量集合，和定值连线 K着色… Lec0 考试信息 a）语法分析 + 词法分析 + 编译基础知识 40%左右 （slide01 + slide02 + slide 03 + slide05） ​ b）语法制导的语义计算 + 静态语义分析与中间代码生成 30%左右​ （slide 06 + slide07） ​ a）和 b）共计70% ​ c）符号表+运行时存贮组织 10~15%​ （slide04 + slide08） ​ d）代码生成 + 代码优化 15~20%​ （slide09） ​ c）和 d）共计30% 2）不出题范围 ​ a）Slide或Lecture文件中所有标有“选讲”的内容 ​ b）Lecture09 中 3.1, 3.3 和 3.4 ​ c）Lecture09 中 4.1 和 4.2 Lec1分析，综合 两大阶段 编程语言范型命令语言 描述问题如何实现 有状态并改变 陈述声明语言 描述问题做什么，没有状态 OO 并发、分布式语言 同步、数据库、脚本 前端 分析，首次生成中间代码 中端 中间代码生成优化 后端 综合，生成优化目标代码 字符流-单词流-AST语法分析树-中间代码1~n-目标代码和优化 词法、语法、语义，中间代码生成与优化，目标代码生成与优化 辅助以符号表管理和错误处理 pass|Phase 从头到尾扫描一遍，单或多遍，常有逻辑先后 有Interpreter 不产生目标程序，不区别翻译执行，直接翻译完就执行，解释程序一直守候，直接出结果，用于实现虚拟机。区别于编译程序。 预处理程序，处理掉扩展信息再送进编译程序。 装入与链接程序，用来对可重定向的机器语言程序修改，合并多个并加入库，以产生最终可执行的低级程序。 调试程序，接受编译出的调试信息以及程序，来给出更多运行时的信息 T型图用底下的程序把左编译成右。 本地编译器指的是，用M把A编译成M 交叉编译器，用M把L编译成N 如果想用已有语言A实现新语言B，则相当于已有M下A编M的编译器。我需要拿A设计一个把B编译成M的编译器，并编译成M。就得到了在M下把B编译成M的编译器。 A的L语言移植到B机器，需要用L写L转B。然后来回编译 用编译器编译就是把T放到右下 Lect2 词法分析识别单词 返回Token流（Token和属性值），或者错误信息。 经常由语法分析程序调用，不断获取下一个单词记录 单词描述工具扩展巴克斯EBNF 类似正规表达式的形式表示单词类别 用::= {表示0个及以上个} &lt;非终结符&gt; {}0或多次 []0或一次 状态转移|有限状态机 来表示词法分析过程，结束态是识别完当前单词给出的类别。 正规表达式 有限状态机 标识符vs保留字，保留字表。 字符退还 读取&lt;下一个不是=，则一定是小于号单词，但是下一个已经读取的要退还。 每一类词法单元都对应正规表达式 转换成有限自动机，比如Thompson构造成ε-NFA 增加一个开始状态，转移到每一个初态 可以使用子集构造法得到确定化的DFA 可能会最小化，等价获得小状态DFA 如果没有连一起的自动机，则分别依次模拟运行每一个词法单元的自动机。 Lect3 自顶向下语法分析 91基本思想识别和解析，对于任意CFG和句子，判断这句是否在语言中。如果在给出分析树或者最左推导，否则报错。 从文法开始符号S出发来推导，每一步都获得句型，最终句子正好是终结符串。即每一步都是用产生式换一个非终结符。 非确定 非终结符的不确定 所用产生式的不确定 改进 一定替换最左边的非终结符，产生式不确定，则一定产生最左推导。 更加确定 产生式选择是确定的，所以无回溯。怎么选？向前查看lookahead一定量的单词。这样很爽但对文法有限制。 限制文法 不含左递归 直接左递归 P-P1|2 最后最左边肯定是2，引入P-2Q Q-1Q|ε 间接左递归 P-Aa A-Pb 不含左公因子？？ S-aAb|aAc 或者A-a|aA 引入新的VT替换掉公因子右边 不含左递归和左公因子也不一定是LL1文法捏 但是不是LL1如果有有限产生式也可以使用LL1来分析 LL1文法左到右扫描单词，最左推导，向前查看1个即可 First集合first(某短语) = 这个短语能推出的所有最左终结符，包括ε 计算First 范围是所有产生式右端的所有后缀，ε和单字符。 包括ε的所有终结符都放上自己。 LOOP 【放空】非终结符可以推ε，把ε放入。 【分割】对所有后缀（两个以上字符）的集合，考虑 其实是找第一个不含空的，并到它。如果都含就全并加上ε 存在一个i位置的first不含ε，但它之前字符的first都含ε。则这个后缀的first为1~i的广义并去掉ε。 否则，如果所有字符first都含ε，直接广义并。 【产生式检查】对所有产生式左边的VT，都加入右边整个的first。 Follow集合Follow（非终结符A）= 合法句型中所有可能跟在这个A后面的非终结符或者结束符# 计算 S放入# LOOP 【检查尾缀，放入first，可能放入左边的Follow】对所有产生式右端中的每一个VN B。把他后面后缀部分的First集合去ε之后加入FollowB。如果有空，就把产生式左边的Follow加入 预测集合PS（产生式P） 如果ε不在右端的first，则就是first 否则是first去空加上follow LL1判断每个非终结符的任何两个不同产生式，其预测集合不相交。 LL1分析递归下降LL1每个VT对应子程序（函数），根据语法描述来明确：根据下一个符号选择产生式处理。产生式处理就是非终结符调用子程序，终结符读入字符判断合规与否。 void parseS { 如果需要查看则看lookahead，可以switch来选择产生式，根据PS集合来判断 matchtoken表示终结符 ParseXXX表示非终结符 } 表驱动预测分析表+下推栈 分析表为VT*VN，即非终结符+向前查看（PS）得到产生式右端。 开始时候栈中有# S入栈，S# 终结符则读入消除 非终结符则查表对应产生式，换成产生式 推广大胆并First… 错误处理表驱动 Aa查表没有产生式可用，跳过输入串一些符号直到同步符号为之。 FollowA中所有作为A的同步符号，遇到了之后弹出A，大概表示A已经过去 把FirstA加入A的同步符号集合，出现时候根据A恢复分析 递归下降 进入parse的时候检查下lookahead，补救集合定义为Begin∪End 如果没有合法的非终结符，则跳过所有单词直到合法符号或者EndSym 出parse的时候再检查下matchtoken，如果不在endsym，就跳过等待开始符号 LLk文法结论 可判定：CFG是不是LLK文法；两个LLK是否相等 不可判定：一个CFG是否存在K，使得LLK；或者说存在等价的LLK LLK无二义，不存在左递归 不含ε产生式的话，LLK一定在LLk+1里面 Lect4 符号表 17 7作用静态语义检查、中间代码生成 常见属性名、类别和类型、储存类别和分配、作用域、其他（内情、结构成员、形参） 实现线性表、有序表、二叉搜索树、Hash 全局符号表+作用域各自符号表 作用域和可见性当前作用域，开闭。 某一点的开作用域中声明的名字才可访问。 单符号表：一个大符号表，所有嵌套作用域共用 多符号表：作用域栈，每个作用域维护自己的符号表 在 Lect5 自底向上语法分析 113 1自底向上分析思想识别与解析 自顶向下是从S开始，相当于推导分析。而自底向上就是从终结符串开始规约到S，P右到P左，找不到就回退。 改进 选择可归约串 归约减少回溯，句型来说，可规约串一定是短语 从S开始推导的过程中，任何一个非终结符A能产生的串β就是短语。是句型αβγ相对于A的短语。 在树里看，就是以非终结符为节点下面的东西随便拼出来就好。 直接短语 短语里能被一步推出的。就是所有产生式的右端？ 千万注意空字符。特殊判断一下这个句型里有没有空字符存在，是否属于直接短语。 句柄 S最右推导出（右句型）αAw且A一步到β。就是说最右推导到这里右边已经推出一些终结符了，下一个马上该一步可归约的串。 短语是可归约性串，不一定一步不一定在哪 直接短语是一步可规约串，不一定在哪 句柄是在最靠左的一步可规约串，因为是最左推导中出现的A 句柄不一定唯一，可能有多个（二义文法） 移进-规约分析功能强大，推导的时候只观察可推导出的输入串的部分，归约时候输入全部出现。 利于出错处理：输入符号查看后移进 构造复杂 输入序列#+下推分析栈+有限状态引擎+分析表，对应rm推导（规范推导） 根据引擎状态、下推栈内容、剩余序列来确定动作和新状态 reduce 归约 shift 移进 error错误 accept成功 移进归约冲突不确定移动还是归约 归约归约冲突多于一个短语可以归约 借助分析表查询，LR分析表or算符优先分析表 LR分析基础从左到右扫描，最右推导。以下四种共享分析表。 分析栈中存在的是各种状态。 分析表ACTION表是横坐标是当前输入串，纵坐标当前栈顶状态。表内有s r acc，由栈顶和输入串找动作。 不带符号栈有移进新状态和归约并转到两种操作。 移进新状态就是把状态压入栈顶。 归约并转到就是输入串消除一部分然后根据得到的非终结符替换状态。 带符号栈移入的时候把符号也移入 归约的时候弹出几个符号和状态 LR0向前查看0个 增广文法增加一个开始符号的开始符号。 活前缀β是右句型的句柄，则αβ的所有前缀（包括epsilon）都是G的活前缀。 大概是在最左归约句型的句柄（下一步要被归约的部分），前面连起来的部分就是活前缀。即最左归约的时候所有不要被归约的前面的东西？ 增广文法的活前缀 S 是 G’ 的活前缀 活前缀一定是右句型的前缀且不超过句柄。 活前缀含有句柄的所有符号：产生式右部完全到栈顶 一部分符号：右子部到了，期待左子部 没有，期待全部右部 LR0 FSM任何CFG都对应一个，由增广构造。看做一个字母表的DFA 是特殊的LR0项目（产生式右边加. ，标志着已经分析过的串和产生式匹配的位置）集，分为 每个状态都是项目集的闭包CLOSURE，计算CLOSURE I 每一个J中的待约项目和B的产生式，把B的产生式加进来并把点放在最左边。 循环直到没有新项目 构造方法 初态为增广CLOSURE（{S’ -&gt; .S}） 状态转移函数为 GO(状态I，符号X) = CLOSURE J，J是I的状态中走一个X。即从初态0开始，尝试把里面每个状态都往后走来构造新的闭包状态。值得一提的是走的一样的符号状态算一起的。 这个FSM是根据VTVN转移的自动机，每个状态都是终态。 这个DFA的语言是G’所有活前缀的集合。 即通过构造增广文法的FSM，找到了G’的所有活前缀的语言。所以我们不会错过任何最右推导。 增广文法的每个活前缀都对应其中的一个状态，从初态开始就好。 从这个FSM构造LR0分析表 所有状态即为栈顶的状态，作为纵坐标放在左边。所有字符（包括#）放在上面。 根据项目的不同标记字符即可 先在增广接受项目的状态上标注#acc 然后根据每个状态的转移边标记s，根据归约项目把所有VT标记r，这样归约的状态相当于不查看无脑归约。 每一格子动作都唯一的就是LR0文法，其每个状态都： 不同时含有归约和移进，即.a和x.不同时出现——移进归约冲突 最多有一个归约——归约归约冲突 SLR1FSM中有状态有归约同时还有移进。即不止含有一个点在最后的状态。 向前查看，根据下一个输入符号是否是归约后VN的follow来解决冲突。 归约归约：所有归约后VT的follow不相交即可。 移进归约：归约VTFollow和移进符号集不相交即可。 修改为，对所有含有归约项目的状态。求出Follow后只在follow内标归约即可。 LR1SLR不能解决的，移进归约冲突。只考虑了归约VT的follow，也应该考虑是否是句柄的Follow。 修改项目格式，增加向前搜索符 表示产生式右端完整匹配后允许在余留符号串中的下一个终结符或者#。 用逗号分隔， 这样的归约项目，只有后面是a才能归约，相当于进一步强化条件缩小可归约范围。 LR1FSM 闭包构造 闭包补全中，新加入的产生式的搜索符为First βa。即老产生式后面东西的first集。 状态转移构造 开始状态为S‘到S，搜索符号是#。 状态转移方法不变。 构造分析表 注意向前搜索符只在归约的时候用。 LALR1LookAhead LR1 合并LR1中的同芯状态，得到和LR0FSM相同的状态，但保留更强的能力。芯指的是不包含向前搜索符的部分。 合并同芯状态后如果没有归约-归约冲突，就是LALR1文法。只需检查新合并状态即可。 构造LR1FSM 合并同芯，搜索符号用斜杠/合并 合并之后的GO后继，也把原来的后继状态合并。 二义文法在LR分析二义文法一定不是LR文法，但是可能人为限定之后相当高效。 在一些冲突状态中，人为规定优先级 左结合的相同符号，优先归约 不同符号，优先级高的先归约，优先级低的等待高的移进。 LR分析出错处理根据堆栈状态和输入符号设置报错信息。恢复措施？ 应急恢复：从符号栈和剩下的输入前端找一块能被某个VN最右推导出来的句型，且VN的follow包含输入符号串后面的符号。然后符号栈强行归约换成VN，状态栈弹出一定状态后根据归约的VN GOTO。 即兴恢复：对于每个error都确定场景。。 比如多了个右括号，没有左括号可以匹配了，就删了它 Lect6 语法制导的语义计算 81 2语义计算：语义检查，中间代码生成等 属性文法在CFG上扩展：文法符号可以有属性Attr，产生式有语义动作，是语义规则的集合。 常见动作，赋值:= ，特定语义函数，可以很灵活 继承和综合综合|继承：自底向上传递，被赋值的属性属于产生式左边的VNA还是右边的符号。 综合属性：可以自底向上后序遍历，得到求值过程。 继承属性：同时存在继承和综合属性的话，需要深度优先遍历？反复上下？自下而上综合，自上而下继承，可能多变和多遍。。。 属性文法的语义计算——树遍历 构造语法分析树 依赖图 对树里每个节点的属性都建立一个节点。如果有非赋值的函数，但是也有依赖的属性，则也建立虚节点。 根据依赖关系标记有向边，前驱为先计算的值。 无圈图的拓扑排序来遍历分析树，计算所有属性 拓扑排序：取绝对前驱进行排序… 标注|修饰 来表示计算结果 有圈不可这么算，不是良定义（规则集合能为所有分析树中的属性集确定唯一的值集） 属性文法的语义计算——单遍，语法分析的同时S属性文法——只包含综合属性自下而上，LR分析正好也是，扩展分析栈的域（语义栈来存放综合属性）计算综合属性正好就是每一步归约之前 状态、符号和语义栈。计算的时候靠栈顶计算即可。 注意有些lexval是自带的，压入栈的时候就带着了，是lex词法的时候准备好的。 L属性文法——可综合可继承右边文法符号属性的计算只取决于左边文法符号的属性，不依赖其他。 左边属性当然是综合。即要么综合，继承就只继承VNA 自上而下 深度优先后序遍历的方法，其实是先深搜到底，把继承属性传递下去，再自底向上计算综合属性。 对每个节点而言，先传给孩子继承属性并深度访问孩子，最后通过孩子综合自己。一定注意递归返回的时候的综合计算。 procedure dfvisit (Node n) for m in n.children 左到右: ​ calc m继承属性 ​ visit m calc n综合属性 翻译模式的语义计算语法制导语义计算的另一种描述，类似属性文法但是{}语义规则集出现在任何地方。显示表达动作和运算次序。 必须受限 才能保证访问的时候存在 类似S属性文法仅需要综合的翻译模式 放在右端末尾即可 类似L属性文法 右端符号的继承属性计算位于该符号之前——所以压入的时候一定计算完成 继承属性的动作不访问右边符号的属性，只依赖左边（如果用P左的VN属性只能用其继承，不能用其综合）。——所以要压入自己的时候，使用的东西都已经在了。 左边综合属性放在最后，大家都算完了之后，放在产生式尾部。 单遍——自上而下的预测分析经典的ParseX模式，参数是继承属性，返回值为其综合值。 函数中按照查看来选择产生式，根据产生式慢慢parse，产生式里面说白了就是给他继承属性，保存好他的综合属性。 对于终结符，保存（绑定）其综合属性，调用matchtoken和nexttoken 对于非终结符，把他要的东西给他去parse并保存综合属性 如何在带有语义规则时候消除左递归？ 原来：从下往上套 现在：从上往下套，从下往上传 用R.i一步步嵌套继承下来，最后翻转成综合属性R.s，一步步综合上去。 原来最后一步的综合，变成第一步的继承。 原来左递归的综合，变成右递归的继承。 最后的戛然而止，把继承转换为综合开始上传。 单遍——自下而上的移进归约分析 去掉中间的语义动作——除了复写规则以外的语义规则都在P的末端，方便计算综合属性。 单纯函数，没有保存值。——引入新VN A-&gt;ε，A代替原来的这个函数，print函数放在A后面。 （不急）保存值了——引入新VN A-&gt;ε，A代替原来的这个函数，函数放在A后面。增加一些复写规则（单纯复制值）。 分析栈继承属性访问和模拟求值 指的是所有继承属性的访问，在任何位置。 继承属性是简单复写，且使用P右端前面的综合属性是OK的。 继承属性访问通过已有符号的综合属性间接进行（往前倒，总能找到但是可能不唯一），保证总可以通过某个符号的综合属性来体现 常常增加新的符号和规则来达到目的——针对不唯一情况 引入新推空VN，来把位置造到相对栈顶相同。把前面有用的值继承下来，然后综合上去。 非简单复写，如1.2中所述。把需要的参数继承下来，在推空计算中综合后，给到后面的继承。 用综合属性代替继承属性 把print和单独赋值的继承单拿出来，即不是两边有数的。 复杂函数单拿出来做成简单复写——中间的语义规则全是简单复写 在翻译成栈语言的过程中，只管综合而忽略其他。综合属性放在左端位置，访问的属性一直向前倒直到综合，如果不一致访问，就做成唯一的。 注意空字符的top位置。 注意往前数top的时候，箭头是不减一的。 有时候，自己想用的属性不在自己的子树里，就没法综合。可能还要用后面的继承。试试变换等价文法，把这些东西放到自己的子树里。。。 Lect7 静态语义分析与中间代码生成 66 2静态语义分析静态检查：类型；作用域；控制流；唯一性；上下文相关性 类型检查借助翻译模式，将类型表达式作为属性赋给程序部分。 大概是，在最底层通过lex确认字面值和type类型。然后需要赋值的语句进行检查。利用子节点的ok或者指定类型来判断合法与否。 typeerr。变量一直标记type。 声明语句需要addtype(id.entry, T.type)，即添加符号表。ident也可以lookuptype来查找类型。Expression是带着类型属性的。 Call则要检查参数数量、类型是否一直。所以para里面是ok而不是具体type。 Statement中 Stype多为ok，由下层s和E的合法得到。 检查break和continue在内部：在非循环的时候，S传承inloop或者初始化0.循环的inloop为 1.在break中检查S是不是inloop。相当于继承属性 中间代码生成利于重定向，缩小跨度，利于优化 AST也是中间代码 有向无圈DAG 只考虑计算，把AST分析树中相同结构子树合并 语法制导AST采用产生式时，构造VN节点，同时VT节点也构造好。 offset：存储区变量偏移地址 width 占用字节数 enter(id.name, Decl.offset) 符号表中id的偏移量设置为.. 保存偏移信息全局空间：P在不断生成D和F。每个东西有width和offset参数。F不占空间，offset是继承属性，width是综合属性。 所以width从声明底层T D获取标注好之后一直向上传递，则P的width就是自己这课子树的整个width字数规模。一直向上综合。 然后通过继承属性向下分配偏移，继承就好了。右P偏移为父亲加左孩子偏移 Lect8 运行时存储组织 43 3基本类型：char1 integer4 float8 boolean1 pointer4 array struct object 表达式计算 栈区or专门运算数栈 低地址：保留——code——静态数据（Initdata、bss0）——共享库——堆++ ++栈——保留——OS 静态分配编译可确定大小，有些语言只支持这样，如static const global 栈分配递归、活动记录（栈帧） frame pointer指向帧底（高） sp指向栈顶（低） offset以word为单位 临时单元 动态数组（动态数组的存储位置，比如float的话就是2N的空间） 固定局部数据（动态数组：底下放内情向量4B，然后addr ptr4B指向上面的动态区） 过程参数（先参数个数） （reg保存） 控制数据（SL DL RA ） （返回值） 堆分配不限时间次序，需要显式释放delete new，用户清理，野指针 java隐释放，用户不清理 分配算法：最佳适应、最先适应、循环最先、碎片整理 嵌套过程语言的栈分配解决对非局部量的引用、存取 注意区别于函数递归，嵌套可以访问外层的活动记录。而R call R后并不算嵌套，还是同一空间 解决：Display表+活动记录静态链 链都指向底，毕竟是base+offset模式 动态链DL指向调用该过程前的最新活动记录地址，就是caller 静态链SL指向静态直接外层（能访问外层数据来说，有过程嵌套语言）最新活动记录地址，用来访问非局部数据,在动态链底下 （全局）Display表嵌套层活动记录在运行栈上的基地址，主层次为0，当前层次为K，display有K+1单元。 在每个活动记录存入完整表，每次call时候从caller抄几个再加自己 存一个表项即保存被替换的Dn。在静态存储or专用reg维护全局display表 用静态链，指向自己的直接外过程。更容易实现，但是效率低 对于动态块的非局部量 1要么类似函数单独有活动记录 2单个活动记录内随时扔，作用域结束即无用可覆盖。 动态作用域 变量被认为是最近的调用中声明的，类似动态链的效果。之前有就行。 Lect9 目标代码生成和优化 70 3独立于不断变化的主过程，从TAC开始有流图并不断改进和优化 基本块 流图 循环基本块顺序执行的语句序列，只有一个出入口，只有入口label和出口转移or停止 入口：程序第一句or转移的目标句or条件转移紧挨着的 划分基本块 找到每个入口 根据入口构造：从入口到下一入口or转移or停 没在基本块的是无法到达的 流图：CFG，基本块为节点，连线条件： 1 条件转移连两条线 2 转移连一条线 3 顺序出口连一条线 循环支配 首节点到n的任意通路都过m，则m支配n。m dom n，domn = 所有支配节点，即所有必过点。 回边 d dom n但是n指向d。我可以回到我的必经之路。 （自然）循环 回边两端+能够不过d到n的节点。显然d可以到循环的任何点——直观理解，如果这些点不能由d到达，则d不是domn了 数据流分析基础典型方程 out = gen∪（in - kill） 出口信息 = 内部新生信息+（进来的信息-已死亡信息） 到达-定值分析定值语句，可能给A赋值 定值点到达：流图中从定值点d有路径到p且过程中没有被重新定值 outB = genB ∪ (inB - killB), inB = ∪outb gen是定值且能到出口的所有定值点 kill B B外能到B入口，但是定值变量在B内被重新定值 in为所有前驱out信息的并 算法 标注gen，out=gen 标注kill：找定值变量的其他定值点，看看那个能“到达”此块，即中间没有被kill。 一直循环到不变 从1开始对节点 newin = 前驱out，如果和老in不一样 改变，更新老in 更新out = gen+in-kill 活跃变量分析活跃变量——从某点p开始后面用过A在p的值，A在p是活跃的。如果存在路径在变量被重新定值之前还要被引用 方程：livein = liveuse用的前面的 ∪ (liveout - def)，out = 后继In的并 其实是从后向前，入口活跃 = 用了的+（出口活跃-定值且之前没被用） 标注use，in = use 标注def，定值且之前没被引用 一直循环到不变，从1开始对节点 newout = 后继in 如果不同，则更新newout；按照方程更新in UD链和DU链ud：u的全部d点。借助到达-定值：本块自己有定值orIN中的所有A的定值 DU：D的所有U点，那就是？？ 待用信息：D的待用信息，DU链最近引用点 活跃信息 基本块的DAG表示 局部优化有向无圈图 叶节点是变量名或者常数，x0代表x初值 内部节点是运算符号 只考虑赋值 单双目运算三种子图 画图就好 可确定的常数，就直接写成新节点赋值 没被赋值直接使用的，假设初值为A0 最后拓扑排序，写出优化代码 寄存器分配Ershov数——SethiUllman 表达式求值，从底层开始，孩子相等加一，孩子不等取大？ 写汇编 图着色分配 假定无限reg，完成指令选择和生成 物理寄存器指派到伪寄存器。不足时伪寄存器泄露到内存，尽量减少 寄存器相干图伪寄存器（变量）为节点 如果节点在程序某点被定义，而另一个节点在紧靠该定值之后的点是活跃的，则连线？ 即，定值之后活跃的所有变量，连接这个节点。需要知道每句之间的活跃变量。 着色 启发算法 选一个颜色数k，一个一个节点删除度数小于k的节点即可。","link":"/2023/02/25/2022Fall-compile-final/"},{"title":"2022秋季学期 计算机网络原理 期末复习笔记","text":"CH1核心思想：分组交换 1969 arpanet 56kbps 1979 TCPIP 光线：骨干网带宽9个月翻倍，10年10000倍。 迈特咖啡：价值正比于用户数平方，效率是n方 电话vs网络：聪明网络笨终端和聪明终端（修复传输错误）简单不可考网络 分组交换：简单、灵活（支持各种物理网络和应用）、可扩展、健壮（牺牲带宽利用但健壮 ipv4耗尽，用nat支撑破坏原有网络结构，需要过渡到ipv6 CERNET是我不过第一个全国性计算机互联网络，第二大计算机互联网 下一代互联网Internet2 NGI Abilene GEANT…中国NSFCNET 核心路由器 CNGI CNGI下一代，高速互联 ipv6 cernet2主干 大规模国产设备 Ch2 网络体系结构定义和组成一批独立自治的计算机系统的互连集合体，区别于统一的分布式系统 资源和通信子网（通信线路+网络互联设备） 广播式通信 bus、ring 共享线路，可以直接被接受 交换式通信 交换设备选择输出，star ring（loop） tree… 关键需要routing 通道分配：静态分时间片、动态（集中or分布仲裁） 网络体系结构从功能定义层次结构，但不规定具体协议和细节、接口 功能分层——协议分层——体系结构分层 需要什么功能：无差错、共享物理线路、路由选择、信息缓冲、流量控制、会话控制… 特点：同时一对用户、通信是相互的、分散在各个网络和用户设备 服务：同一实体上下层间交换信息时必须遵守的规则 协议（Protocol） ： 计算机网络同等层次（通信时为对等进程）中，通信双方进行信息交换时必须遵守的规则。——语法、语义、定时关系 n层协议：不知道上下层内部结构，独立完成功能、为上层提供服务，使用下层服务 SAP服务接入点 任何层间服务是在接口的SAP上进行的，有唯一的识别地址，层间接口有多个SAP ICI和SDU加一起是IDU，也就是下层服务数据+接口控制信息=接口数据单元。通过SAP传输。下层服务数据+协议控制信息=协议数据单元 无连接：独立路由，顺序性差，基于连接不一定可靠，顺序性好 服务原语四种类型：请求：想干事情、指示：关于事件的通知、响应：对事件回复、确认：对先前请求的回应 分层的好处：模块化，抽象功能（底层改变保证服务一致即可），复用性 坏处：信息被隐藏，实现起来更低效 端到端：除了必须和基本功能外，放到高层去实现额外的功能 典型网络参考模型 标准化组织 ITU ISO ANSI NIST IEEE OIF CCSA RFC IAB IETF IRTF OSI七层模型 物理（传输bit）-数据链路（有差错的物理线路提供无差错数据传输Frame）-网络层（控制通信子网，从src传到dst的packet）-传输层（端到端的数据传输，细化到资源子网的主机）-会话（会话控制与安全认证）-表示（数据转换和表示）-应用 TCPIP 把底两层统称Host to network 网络Internet层：控制通信子网提供IP包传送，异构网络互联 传输层：端到端的数据传输，TCP和UDP 应用层：表示、会话、应用，各种管理和服务 教学所用 物理 数据链路 网络 传输 应用 其他网络体系结构Novell Netware（XNS）：C/S结构，文件共享而非磁盘共享。网络层协议用IPX，不可靠无连接协议，4网络号+6机器号MAC。传输层NCP、SPX（面向连接 X.25分组交换，面向连接，早于OSI B-ISDN电信公司想统一网络，主要用ATM技术 ATM 异步传输没有主时钟，cell是短且定长包，面向连接，155/622M’ Summary通信子网：点到点通道，关键路由选择； 广播通道，关键通道分配； Ch3通信基础理论频谱：信号包含的频率范围，带宽=频谱宽度 有效带宽：能量集中在相对窄的频带中，叫做带宽 信道有截止频率fc，0fc的振幅衰减弱，以上的振幅衰减厉害，由物理特性决定。所以0fc为有限带宽。带宽越宽， 波特率：每秒钟信号变化的次数，调制速率。 比特率：每秒钟传送的二进制位数 每个信号值可表示几位，比特率是波特率几倍 即使对于完善信道，有限的带宽限制了数据的传输速率 奈奎斯特定律：无噪声有限带宽信道最大数据传输率 = 2Hlog（2，V） bps 带宽为H 每秒采样2H次能够完整重现，信号电平分为V级 信噪比：信号功率S与噪声功率N之比 10log(10,S/N) db 电话大概30db 香农定理：带宽H信噪比S/N的任意信道最大数据传输率 = Hlog(2, 1 + S/N) bps。是难以达到的上限 如果有噪声按两个公式都算一遍取小者 数据通信技术 数据通信：计算机-信号变换-信道-网络设备-信道-信号变换-计算机 单工：信息单向传输，回送监视信号 半双工：信息可以双向传输但不能同时 全双工：信息同时双向传输+监视信号 同步：接收方必须知道每一位信号的开始及其持续时间， 异步传输：以字符传输为例，每个字符由发送方异步产生有随机性，需要辅助位，每个字符需要10-11位传送 1起始 7编码 1奇偶校验 1-2终止 效率低、主要用于字符终端与计算机的通信 同步传输：信息传送以报文为单位，传输开始时需要同步字符来同步收发双方。传输信息中抽取同步信息修正同步保证正确采样 不间断，效率高；字符间辅助信息少；传输信息中不能有同步字符，需要透明传输处理 基于位的传输一般同步，二进制位流，以位为单位同步，开始结束由特定八位二进制同步，效率高 模拟-调制 数字-编码 数字信号：价格便宜；噪声不敏感；但是易于衰减；高频高衰减 基带传输，直接使用传输变换前所占用的频带，原始信号固有的频带，适用各种情况但对传输线要求高（频率成分宽）。低0高1 不归零None return to Zero编码：低0高1，难以分辨一位结束开始；必须有时钟同步发送接受方；若01连续出现，直流分量累加==》容易出现传播错误 曼彻斯特编码、相位编码：中间的跳变是数据也是自同步时钟 在每位中间跳变，低跳高是0 高跳低是1 差分曼彻斯特（两种）：中间固定跳反，且每位开始时候有跳变是0，维持是1 逢1（0）变化的NRZ（两种）：仅在开始的时候逢1（0）跳 数字数据的模拟传输 频带传输 在一定频率的线路载波传输，用基带信号对载波调制，使其变为适于传送的信号 调制：用基带脉冲对载波信号的参量控制 调幅ASK 振幅做变量 调频 FSK 频率做变量 w不同值 调相位 PSK phase phai改变 模拟数据的数字传输 脉冲代码调制 PCM ， 将模拟信号振幅分成2^n级，每一级用n位表示，采样 差分脉冲代码调制，根据前后 两个采样值差编码输出二进制数字 delta调制 根据采样值前后差决定输出0or1但跟不上变化太快的信号（每次的delta固定，跟不上大变） 多路复用技术 多个信号共用物理线路，时分复用TDM，频分复用FDM，波分复用WDM（多波长光混合和拆解），码分复用CDM T1载波 采样128等级7位二进制，传输速率1.544Mbps 具体，每125us传播24路8位+帧同步位共193位，数据速率1.536。每个通道中8位有1位控制，所以每个通道的数据比特率为56kbps，总数据比特率为1.344Mbps 交换技术 电路交换：直接切换物理线路。 建立 传输 拆除。必须建立点到点的物理通路，建立时间长，数据传输延迟短。一般时分复用，分成frame再分为slot，slot在frame内的相对位置决定槽所传输的数据所属的会话。 发送接收方需要同步 非永久会话需要动态绑定slot到一个会话 报文交换：信息以报文（逻辑完整信息段）为单位进行存储转发 线路利用率高；中间节点通信设备buffer够大，延迟时间长 分组交换：比报文小的信息段，随机乱切，定长or变长 src节点分组，中间节点存储转发，目的节点组合回报文 每个分组头都需要原地址和目的地址，独立路由 不预先分配资源；线路利用高；易于重传，高可靠；易于新传输让紧急信息优先通过；开销增加 分组交换：数据包分组 虚电路分组（常用于电话， 数据报分组交换：每个分组均有地址，独立路径。IP networks 虚电路：电路+分组 同一流的分组通过一个预先建立的路径（虚电路）传输。确保分组的顺序，但是来自不同虚电路的分组可能交错 统计复用，按需分配信道资源 来自任意会话的数据立即发送不需要等待slot，用分组头来分组数据 电路交换vs分组交换 分组：统计复用，有效利用带宽 峰值带宽：平均带宽：话音3:1 数据5:1 分组交换处理拥塞，需要复杂路由器且难以保证端到端的服务质量（延迟与带宽） 实际使用结合一起 电路交换：适合实时信息、模拟信号，带宽低 报文交换：带宽高，可靠灵活；延迟大 分组交换：缩短延迟；可实时；高带宽中经济合理可靠 交换结构 crossbar，一群横竖电路交叉成十字，加入连接点… 空分，结合小crossbar，分成几组然后结合连线。 时分：按照映射表打乱进入帧的timeslot数据，然后再给出去 思考题 电路交换和分组交换的区别 Ch4 物理层接口与协议物理层定义功能在网络设备中提供透明比特流传输。启动和关闭连接，传输数据 物理层特性机械特性 接插装置 引脚和排列、电气特性、功能特性 数据控制定时地、规程特性 典型物理层标准接口RS232-c RS449 442a 423a RJ45 传输介质双绞线模拟or数字，线的类型和距离决定带宽 非屏蔽双绞线UTP 屏蔽双绞线STP 同轴电缆基带同轴电缆 50Ω 数据传输 宽带同轴电缆 75Ω 模拟传输 CableTV 300/450Mhz 光纤单模or多模，全反射长距离传输 只有特定的角度继续传输（传输模式），多个反射角度叫做多模，但是短距离。光纤半径到波长数量级时，只有一个角度or模式的光可以进入，叫做单模，适用于长距离。 单模多模都可以波分复用 850nm 便宜，衰减 速率慢距离短 1310 无色散补偿，功率放大下40km 1550 同，功率放大下80km 光网组网 点到点四根线，两根保护倒换。环形只需2/1根 中继器来光电转换 网络传输技术SONET/SDH TDM技术同步系统有主时钟 810B/125us 51.84Mbps 移动电话单向寻呼：单向、小带宽 通话：双向，多频率 1G 模拟蜂窝 只语音 2G 数字蜂窝 主要话音 GSM CDMA 34G 话音和数据 AMPS蜂窝cell在附近蜂窝中重用传输频率，如果超过系统容量就进一步划分蜂窝，重用频率并减弱功率。容易被窃听、盗用。三个频率足够1+6蜂窝使用 蜂窝中心基站，计算机+天线 通过包交换网络+MTSO（电话系统） MSC相连 Ch5 数据链路控制与协议概述目标和功能 有差错的线路上无差错传输——正常传输，组帧，差错，可选顺序和流量 网络设备和主机都算节点 点到点：专指链路上的两个相邻节点 端到端：源到目的，可能由多个链路 虽然是物理层连接，但数据链路层看起来虚拟通路 服务 无确认无连接服务（低误码，实时，局域网），有确认无连接（不可靠信道无线网），有确认有连接 组帧组并且计算checksum 字符计数法帧头表示帧的字符个数——一步错步步错 字符填充的字符定界引入DLESTX，DLEETX字符，中间内容中如果出现特殊字符，加入DLE两遍来转义 Data link escape start end，局限在8位字符和ascii DLE STX A DLE DLE B DLE ETX其中数据位ADLEB 位填充的标记定界特殊位串来开始和结束 01111110flag，正文中一旦五个1就插入0。只有flag中出现六个连续1 物理层编码违例有冗余的物理层编码，用违规码定界 错误检测纠正特点：随机，连续突发 n = m数据位+r校验位，一共n位码字 检查d个错，海明距离需要d+1 纠正d个错，海明距离需要2d+1 奇偶校验可检查奇数个错误，纠正单比特需要2^r &gt;= m+r+1 海明码连续突发错误的话，可以按行书写海明码然后按列发送。相当于把连续错误分散到每一个码字中 检错+重传 CRC循环冗余码需要多项式Gx，高低位必须为1，且比传输信息短 计算checksum加在帧尾，想要帧多项式被Gx除尽。 计算消息多项式Mx，后面加r（r是Gx的多项式阶数，比位数短1）个0变成2^rMx。用Gx除 最后用2rMx减去余数，其实就是把余数补上去，即得到一定整除的2rmx 注意此时的除法和减法都是图一乐，不借位，相当于异或 检错能力若中间改变的多项式Ex整除Gx就不能发现，否则可以 单比特OK，Ex/Gx肯定有余数 两个孤立单比特，那任意Gx不能是任何X^i-j +1的因数 奇数比特错，Gx选择x+1倍数即可，一定除不尽 r个校验位多项式（有r+1项的Gx）能查出所有长度小于等于r的连续差错 r+1连续错的时候，概率很小查不出来，约1/2^r-1 大于r+1呢？？？坏帧接收大概2^-r 网卡实现crc校验 基本协议无约束单工协议——一直发单工、无休止发送和无限大buffer，信道不损坏 单工停等——buffer有限，每次发一个等ack接受后给sender响应 sender 接收网络层，组帧，发送，等待 receiver 等待，接收物理层，发给网络层，发送确认帧 噪声单工PAR——信道有差错，引入1位序号，翻转出错重传，定时，加入1位序号，来回翻转 send 接收网络层，加入序号，发出去并启动计时，等待响应（ack了序号，翻转序号；超时重发） rece 等待，接收，序号正确则发给上层，发回ack并翻转期待序号 滑动窗口双工，引入捎带机制，充分利用带宽但复杂 信号都有，期待接受and期待确认 发送端维护已发送但是没确认的序号表叫做发送窗口，上界是要发的下一帧，下界是待确认的最小帧。即左闭右开区间。 发送时发送上界帧并加一，接受到ack=下界则下界加一，如果ack在窗口内则连续加一到ack+1（累计确认） 接收窗口 固定窗口，上界是允许的最大序号，下界是紧邻的序号。收到0123则【4,7】，等于下界的被接受并响应。上下界同时移动 1bit滑动窗口序号只取01两个值且两窗口都是1. 我发送的帧seq = ~上一个ack，ack=上一个seq 如果同时发送会有一半的重复帧，即我第一次发B0你的A0还没到，你A0到我这的时候我还没收到B0的确认只能再发B0. 最大效率|利用率 = 发送时间/总占用时间 信道利用率 = 帧长/帧长+延迟*比特带宽 退后n帧重传发送窗口大于1，接受为1 发一堆，慢慢收。如果有一个坏帧拒收所有后面并不再发送ack，等待超时后发送方从坏帧重发。多个计时器。 在坏信道上效率低 窗口大小不要能一次性发满序号，至少发送窗口&lt;序号总量 选择重传发送接受均大于1。接收方可以暂存坏帧后面的帧但仍然只发送老ack，发送方只重传坏帧，但需要buffer够大。ack可以突变。 接收窗口完全移动后，不要重合。不然重发当做新帧。 发送&gt;=接受时，接受最大为（maxseq+1）/2 else 发送+接受&lt;=序号个数 确认计时器：防止负载不均衡，实在没有捎带就发一个空ack出去。计时器在接收窗口移动后，或发了NAK时开始。发送任意一帧时结束。 否定确认NAK：收到坏帧或跳脱帧主动发NAK 说明与验证协议工程：说明、验证、实现、测试 验证——可达性分析 图论分析 测试 一致性、互操作、性能 用形式化描述代替自然语言，如FDT和FM Formal FSM有限状态机状态、标号，初态，变迁 Petri网？？结构：圆圈位置、变迁线段、弧 活动标记Token点 常用的数据链路协议面向字符，面向比特 HDLC终端和计算机之间组合沟通，用01111110定界。一直传定界符号表示空闲 定界——8b地址（命令or响应）——8b控制信息（0，3序号，1pollfinal命令或响应，3next作为ack||ortype表示监控真、否定确认帧、不接受帧或者拒绝帧）——数据——16b校验和CRC——定界符 滑动窗口3位序号，发送窗口为7。但next表示第一个没收到的序号 X.25的链路层LAPB使用HDLC CRC只检错不纠错，丢弃出错 重传N次后报告上层协议 帧序号错了发送拒绝帧，发送方重传检错也纠错 PF为检验指示， SLIP和PPPSLIP：标记定界，字符填充，发送原始IP包。不提供差错检验，只支持IP并不能动态，不提供认证 PPP改进SLIP，提供差错，支持多协议，动态分配IP，以帧尾单位。 PPP面向字符，以01111110开始，采用字符填充而非位填充。 Ch6 局域网 介质访问子层 108 6局域网概述高速短距低出错，经常使用广播信道，解决信道分配问题 静态：FDM频分复用orWDM TDM时分复用，固定时槽 多路访问协议纯ALOHA 直接发，如果冲突则等待随机时间再发。 相当于两个帧时内的k=0，λ=2G，得到P0 分槽ALOHA每个站只有在槽开始的时候可以尝试发送，冲突危险减半。效率翻倍。 载波监听多路访问CSMA1-坚持CSMA先监听，如果空闲就马上发，忙就一直监听后发送。如果冲突则随机等待再发送。冲突概率大，怕延迟 非坚持CSMA监听，如果空闲就发。如果忙就等待随机时间然后尝试 冲突少，信道空闲多且延迟高 G越大效率越高，但是延迟更大 p-坚持CSMA分槽信道中，监听到空闲有p的概率发送数据。或者延迟到下一个时槽，看空闲的话再次以p尝试。忙就再等待。冲突就等待随机。 冲突检测的载波监听多路访问CSMACD冲突太浪费了，如果冲突可以发送干扰，打断自己和所有站的发送。等待随机时间在发。 检测冲突最坏需要两倍电缆时间。 无冲突协议——预留协议（先请求）分开为传输，竞争和空闲 位图协议信道上N个时槽，要发就置1。大家都知道了就按序号发送 轻负载效率d/N+d 数据帧由d个时间单位，重负载下d=Nd 不公平，有固定开销 二进制下数大家都有等长二进制串表示自己，互相或在一起。如果看到更高的位有1则放弃请求。效率为d/d+log2N 有限竞争——适应树搜索协议轻负载竞争，重负载无冲突。分组各站，组内竞争 组织站点为二叉树，折半请求搜索。如果获得之后，留给没有竞争的后一半竞争。 局域网技术只有一个信道，短距离， 隐藏站点问题。竞争者太远 暴露站点：非竞争者太近 区别于CSMACSMA的电缆可以传播信号给所有站点。冲突被站点发现 WLAN中信号只能发给附近的人，尽量保证只有一个发送站，冲突被接受者发现，信道可以同时有多个有效帧 MACA协议——先双方握手并告诉周围A发B RTS请求发送，同时A周围站点不发送 B回A CTS已经准备好，B周围不发送 A发送 冲突则二进制指数后退等待随机时间后开始 MACAW 每个成功数据帧都要被ack，发送站点载波监听，冲突后不针对站点而是针对流来后退，拥塞时站点交互信息 802系列介质访问控制MAC子层上引入LLC逻辑链路控制子层，提供更多的确认和流量控制服务——不可靠数据报，有确认数据报和可靠面向连接服务 802.3电缆标准 10basex，10mbps base基带传输 500m。 中继器：物理层，接受放大信号、双向重传。两个收发器之间可以四个中继器2500m 曼彻斯特编码，简单。 帧格式 使用7B的10101010作为前导，然后10101011作为开始。 地址第一位 单0组1 第二位全球0本地1 全1广播 避免帧到达前就发完，发送时间大于2τ。（防止对向冲突） 快到对面的时候对面开始发，这样就Collision。减小站点距离或者加大帧长才能提速。最大冲突检测时间为51.2us 二进制指数后退 时槽为51.2us。第i次冲突后 等待0~2^i-1。到10位上界，16次彻底失败 用交换802.3LAN来减少冲突 ？？大概是接入交换机，被缓存并并行转发？ 以太网快速以太网 HUB的10BaseT甚至100BaseT4100BaseT44对非屏蔽双绞线1对Tohub1对FromHub，两对变换方向。 25MhzBaudrate。曼彻斯特编码，8B6T，8B映射到6个三进制位。每对带宽25*8/6 =33.3Mbps。正向100反向33.3？？ TX 2对五类线，to和fromhub。125Mhz，4B5B编码。每对125/5*4=100Mhz FX 2根多模光纤，全双工 HUB 共享：一个冲突域，CSMACD二进制指数后退，半双工 交换式。输入帧缓存，一个端口为一个冲突域 1000BASE X系列是8B10B编码 1000baseT 4B5B编码 一个冲突域只允许一个中继器 10GE 万兆以太网，全双工，不用CSMACD。只光纤，单模可以用在WAN MAN 多模的传输距离只有65-300M 802.5 令牌环LAN并不是广播，而是点到点组成的。完全公平且无冲突 Token，要有足够的延迟被容纳。 要发数据，取下令牌，发送，发送站负责移除帧然后重新生成令牌开始监听。 确认：帧内的比特域，初值0，目的站变1. 重负载效率100%。 引入1bit传输延迟。物理长度为信号传播速度/比特率 屏蔽双绞线，差分曼彻斯特 令牌持有时间10ms，有优先级 环上竞争选出监控站，负责维护保证令牌不丢失，处理断环和坏帧 光线分布式数据接口 FDDI多模光纤 类似TokenRing 100M 4B5B 200km 1000站 连接LAN的主干网，可以双环。站点发完后立即产生新令牌，环上可同时多个帧。 DPT RPR Dynamic Packet Transport用于MAN 双环，双环都可以传输data和control 目的站取下报文，不占用 网桥在LAN之间实现帧存储转发。可以分隔大LAN可以连接远LAN。 兼容不同类型，安全保密 中继器不能隔离冲突域，网桥|交换机可以 原理多个物理层和MAC子层。 转换帧格式，缓存不同速率的帧，高层协议的定时器。甚至MTU最大帧长的区别。无法转发就扔掉 一开始接受所有帧，洪泛转发帧。后来逆向学习，通过源地址收集MAC写入对应表。不断更新 多个网桥的回路问题 网桥间通信，用连接每个LAN的生成树覆盖拓扑。透明or生成树网桥 网桥广播自己的编号，最小为root 计算到根的最短路，构造生成树，使得LAN和桥到根最短 故障重新计算 不断更新 源路由网桥 如果不在自己的lan内，在帧里制定好路由序列。LAN的12位编号和Bridge的4位。每个站广播发现帧来获得最佳路由。 Ch7 路由选择和网络层 183 7概述在实体间交换网络服务数据单元。传送实体独立于路由选择和交换的方式 通信子网的最高层 传统电信vs互联网：可靠连接vs不可靠，复杂功能放在传输 路由算法数据包分组交换vs虚电路分组交换，每个或者一次路由选择 最优化原则 最优路线的包含性，最优路线的子路线是最优路线 汇集树 类似生成树，只不过是所有src汇集到dst，是路由算法的目的 最短路径路由DIJKSTRA 静态洪泛重复分组多，回路。给分组设置寿命计数器，不要反复传播+记录经过的路径 改进为选择洪泛，转发到正确方向接近的线路，作为基准来评价 基于流量的路由算法拓扑结构+网络负载。假设站点间流量平稳可预测，得到平均分组延迟来找最小延迟的路由算法。可以离线计算 需要通信量矩阵Fij和带宽矩阵Cij。即流量和带宽 计算平均延迟T = 1/(μ平均包大小1/800bits C带宽 - λ平均包量) ，为剩余网络带包数的倒数 距离矢量算法 Bellman Ford DV应用：ARPANET RIP 路由器作为索引|出镜线路|距离估计值（hop）or延迟 每隔一段时间，向所有邻居发送自己的表 同时收到来自所有邻居的表更新自己的路由表，为min（到邻居的代价+这个邻居到目标的代价），这个过程不依赖老表？难道这个代价是重新测算or保存到一张长期有效的另外表中。 问题 无穷计算不收敛，好消息与坏消息 突然很好很近的路径进来，很快被同步，大概是正比于路径跳数的时间 宕机一个router，产生无穷计数，大家都缓慢的增大。因为宕机一个后，其他路由器还以为自己的邻居仍然有很好的路径能到宕机哥们那里。 禁止路由器向邻居返回一个从邻居获得的最佳路径（线性拓扑中的无穷级数）染毒逆向的水平分裂法 即如果我的路径包含你，我就告诉你是无穷大的。闭合Y字形失败。 问题的核心 当 X 告诉 Y 它有一条通往某个地方的路径， Y 无从知道自己是否已在这条路径上。 链路状态路由 发送自己周遭链路的状态 LSOSPF ISIS 开始工作之前，每个router： (1) 发现它的邻居节点， 并学习其网络地址。 往每个线路发送hello，接受者加上自己的唯一身份。 广播LAN建议增加超节点，连接广播所及的节点 (2) 测量到每个邻居节点的距离或者成本度量值。 常用度量：带宽反比、链路延迟 (3) 构造一个包含所有刚刚获知的链路信息包。 发送方标识符，Seq用来自己控制版本新版加一，Age寿命过期就扔，表：邻居列表和对应成本 (4) 将这个包发送给所有其他的路由器，并接收来自所有其他路由器的信息包。 洪泛，发一个新的就递增。接收方需要记录来自其他Router 的已接收最大序号，如果接收到同样包则丢弃不发送，收到小序号则过时 问题：序号绕回，用大范围；路由器崩溃，丢失序号记录，发的太小会被拒绝；序号被破坏，错误地增大很多seq导致新的被当做老的 解决：加入age年龄字段，每过1s减一，相当于有效期。 一般10s左右新的包就会来替换掉老包，年龄设为60检测宕机 链路状态数据包需要返回ack以确认 来自不同src的副本可能从任何邻居那里到来。到来的标记ack并发送ack，其他标记sentflag (5) 计算出到每个其他路由器的最短路径。 完整网络拓扑图，每条边被表示了两次。因为双方向不一定成本相同。运行Dij即可并存到路由表中。 评价 没有慢收敛，但可能路由震荡（当路径负载作为代价时，可能顺逆震荡），需要Onlogn，长时间定时或者重大变化才重发分组 路由算法依赖于路由器计算路径的处理，少数路由器瞎编也可以破坏网络。比如声称不存在的链路或者故意忽略链路。 分层路由太大，表大，收敛慢，计算大。分层后不一定最优 最优lnN层，每个表项elnN个 移动主机路由设定移动主机有不变的家乡位置和地址，每个区域有家乡代理和外部代理。分别记录登记在这人在外边的，和人在这的 进入新区域的移动用户向本地的外部代理注册，告知家乡地址，目前链路地址和安全信息。外部代理会定期广播的自己的存在和地址分组。 外部代理和家乡代理联系，更新其现在的位置和外部网络地址 家乡代理检查通过，ack 外部代理收到ack，登记并注册成功 收： 家乡局域网——家乡代理—隧道—外部代理，同时告诉发送方你直接隧道到外部代理就好了or移动主机通过外部代理告诉发送者自己的转交地址，以后直接隧道到这里来。外部代理发给用户（三角路由，后续直接优化到一条边了） 拥塞控制算法开环控制：好的设计避免拥塞，不考虑网络状态 闭环：基于反馈，监控，调整 vs流量控制，拥塞是全局性的，流量是对点的，不要超过接收方处理能力 参数 丢包率 队列长度 重传量 延迟 延迟变化 反馈 丢包路由器向负载发生源头发送告警分组 分组头中保留拥塞域ECN，对应端口所有输出标记好，接收方ack也携带 端主机反馈 开环控制——流量整形把突发性的变成均匀可以预测的 漏桶算法不平滑数据分组流变平滑，可以固定or变长分组协议ATMorIP 字节计数，规定桶容量为B，出水速率为R。不灵活 令牌桶t产生令牌，传送分组消耗令牌，可以累计发送权到桶大小。适合突发。如果路由器有9600KB的缓冲区和200Mpbs的速率，主机速率可到1000Mbps，则在主机端使用B9600KB R200Mpbs的令牌桶。 一开始全速发送一段时间直到填满缓冲区，然后削减到200Mpbs，桶空则延迟，流量慢于200的时候慢慢被填满。可以有一些突发。 双令牌桶 第二个桶的速率更高但几乎没有容量。即降低初始突发允许大的突发更加平滑的输出，而不是一开始很快后来降低到长期速率。 虚电路子网和准入控制三方出具流说明，包含流模式，服务质量等。慢慢协商。协议后预留资源 拥塞问题解决前不允许建立新虚电路or可以建立但必须绕开 逐跳抑制分组 抑制分组通知源主机太慢了，每一跳都有抑制作用，更迅速，需要上游Router缓冲区更大 数据包子网拥塞 包调度——公平队列每个输出都有多个队列，循环扫描队列头发送包，队列优先级相同。即abcabc的发送。但是大包获得的带宽大 改进为加权队列 ——分组轮询变成字节轮询 时间按照发完分组的虚拟时间计算，可以有权重，时间除以权重 也就是一轮循环砍一个字节，有的管道砍得多。先被砍完的包先发送。 完成时间 = max 到达时间，同队列前面包的完成时间 + 长度/权重 负载丢弃多媒体 扔老的 milk 文件传输扔新的 wine 网络互联中继器，物理层拷贝比特放大信号 网桥，数据链路层。局域网之间存储准发帧，可以改格式 多协议路由器，网络层。在网络之间存储转发，可以转协议 传输|应用网关：传输层转发|应用层互联 无连接网络互联多协议路由器转协议，转分组格式和地址等等 隧道源和目的主机网络相同，中间隧道打包。把原来的包作为载荷 互连网络的路由 更复杂，自治系统AS？？ 内部网关协议IGP：RIP OSPF ISIS 外部网关协议EGP：BGP 分段透明分段：网关分片后每个片段必须经过同一个出口，再重组。对其他网络透明。 需要数据包结束标识 路由被限制在同路径，损失性能 路由器工作大，需要拆分组装缓冲等 非透明：一旦分段，直到目的主机都不重组。需要的话可以继续拆分 头太多开销太高， 容易丢失 树形标记，0分为0.0和0.1再往下分。长度前后一致 偏移量法：原始分组seq，offset（仅数据层）和最后片指示 路径MTU发现，IP中有不允许分段的DF比特。如果接收到很大的数据包，会生成报错发给源主机然后丢弃此包 源端需要分段到路由器能处理，再次发送可能仍然被之后的路由器拒绝 需要更高层协议了解路径MTU并传给IP，比如TCPIP来传递，相当于把分段任务从网络交给主机 启动延迟增大，需要来回找MTU 可能会拦腰截断MTU 防火墙两个路由器根据规则表过滤，或者边缘网关审查 互联网网络层协议IPv4头20B变长到20+40 IHL 几个字的头。 Type 3个优先级位 3个标志位Delay T R 2个保留位，经常忽略 DF，不许分片，必须接受576B的片段 MF，还有更多分片，最后一片为0. offset 片段偏移了多少字节，仅表示数据部分偏移 MTU1500时候最多20头+1480B数据。 生存期：寿命，TTL跳一次减一，丢弃后告警。最大255 Header校验和：16位取反循环相加，进位在末尾，和再取反 地址网络号+主机号，分类 全1广播 全0本机 host部分可以划分为subnet和host，划分子网 ICMP 互联网控制消息协议 报告错误和测试，封装在IP中 ARP 地址解析协议 解决IP和MAC地址的映射。建立ARP表，存放IPMAC地址对。同子网内查找arp，否则用默认缺省网关的IP查找。没找到就广播分组，目的主机需要应答，ARP增加。 每个主机启动的时候广播自己的映射。 表项有生存期。 RARP MAC找IP，也使用ARP消息。无盘工作站启动，由于路由器不转发广播帧，RARP服务器必须与无盘工作站在同一子网内 ？？ 区分BOOTP 使用IP UDP，可以分配其他信息。可以转发到其他子网 RIP 内部网关协议IGP，基于UDP 距离向量算法，用跳数衡量距离，30s一次。 6个周期180s没有邻居声明，则认为失效。所有经过其路由无效。声明发给其他邻居，并快速再次发出声明传播到全网。RIP可以快速传播链路失效 OSPF开放最短路径有限 内部网关协议IGP 多种衡量比如延迟，距离，带宽。链路状态算法。 基于服务类型路由、负载平衡、分层路由、安全措施、隧道技术 自治系统分为区域，每个AS有主干区域0.用星连接，局域内路由；区域间路由都到主干再转发目的；自治系统间路由 路由器可以重叠：区域内，区域间，主干，自治边界。 BGP边界网关协议 外部网关协议 基于TCP 特殊的跨域路由协议：控制流量路由，更注重策略而非性能 TCP连接传递路由信息，路径向量算法，路由信息中记录路径轨迹。类似距离向量。广播所有目的地的路径。通过告不告诉路径控制流量。 消息类型 open，建立对等TCP连接认证身份；UPD，更新路径或者撤销；KEEPALIVE，没有upd也告诉你连接有效，回应open；NOTIFICATION报告上条消息错误或者关闭连接 CIDR无类域间路由 B类地址浪费大量空间 将剩余的C类地址分成大小可变的地址空间，推广到所有单播地址，掩码确定前缀长度。 世界四大区各有一块连续的C类地址，增加mask掩码域。最长前缀匹配：多个匹配成功选择掩码最长的路由表。适用于所有IP地址？？？ 分配地址的时候分配一些0和掩码。 匹配时，目的地址先and掩码，然后匹配根地址。并最后选择前缀最长（掩码最长）的表项即最具体的。 分配地址时，根据掩码数据对齐 IPV6不兼容IPv4但兼容很多Internet协议如TCP UDP OSPF BGP DNS 简化IP头，定长不用IHL，取消分片的域。必须能支持1280B的分组，路由器报错主机分片。不要检验和。更好支持选项更高安全 40B Priority 流控或不能，表示优先级高低 Flowlabel 允许src和dst建立具有特殊属性的伪连接 Payloodlen并不是总len了 nexthdr指示扩展分组头，如果是最后一个则告诉tcp或tcp 拉火车一般指示后面的分组头，目前六种 hopbyhop 指示挨个路由器检查的信息 routing 必须经过的路由器 fragmentation seq fragmentnum morefragment… 最大跳数 ::192.1.1.1 表示v4地址 过渡方案双栈，两套协议栈，主机根据DNS返回结果或对方版本号选择。路由器看版本 翻译，路由器可以翻译如NAT-64 隧道，把IPv6隧道进Ipv4里面传输，更有普适性？ 路由器体系结构和关键技术路由：建立端到端的路径 转发：确定next hop 难度在于：内存速度跟不上moore，性能要求（带宽增加）快于摩尔定律 结构发展 单总线单处理器 单总线多处理器，每个接口卡处理器来协调 交换结构+专用硬件 可扩展路由器 基本结构 多套网络接口 路由引擎，运行高层（路由）协议 路由表：被引擎更新，包含所有路由信息，承上起下 转发引擎，确定转发路径 内部交换，在接口和引擎间高速数据通路 两条路径 数据和控制 控制，进引擎再出 数据，关键路径，在内部交换后被转发：路由查找+内部交换 基本功能 正确转发的路由查找，正确传送的内部交换 查找算法 值入手，穷举，TCAM硬件查找 长度入手：Trie树 长度空间二分 线性链表太慢 二分Trie 最坏logN 储存效率低 路径压缩Trie，把单分支的节点压缩。 多分支 O（logN /K） 更新慢，空间浪费 大RAM的查找表 两级分别是16位，包含地址、下一层地址和下一条 区间二分查找 log2（2N）最多到logk（2N） 更新很慢 TCAM 速度快芯片贵功耗大更新慢 低地址前缀最长，一个周期精确查找 高速报文转发虚拟输出队列（队头堵塞）》输入队列 Ch8 端到端访问和传输层 67 1传输服务消除网络层不可考，提供端到端的进程可靠，与网络无关的数据传送 传送实体 1~4层为传送服务提供，往上叫用户 TPDU 传送协议数据单元 原语CS模式：listen connect send receive disconnect 对称（双方单独关闭）或者不对称（任何一方）的关闭连接 非对称数据丢失，对称两军问题（不存在安全N次握手释放对称连接）。一般用三次握手+定时器释放，即释放+定时 连接和释放，都是自己执行原语+对方包到达 Berkeley Sockets对称释放连接，都调用close 服务程序：socket创建分配表空间，返回fp；bind赋予地址；listen分配数据空间；accept阻塞等待连接，有连接请求的时候创建新的套接字和fp，原来的继续等待 客户程序：socket创建分配表空间，返回fp；connect阻塞并尝试连接； 传送层寻址 传送层编址即标识TSAP传送服务接入点，连接应用进程。互联网的TSAP为ip+本地端口 可能约好，也可能从目录、名称服务器（连接，查询名称，得到TSAP，释放）查询 进程服务器，帮助一些服务进程监听。多个端口监听，客户进程在某几个TSAP建立请求。如果没有服务进程，那进程服务器和用户连接帮助唤起服务进程。即简单应答一下请求，并帮助叫人。 连接管理三次握手 A发出序号X的CR TPDU B发出序号Y的CC TPDU，并ack X CR A发出序号X+1的data tpdu并确认Y CC 解决网络层丢失、重复等问题 缓存和流控不可靠的缓存每个连接单独缓存，一边重传。接收方随意。 固定大小，可变大小，通用缓存池 流控用可变滑动窗口，即窗口大小根据接收方的缓存情况给出（协商）。应该周期性发TPDU。 TCP协议字节流，端到端，连接，可靠 双方都套接字，作为TSAP，IP地址+端口。256被保留。点到点双工用两个套接字表示。不支持组播广播，消息边界不保留。 PUSH标记不缓存，强迫发送 URGENT紧急数据 按照字节分配序号 TPDU叫做SEGment 20B头+选项+数据；段不超过65535的IP数据包，不超过数据链路层的MTU，以太网1500MTU 滑动窗口，确认序号是接收方希望接受的下一个序号； TCP头 头长度 4b，用几个word表示，包含option。 RST用来不可恢复的错误重置连接 SYN 连接建立指示 FIN释放连接指示 ECN explicit congestion notification显式拥塞通知时，ECE表示ECN Echo，让发送端放慢速度。发送端设置CWR给接收端表示已经放慢停止ECE window size 从确认号开始可以再发多大字节流 checksum对TCP头 数据和伪头（addr+-+protocol+TCP段长）计算校验和 选项 三次握手建立 服务器listen+accept 开始监听 客户端connect 产生syn1 ack0 seq100的tcp segment 服务器检查服务进程 没有监听，回答RST重置连接 有监听，服务进程选择接受。SYN1 ack1（101） seq300接受。 客户方syn0 ack301 seq101 确认 服务机listen直接收到send，则去尝试SYN连接 SYNSENT后也在listen，收到SYN发送SYNACK到SYNRCVD 对称释放连接双方都可以FIN释放，但是只是一方不再发送。所以FIN ACK共2对才能释放，可以中间既FIN又ACK而3段释放。可能会同时发送FIN，那么单独确认后关闭。 主动fin，进入finwait1。被对面ack自己的fin进入finwait2。常规。 主动fin在wait1时，同时收到对面fin，发送ack进入closing。等待ack即可timewait。 主动fin后被对面ack+fin，则自己应答ack进入timewait。 被动fin，发送ack进入close wait，等待自己发完。自己这边发完了就主动fin进入等待最后的last ack，等到对面ack就成功释放。 传送策略在WIN0时候。紧急数据仍然可以发送，1字节端强迫接收端重新宣告ack和win叫做window probe窗口探测 发送方缓存数据等待大段发出 接收方期待捎带而非单独发 Nagle 发一个字节，然后每次等到ack后发送全部 Clark 解决傻窗口。应用层读一个造成window=1，至少多一点buffer再告诉发送方。比如一半buf或者最大段长 拥塞控制原因：网络慢buffer大（拥塞窗口，慢启动，避免拥塞），快网络小buffer（随时window调整），按照最小值发送 慢启动拥塞窗口congwin，初始值为最大段长MSS。先发最大段长，正确确认后拥塞窗口变为2个最大段长。被正确确认后加倍。直到超时or大于阈值threshold（64K）。也就是收到一个ack加一个段。 拥塞避免大于阈值后线性增长，一个RTT周期增长一个段长。直到丢包超时。 如果超时则阈值阈值减半，窗口变为1个段长。开始慢启动 快速丢包超时——快速重传 超时or三个重复ack，直接认定超时。阈值减半窗口回1. 以上三个技术最早在Tahoe版本实现 快速恢复？？TCP Reno会把当前的ssthresh的值设置为当前cwnd的一半，但是并不会回到slow start阶段，而是将cwnd设置为（更新后的）ssthresh+3MSS，之后cwnd呈线性增长。 有人说超时到慢启动，快速重传触发快速恢复。每接收到一个冗余的确认报文，cwnd就增加1MSS 快速回复再超时，慢启动。 非冗余ack，新ack，cwnd回到ssthresh开始拥塞避免 多用户竞争瓶颈链路带宽问题有效性+公平性 M 与原点连线，A正规斜线？？ MIAD 不稳定（需要初始带宽相同，且…），震荡；不公平收敛，大带宽全要；有效性不收敛 AIAD 稳定在ad==ai；不公平收敛；不有效 MIMD 稳定，来回震荡；不公平收敛；有效收敛（系数符合） AIMD 公平收敛 有效收敛，越来越靠近y=x UDP协议无连接，端到端 更快、简单、小头、没有拥塞。但是可能乱序丢失，每个都独立。用于流媒体（可以丢包但是速度延迟很重要） 其他应用：RIP发送路由信息 DNS SNMP（网关信息） 头 端口长度校验和 Ch9 网络应用 68 1应用层进程、线程通过os提供的IPC通信。不同主机则使用应用层协议通信。 用户代理user agent指的是用户和网络应用程序间的接口，如web浏览器，播放器 socket就是Internet API，两个进程读写socket通信。IP地址指明主机，端口指明进程。 TCP：email+smtp; remote terminal access+telnet; Web+Http; ftp; 流媒体+proprietary; remote file server+NFS; UDP: 流媒体+proprietary; remote file server+NFS; Internet telephony+Skype； DNS 流媒体，远程文件服务器，网络电话 CS模型请求——响应 服务器具备并发性，为每个客户建立进程or线程处理通信。一部分用于接受请求创建进程，另一部分负责实际处理和通信。可以同时使用tcpudp 域名服务 DNSdomain name service 小网络只需要查一个文件就可以对应主机和地址，但是大网络就不行 app调用解析器resolver，向本地域名服务器请求，以udp发送；本地域名服务器尝试解析，如果失败继续向上级域名服务器查询…直到解析完响应 名称空间顶级域名由ICANN管理，over250个顶级域名，不断被划分成一棵树 顶级域名分为组织结构通用域名和地理结构国家地区两种，下面有子域名. 大小写无关，每部分最长63字符，整体最长255字符。是从底下向上到根节点。这样前面一样也并不会冲突。 新的细分域名（新域）要被上级的管理员认可。 DNS数据库每个域都有一组关联的五元组资源记录， 域名——有关的资源记录 域名（可能有多个记录）；生存时间；type；class（IN表示internet）；value type SOA 名字管理员的电子邮件，域的基本信息 A or AAAA quadA 主机名——主机地址 MX name对应邮件服务器的hostname，通过@后面的地址找到邮箱服务器 NS 域名——权威域名服务器（地址）名字，所在域和子域的名字服务器，用于域名查询处理。 CNAME 规范名称别名——规范名称 DNS划分域名空间到很多zone，边界由人工设置。edu.cn 和 tsinghua.edu.cn为不同的zone，有各自的域名服务器。主和备份域名服务器，备份从主服务器获得信息。。。 多层DNS query example 查本地直接查，如果查外地。本地域名服务器联系根服务器（很强），然后逐渐往下联系。查询robot.cs.washington.edu 本地——根——edu——washington.edu–查英语系直接获得答案，计算机系需要再往下找到cs.washington.edu 本地不能返回部分答案，需要递归查询（负责到底）。根服务器返回部分答案给本地，迭代查询（我不知道，你问他吧）。 引入缓存 在本地域名服务器缓存一些常见的域名和IP，以及其权威域名服务器。不过缓存答案不一定及时更新（过期） 简单网络管理协议 SNMP功能：性能、故障、配置、记账和安全管理。基于UDP 模型被管理节点（主机路由器等网络设备）：运行snmp agent维护本地数据库，描述自己的状态历史等，影响运行。 管理工作站：运行manager 使用管理协议与代理通信，维护管理信息库 管理信息：每个站点用多个变量（对象object）描述自己的状态，组成MIB管理信息库 管理协议：用于manager查询修改被管理节点状态。被管理节点也可以向管理站产生trap报告 抽象语法表示法 ASN.1MIB采用树形结构，根在最上面。在不同计算机之间的对象描述和传输。分为数据描述定义和传输语法定义 5数据类型int bitstring octetstring（无符号字节） null object-identifier 任何标准中的对象都用对象命名树可以表示比如tcp 1 3 6 1 2 1 6 构造新类型的方法：seq seq of (1type) set set of choice(union) 也可以通过标记新老的类型来创建新类型，四类标签… 传输语法 编码规则BER标志符 + 数据长度域 + 数据域 标志符：2Tag|1type|5number 大于30的num第五位11111用后面字节表示 00 universal 01app 10 上下文特制 11private 0 primitive原始类型 1constructed 数据长度域 &lt;128 一个字节，高位0 更大时候第一字节高位1然后后面是表示长度的字节个数 数据域 int 直接二进制编码 bit str 头部第一个字节是最后不用的位数，比如0x07 octet不变 null 长度0 无数据 objident 命名树编码整数序列。前两个数用一个字节40a+b 如1361 编码为4 数据长度域 3 6 1 SMI和MIBSNMP在ASN1上定义了4个宏和八个新数据类型来定义数据结构，叫做SMI 变量叫做object，相关对象叫group，group汇集成module MIB包含十个组，管理站通过SNMP向站点agent查询这些对象的值 object属性：类型（名字）、语法（数据类型）、存取（access ro wo rw non）、状态（实现需要，比如必备实现，可以实现和废弃） 电子邮件SMTP协议结构用户代理（用户进程）——消息传输代理（邮件服务器，OS后台进程，从源发到目的端）——简单邮件传输协议SMTP 基本功能和进阶功能： 撰写、传输、报告、显示、处理 自动转发、自动回复、收件箱、抄送、加密、优先级、群发的mailing list比如students@cs.tsinghua.edu.cn 组成MIME 多用途因特网邮件扩展 多媒体支持，转换为ascii流发送 信封：接收方信息，如名字地址，优先 安全 邮件消息 邮件头：用户代理的控制信息,比如from 邮件体：实际内容 X.400地址/C=US/SP=MASSACHUSETTS/L=CAMBRIDGE/PA=360 MEMORIAL DR./CN=KEN SMITH/ SMTP描述 25号端口，TCP连接 接收方是服务器，首先发送准备接受消息 客户发出Helo 消息，服务器回答Helo，开始传输 首先发出From 和 RCPT To，服务器分别确定收信人存在，表示可以继续发送 客户发送DATA，以CRLF.CRLF结尾，服务器可以确认 服务器也会发送邮件给客户，过程相同。然后释放TCP连接QUIT 消息以7bit ascii为单位，特殊串如结束符不允许出现，可以base64编码之后 持久连接 POP3 用户代理和邮箱不在同机器，使用pop3取回邮箱的信件。 IMAP 多个用户代理访问同样邮箱 PGP/PEM 加密email WWW模型 Web页面 URL表示地址：协议+对象地址（域名orIP）+路径名 对象object组成 HTML+引用对象 browser 访问网页的客户端 MS IE Netscape Navigator Web服务器，储存web对象 Apache Microsoft Internet Information Server 超文本传输协议HTTP HTTP hyper text transfer protocolTCP 80端口 cs模型，无状态协议不保存客户信息。 1.0 非持久连接 http1.0 1.1 持久连接 2.0 多路复用 3.0 HTTPoverQUIC 例子建立连接——请求——响应一个页面——服务器关闭tcp——浏览器解析页面发现有十个引用的对象，再去请求对应的服务器 持久和非持久非持久 HTTP1.0 服务器响应后马上关闭连接，每个obj取得至少两个RTT，都需要慢启动 持久 HTTP1.1 同一个TCP连接上，服务器解析请求响应，再解析新请求。客户端请求所有obj，较少RTT和慢启动。。 代理服务器缓存web缓存如果有，直接返回。否则申请原服务器。有更小的延迟和减轻远端流量 文件传输FTP协议tcp 21 cs模式，并行的tcp连接。 21端口用来控制，使用telnet。在protocol interpreter中 20端口传输数据，数据连接可以双向，不一定始终存在，单独的数据传输进程。 维护状态：当前目录、身份认证 常用协议集 体系结构 - 物理层 SONET/SDH 光网络 链路层 ATM 面向字符：PPP字符填充，多协议多功能，改进SLIP，不滑动 DDCMP BSC BM XBM ，SLIP字符填充 原始IP包 标记字符定界 面向bit：SDLC ASCCP HDLC（主、次、组合站，使用011111110定界 CRC校验 信息、监控、无序号帧） LAP LAPB（X.25，是HDLC子集） MAC+LLC（HDLC）逻辑链路控制子层 802.3：1-坚持CSMACD 10Base5… 曼彻斯特 前导7字节10101010和一字节10101011 以太网 MTU（前导8）46+18~1500+14+4B 6字节地址 最短帧长大于2τ防止冲突 100BaseT4 25MHz 8B6T编码 每对33.3Mbps 10GE 只光纤 单模更好 不使用CSMACD 全双工 802.5 令牌环 需要延迟容纳令牌 重负载100% 曼彻斯特编码 物理层违例定界；源路由网桥指定Lan序列 FDDI 多模光纤 100M 4B5B编码 物理层违例定界 类似令牌环 DPT|RPR 城域网双环 SRP 802.11 WIFI——MACA（RTS+CTS 二进制指数后退） W确认，载波监听 收发器：csma等 交换机：隔离卡内冲突域，卡间并行无冲突 网桥：互联lan，转帧格式，隔离冲突域； 到根的最短路径为生成树，其他透明。 网络层 静态 洪泛 DIj 基于流量：剩余带包的导数 距离向量路由：无穷计算 水平分裂：从你学的不给你报告 Y失败 链路状态路由：Hello学地址，echo测开销； 包：自己、Seq、Age(TTL、邻居代价 Onlogn 可能震荡 TCPIP IPV6 1280B分组，主机分片；双栈、翻译（NAT64）、隧道 ICMP 报告错误和测试 ARP RARP：MAC IP BOOTP 使用IP UDP，可以分配其他信息。可以转发到其他子网 CIDR 无类间域路由：解决ipv4不够，罪魁祸首B类——把剩余的C类分为大小可变的地址空间。 不给B，多给几块C。世界上四段连续C类， 域内IGP RIP：UDP，距离向量；跳数为代价；30 180s OSPF：链路状态 多种代价 分层路由：区域和主干0号区域。穿越主干。四类路由器：域内、多域、主干、边界 ISIS：链路状态 域间EGP：需要定义策略，而非性能 BGP：TCP 路径向量（类似距离向量） 拥塞控制 开环：漏桶（字节计数）、令牌桶 虚电路：流说明、准入控制、资源预留 数据包子网：抑制、逐跳抑制 公平队列算法、加权公平队列——分组轮询到字节轮询 分片：出口重组or目的重组 路由器：网络接口、内部交换、转发引擎、路由表、路由引擎；完成路由查找 和 内部交换 传输层 berkeley sockets 对称释放连接 TCP 三次握手建立SYN，对称式关闭FIN（三次握手+定时） 20字节开头，满足MTU 可变窗口 Nagle:1 + all + all改善发送 Clark改善window 不保证延迟和带宽 UDP，不握手，只有len和check 应用层 FTP 控制tcp21+数据tcp SNMP udp 性能、故障、配置、安全、记账 背管节点、工作站、管理信息MIB、管理协议SNMP ASN1抽象表示，构造新类型，SMI管理信息结构。obj-grp-mod 10grp obj：类型、语法、存取、状态 传输语法：BER规则 标志符 tag type tag，可以后延，最后一个首1 数据长度域：高位0直接写，高位1表示有多少字节 数据域： Int 二进制直接传 bitstring 第一个串为最后不用的个数 octet str直接传 命名树放编码，两个数合并40a+b WWW结构框架HTTP tcp Email：SMTP tcp 撰写、传输、报告、显示、处理 信封接收方 信头用户代理的控制信息 信体 MIME多媒体扩展 POP3 IMAP PGP PEM 给用户收件 DNS udp 资源记录，type中A MX主机 NS CNAME SOA ICANN管理顶级域名 递归负责到底，迭代你问问它，本地服务器负责到底 Telnet tcp","link":"/2023/02/25/2022Fall-net-final/"},{"title":"2022秋季学期 计算机网络安全技术 期末复习笔记","text":"markdown丢失图片，可直接下载pdf版 网安期末复习lect1 为什么学 通信 电信和计网历史 网安概述攻击与防御 Enigma 密码概念 发展 Casear 单表 PF Hill Vigenere Verman OTP 列置换 破译 SDES Feistal 公钥原理 RSA DH DSA概念 密钥分配 KDC 公钥分配 概念 攻击与认证 加密 MAC HASH MDSHA 数字签名DSS 身份认证 basic 表单 session 证书 无线网 历史标准 威胁 WEP WPA12 TKIP 802.1x CIA OSI 安全目标-服务-机制-算法 认证保密完整访问控制等服务 特定机制 VPN源路由攻击 IP级安全 IPSEC 实现层次 文档 服务 SASP AH-ESP SA组合 IKE密钥交换 工作模式 SSL 连接共享会话 握手-记录 HTTPS WEB HTTP攻击ARP DNS 电子商务SET 双签名 无处不在的通信基本要素：信源、信道、信宿一个世纪前电信网 半个世纪计算机网络 单向广播有线电视网————三网合一 电信网的发展历程有线电报、电话；无线电报；寻呼；蜂窝移动；手机1830s 电磁电报机morse code滴、答、空。1、3、滴答间1字符间3单词中7 送话器：麦克风，电磁感应震动金属片or液体电阻or活性炭震动铜线传输；1876贝尔专利，双绞线 1878 交换机从一对一到一对多，人工接续1879 电话号码，1893步进交换 1938纵横交换1946 电子计算机 1965程序控制交换机 俄国人波波夫和意大利人马可尼各自独立完成了无线电通信 蜂窝移动通信系统主要是由交换网路子系统（NSS）、无线基站子系统（BSS）和移动台（MS）三大部分组成 无处不在的网络安全 信息窃取攻击蛮力 常用密码做字典，撞库：用获取的账户密码去登陆更大型的信息系统中间人 在受害者网络链路中数据监听和篡改；链路传输截取，并修改来欺骗两端拒绝服务 使计算机崩溃压垮来组织服务，最容易有效，最多，影响网络可用性。SYN洪泛；UDP洪泛；DNS反射病毒、恶意软件 传播到用户系统上，有时利用漏洞偷偷运行，伪装成正常程序欺骗用户。浏览、email、移动介质、下载 防守技术 加解密：中间人攻击 访问控制、身份认证：阻止非法访问 防火墙：阻止大部分外来非法请求 防病毒：识别坏东西并阻止 补丁：修复漏洞 揭开现象看本质Enigma 一战用于战争，1926装备德国军队有键盘转轮和显示器，没有空格和标点制造：1918,Arthur Scherbius破译：Alan Turing，Bomber转轮机——防止字频统计代换密码算法多表代换每次输入后转轮转动一格，同一输入对应的密文不同三个转轮后反射器，反射器不转动且字母为绑定的双射。相当于划分26字母到正反两个空间加解密对应转轮情况一样，即表一样加密：三次正翻译，取反，三次反翻译解密：三次正翻译，取反，三次反翻译使得译码和编码过程相同 使用过程 调节三个转轮初始方向 明文打键盘到显示器的密文闪亮并记录，电报发出 接收方打开同样的Enigma，转轮初始化键入密文出现明文 举例 初始化转轮。 输入A，转轮向前（左，反字典序）转动，七次查表翻译D 再次输入A，转三个轮，七次查表得H 这个例子只有第一个轮在转动？ 加强 如果得到机器（三个固定表）则秘钥为初始方向，可以蛮力 滚轮可拆卸并组合 键盘和转轮1之间有“连接板”，错位连接一些字母成为另外的信号。最多相当于两两交换六对字母 lect2 密码学 I基本概念不同于隐藏（保险柜和密信），不同于访问控制（口令没有加密安全性很弱） 加密形式 传统（对称、单钥） 代换、置换、二者组合 安全性在于保持算法本身保密 不适于大规模生产以及变动大 用户不了解算法安全 公钥（现代、非对称） 算法公开；密钥保密 安全性在于密钥的保密性 概念 密文cipher 明文message有时候为passage 密码算法：Encoder Decoder 密钥Key，在ED中作为下标变量 编码学与分析学：加密方案和破译 编码学的独立特征 转换明文为密文的运算类型 基于置换：重新排列明文元素 代换：映射成另外的元素 不允许丢失信息，运算可逆 所用的密钥数 发送接收相同密钥：对称、传统 不同：非对称，公钥 处理明文的方法 分组密码、块密码：每次处理一个输入分组对应一个输出分组 流密码，序列密码：连续处理输入元素，每次输出一个元素 简单加密：异或。CPK任何两个异或求出另一个 无条件安全（信息论安全）：有多少密文（无限的计算能力）都不能唯一确定由该体制产生密文所对应的明文 每次都换密钥，绝对安全 计算安全 破译密码代价大于数据价值 破译时间超过信息声明期 发展周期 古典密码：艺术，需要算法保密。都是针对字符的代换置换，简单的分析手段 近代密码：有计算机；成为科学；有线电报产生现代编码学；无线电报产生现代密码分析学； 加密体系安全性不依赖加密方法本身，而是依赖于所使用的的密钥 shannon发表论文成为科学 1976 新方向：公钥密码体制，从DES开始 古典密码（代换）Caesar 凯撒密码每个字母换成后面第三个字母key：往后换key个，25种穷举即可升级 密钥次密码：一个密钥次放前面剩下按顺序。单表代换评价 明文的语法模式和结构有多少保留在密文，减少这样的保留信息： 对多个字母一起加密 多表代换 Playfair密码多表代换key：密钥词构成5*5字母矩阵，IJ合并，按行填写。加密：一次两个，相同字母ll变成lx（x为填充字符） 同行，向右一个单位 同列，向下一个单位 四方对角线替换？如果是ij密文输出什么？评价 完整保留了明文语言结构，几百个密文可以分析规律 Hill密码多表代换m个连续的明文字母带换成m个密文，由m线性等式决定，每个字母都是数字0~25。key：m*m矩阵，解密用K逆矩阵——并不所有矩阵都可逆。评价 隐蔽单字母频率，矩阵越大隐藏信息越多。33矩阵隐藏了双字母的频率 Vigenere密码一系列凯撒，多表代换 相关的单标代换规则集，由密钥决定具体变换加密过程第一个密钥字母加密明文的第一个字母，第二个密钥字母加密明文的第二个字母，等所有密钥字母使用完后，密钥又再循环使用。第一步可以先将密钥的长度拓展到（或者缩减到）和明文长度一样。查表 or 计算（Mi+Pi即可）评价 强度在于每个明文对应多个密文，且使用唯一字母作为密钥，来掩盖频率。 字母频率隐藏 并非所有明文结构信息都被隐藏 Vernam密码和一次一密与明文毫无统计关系且一样长，基于位的二进制异或运算得到密文。改进：与消息一样长且无重复的随机密钥——一次一密OTP，直接相加mod26就好评价：不可攻破但是没屁用 大规模随机密钥很难 密钥的保护和分配很难（安全信道&amp;用后销毁） 古典密码（置换）新的排列简单栅栏技术：对角线写入明文，行读出为密文写成矩阵块，按列读出并打乱列次序。列次序为密钥。单步or多步置换 简单置换逐行写入矩阵块（不足行补进随便字母xyz），按列次序读出key：列次序如4312567，即先读1所在列…多换几次后，没什么规律了 转轮机（多层加密）包括一组相互独立的旋转轮，电脉冲可以通过；每个圆筒有26个输入引脚和26个输出引脚，并且一一相连每个圆筒就定义了一个单表代换，多个圆筒就是多表代换三轮\\四轮Enigma 古典密码破译举例穷举、蛮力：不适用一次一密，单纯尝试看明文有无意义频率分析：猜字，最常出现e，q后面u，还有双码、多码统计特性等等单表代换破译过程举例： 词频统计，先换最高为e，t 开始根据三元组（the）、语法规则was been等猜词 对称密码算法加解密密钥相同，密钥用保密信道分配常用：DES、IDEA、RC245、AES、CAST-128、Blowfish 对称密钥密码S-DES（简化DES）输入：10bit key 8bit明文组输出：8bit密文组，破译过程相反包含函数： 初始置换IP 复杂函数fk：包含置换代换，依赖key 简单置换SW 复杂函数fk 初始置换地函数IP^-1 密钥拆分：其实是把10位key拆成两组8bit K1K2用： 10bit K 置换P10 前后两组循环左移1位，放入P8得K1 前后两组循环左移2位，放入P8得K2 加密过程：IP fk SW fk IP^-1 先IP，初始八位置换26314857 K1作fk：fk(L,R) ={(L xor F(R,Key)) ,R},F(R,key) = P4(S0S1{EP(R) xor key}) 扩展，密钥，S盒，4置换 L4R4拆分，R4为输出后4 R4作扩展置换EP：41232341 与K异或 L4R4拆分，分别放入S盒得2*2位输出，合并为4bit S盒 4x4矩阵，取值在0~3,1、4位决定行，2、3位决定列，查表 置换P4：2431 与刚开始L4异或为输出的前半边，后半边为R4 交换函数SW，前后4互换 用K2重复fk 末尾置换IP^-1:41357286 置换求逆：排列回来 加解密过程完全一样且对称 Feistel密码结构Vigenere和Vernam为流密码验证：改变分组大小不改结果，不整除分组也不用补字母分组密码：64|128bits，基于网络 Feistel建议： 使用乘积密码来逼近简单代换密码：依次使用两个或以上的基本密码，所得密码强度将强于所有单个密码的强度 交替使用代换置换 shannon： 扩散 明文统计特征消散在密文中，每个明文影响多个密文 混淆 密文和密钥的统计关系复杂，难以推导密钥 输入：2w bit明文组，密钥w bit Ki 明文分开为wbit L0R0，经过n轮迭代组合成密文 每轮迭代的输入都是上层的输出，但结构相同 L0和F（K1 R0）异或成R1 R0直接成为L1 子密钥Ki由K推出，有Ki生成算法评价： 分组长度和密钥长度：越长越安全，但是慢 迭代轮数：多轮安全 子密钥产生越复杂越难以密码分析攻击 轮函数复杂，抗攻击强 DES分组加密，对称密钥，56bits Key（奇偶校验后写成64bits），分组64bits，标准算数逻辑运算加密过程： 密钥生成器： 56+8的密钥，拆分为28+28 两个28根据16轮，不同循环左移1or2位 置换选择PC-2 56选48bits成为Ki 两个28根据16轮，不同循环左移1or2位 置换选择PC-2 56选48bits成为Ki+1 明文分64bits块m IP初始置换64换64 T1，16轮迭代过程和Feistel相同 具体：R0直接成为L1 F（R0，K）E扩展，K异或，S选择，P置换 32bR0 E盒扩展至 48b 输入一位影响下一步的两个替换，输出对输入依赖传播快，密文每一位都依赖明文的每一位 和K1异或 S盒代换选择，48选到32b 8个6选4的S盒 首尾决定行，中间4b决定列 需要4x8矩阵，取值0~15 P盒置换为32 和L0异或成为R1 T2 … T16 IP-1末尾置换64换64 解密：IP T16：1 IP-1，完全对称过程 其他常用对称密码3DES，blowfis，RC5，AES（取代DES） 高密码强度 广泛用于Internet 代表DES以来的对称密码 3DES两密钥112bit三重DES，明文攻击代价2^112 blowfish快速紧凑简单安全可变64bit分组，密钥32-448bit 子密钥和S盒都是blowfish本身生成，数据不可辨认，密钥分析困难 每轮对数据左右同时运算，和古典feistel不同，密码强度增强 448bit密码抵抗穷举 RC5快速；迭代和key长可变；简单；高安全分组32、64、128密钥0~2040b由分组长度，迭代次数，密钥的byte数决定的算法族使用： 字的模2^w假发 xor 循环左移 AES3des太慢，分组太短——分组128支持128192256密钥的AESw 128 key128 免疫所有已知攻击 所有平台执行快代码紧凑 密钥被扩展为44个wordlen = uint32的数组，每轮有4个字参与 轮密钥加是vernam密码 设计结构简单， 轮密钥加 九轮迭代 字节代换 行移位 列混淆 轮密钥加 最后一轮 字节代换 行移位 轮密钥加 不是Feistel结构 每轮四个阶段，一个置换3个代换，均可逆 字节代换：用一个S盒完成分组中的字节代换 行移位：一个简单的置换 列混淆：算术代换 轮密钥加：利用当前分组和扩展密钥的一部分进行按位异或 lect3 密码学 II非对称密码原理缺陷： 密钥需要安全信道分配 无法用于数字签名？ 密钥管理复杂，O(n^2)的数量 基于数学函数而非代换置换概念： 明文、密文 会话密钥Ks：对称密钥 加密、解密算法 公钥U 公开，用来加密和验证签名 私钥R 保密，用于解密和签名 加密： 每个实体有一对密钥，接收方的公钥加密信息，私钥解密。 每方持有所有公钥和自己的私钥，向谁发就用接收方的公钥加密 签名： 发送方用自己的私钥加密签名发出 接收方用发送方的公钥解密验证发送方 密钥交换： 协商会话密钥来对称加密 可同时使用加密和签名——先自己私签再对公加密 数学原理：陷门单向函数不知道陷门信息求逆困难，知道后容易实现 给定x，计算y=fx容易 给定y，计算x为y=fx困难 存在δ，有δ对y容易计算x（陷门性） 对于加解密，f为公钥δ为私钥 密码分析： 容易被穷举，利用公钥对所有可能的密钥加密，尝试密文是否一致 应对：长密钥，不能太长 函数复杂性不是密钥长度的线性增长，指数或更快 仅用于密钥管理和数字签名 非对称vs对称比较 公钥并不更安全，安全取决于计算量 公钥并不通用，传统并不过时：公钥计算量太大，仅限于密钥管理和签名，不可能取代传统密码 公钥密钥分配很简单：也需要协议、中心代理，并不比传统密码更简单 数论基础任意正整数可以唯一表示为一组素数的乘积模运算，对加法乘法可交换结合分配（需再mod） 欧拉函数与欧拉定理 RSA分组密码，明文密文0~n-1，常用1024bit或309dec密钥产生公钥：小互素整数e，私钥：de=kφ+1攻击蛮力：尝试所有密钥数学：素数乘积的因子分解计时：记录计算机解密时长猜私钥，可以攻击很多公钥系统，仅依赖明文安全性大数素因子分解很难的性能软件硬件分别比DES慢100、1000倍 DH密钥交换两个用户安全的交换密钥，仅此原理：计算离散对数非常难，本原根 a几次方mod 素数p可以从1~p-1排列 密钥交换过程： 其中的a p Xa Xb中素数p最大 选择底数a和素数p公开 Alice和Bob各生成一个自己的私钥XaXb保密 计算a^(Xa)mod p and b^(Xb)mod p 公开 用对方的公钥乘以私钥次方得到共同密钥a^(XaXb)mod p 其他非对称密钥算法DSA数字签名算法也基于计算离散对数的难度 不能用于加密、密钥分配 NIST有后门 选择不公开，分析不充分 比RSA慢10-40倍 密钥512位太短 侵犯其他专利 椭圆曲线密码 有限域、容易构造运算器 加密快，小密钥高安全性 密码加密加密选择：链路or端到端链路： 数据链路层，在传输的每个相邻节点都加密再解密，使用不同密钥， 分配难度不大；无需额外数据；对用户透明 不适用于广播；链路节点中以明文存在； 端到端： 中间不解密，灵活的应用和层次选择 广播网可用；节点损坏不怕；便宜可靠；容易死设计实现维护；没有同步问题； 容易被通信量攻击；分配密钥更难；不能掩盖地址 密钥分配传统对称密码分配 A选择并亲自给B 第三方选并亲自交AB AB最近使用的密钥，加密一个新密钥发给对方 C与AB有秘密渠道，分别秘密发给AB 12人工传送适用链路 密钥分配中心KDCAB想连接，都分别有自己和中心知道的密钥（主密钥） A请求会话密钥保护与B的逻辑连接，有AB信息和N1 KDC用Ka加密消息响应A：一次性会话Ks；原始请求N1便于A响应；两项用Kb加密的给B内容（Ks和IDa）。 A存下Ks把后两项发给B（也可以理解为KDC发给A和B），结束 层次式KDC减少主密钥分配代价，本地KDC攻击破坏更小 公钥分配 用于分配公钥 公钥密码用于传统密码体制的密钥分配 公开发布公钥直接发或者广播，方便但容易伪造 公开可访问目录可信的实体组织维护、分配公钥目录 通讯方目录项 &lt;name,ku&gt; 通讯方可以注册、更新自己的公钥项；访问通讯录目录管理员的私钥破坏很大 公钥授权 公钥证书证书管理员证书：公钥和其他信息，发给相应私钥的通讯方通信方传递证书来传递密钥信息，其他方验证这个证书由管理员发出 任何通信方可以读取证书确定证书的拥有者的姓名和公钥；可以验证证书出自管理员而非伪造 only管理员可以更新证书 各方可验证当前性（过期证书） 公钥分配传统密码公钥太慢 最简单（树洞）被主动攻击 保密真实“要真的是你就把我给你的信息再给我发回来~”3次握手，AN1,N1N2,N2; 互有公钥 A用B公加密（A，N1）给B B私钥解密，用A公加密发送（N1，N2）给A A解密看到N1，确认对方是B，B公加密个N2发给B B解密看到N2确认是A A可以选个Ks用Ub加密发过去公钥密码分配密钥也需要KDC？通过主密钥实现会话密钥分配 lect4 认证凡认证必比较 消息认证基本概念传输分析：双方通信模式面向连接：频率和持续时间；通用：消息数量和长度 伪装：欺诈者向网络插入消息攻击者产生消息并声称来自合法实体非接收方应答（收到或者未收到） 攻击很多：内容、顺序、计时、否认泄密与传输分析——消息保密伪装修改——认证发送方否认——数字签名接收方否认——数字签名和专门协议 消息认证 验证消息来源且未被修改也验证顺序和及时，数字签名和协议技术等等下层：产生认证符的函数上层：将函数作为原语使接收方验证消息真实性 三类认证函数： 消息加密：整个密文 认证码MAC：消息和密钥的公开函数，产生定长值为认证符 Hash函数，映射为hash值的公开函数 认证函数1：消息加密AB共享密钥K，没人知道密钥就有保密性，解密后确认由A发出——并不绝对，容易伪造要求明文有易识别结构，不通过加密函数不能重复 加密前附加错误检测码（帧校验序列FCSor校验和）先FCS后加密，解密后重算FCS：可认证（有效）先加密再FCS，可混淆 TCP： 认证函数2：MAC码定长MAC = C(sharedK,Message),不需可逆共享密钥，可认证，不能签名 消息+MAC后，整体加密：认证明文为持有K的人发出消息加密后，计算MAC附加：认证密文为持有K的人发出，裸奔的MAC？很好篡改MAC app： 组广播，一个接受者验证并告知其他人 接受者随机进行消息认证 明文的计算机程序，不需要加解密，保护完整性来验证MAC 关心认证而非保密性 保密和认证分开，层次灵活：应用层认证，传输层保密性 认证函数3：Hash单向hash类似mac，为message digest，具有检错能力 附加hash值后对称加密：一定来自A且未篡改，也保密 不要求保密时：仅对hash值加密，代价小，也可以认证。 用私钥对hash加密：认证和签名 私钥加密hash，对称密码加密整个：认证、签名、保密 含有共享salt：M加盐后哈希，附加在后面，明文传输：只有有盐的人可以验证通过，也认证 加盐的哈希后对称加密：保密+认证 加密的代价： 慢 硬件成本 小数据块更难以优化 加密算法专利 美国限制 Hash要求：杂凑散列输入长度不限但输出固定单向寻找扛弱碰撞:找一个b与a哈希值相等抗强碰撞：找xy，哈希相等 hash一般结构L个b长分组，最后不足就填充——包含长度信息每个单元输入是之前的n位哈希（连接变量CV），b长度输入分组(Y)，通过压缩函数输出n为分组连接变量的初始值(CV0=IV)又算法开始指定，终值就是哈希一般分组长度b&gt;n所以是压缩https://codimd.s3.shivering-isles.com/demo/uploads/0d2a0805-246a-49b4-9891-af1d5ccccefc.png压缩函数抗碰撞——hash抗碰撞 主要hash算法MD组，产生128bit的mdMD2：补成16bit倍数，加16bit校验和算hashMD4：碰撞 几分钟碰撞MD5：王小云攻破 SHA：Secure Hash Algorithm改MD45，有012方案RIPEMD-128/160/320HavalGost MD5512bit分组128bit输出简单，32位容易步骤： 填充位到mod512=448，少64到整，一个1后面0 填充64位为 消息长度mod2^64 初始化md缓存128bit 0f f0 以512分组处理，4论*16迭代 每个压缩函数分四轮，128的连接变量向下传递，结合512 16字的输入 T[i] = 2^32abs(sini) 每轮中再进行16迭代 ：b根据a变化，其他向右挪一位 最后一轮+CV为下一CVs？ 强度 输入依赖小，强棚64弱128 SHA建立在MD4512bit 分组SHA1 message&lt;264 –&gt; 160mdsha1算法 补充到mod512=64 补充64位报文长度 初始化5个32寄存器缓存 分组处理，两组*五轮*16迭代 RIPEMD-160512分组输出160md 填充到mod 512 = 64 填充长度 初始化5*32 2组*五轮*16步 比较 都不受弱碰撞，md5容易被强碰，另外俩在将来还安全 抗分析：MD5最差 RIPEMD最好 速度：都是32位加和位逻辑，MD5最快 只有sha1高位在前 数字签名DSS防止通信双方自身攻击 B伪造发自A的 A否认发过的 签名需要 验证 签名者、日期时间 认证被签名的消息内容 第三方可仲裁 分为：直接&amp;仲裁 直接 用自己私钥对消息orhash加密签名 接收方公钥加密or对称密码得到保密性 依赖发送方的私钥安全性 仲裁 X到Y的签名消息先给A A检查消息内容和签名来源，然后加上时间戳发给Y，表示仲裁通过 数字签名标准DSS，使用SHA-1，定义DSA不能加密和分配，只签名 身份认证确定你是你——信息（口令密码）、拥有东西（钥匙，盾）、身体特征（生物特征验证）安全网站：认证授权审计+修bug 网站身份认证HTTP：一次连接，无状态 Basic认证每次发送携带凭证明文（账号+口令），与服务端用户凭证比较Base64编解码每次传递容易被监听窃取；本地需要保存账号口令，安全隐患；每个请求都需要验证，低效； 改进 加密传输，消息认证——监听窃取；表单验证+session？——本地保存和每次检查 对称加密U，口令就是密钥k，传输U和EkU——被重放攻击？ MAC认证第一次服务器只给你随机挑战码M第二次用K加密后发回来，服务器加密认证正确 表单身份针对：账号口令本地保存；每次都进行账号口令验证；Session原理：客户端、服务器和时间段 服务器产生唯一的标识符发到客户端 客户端把此随机串存在Cookie中or本地文件，作用域和有效时间… Session存活时候，每次请求都有标识符，服务器关联起 结束后销毁标识符 表单认证过程： 客户端发请求，服务端返回表单页面 用户填写表单（账户密码），服务端验证通过启动Session返回 客户后面请求携带Session的标识符，服务端验证。一般基于以标识符为key的哈希表 优点：简单；方便；易用缺点：账号口令裸奔 改进： 引入挑战机制，避免明文传输和重放攻击 挑战为字符串+时间戳,为U 口令为密钥加密Ek(M||U)，发送U和Ek(M||U)，服务器用存储的k加密M||U来比较 传输账号口令时用传输层SSL来传输请求，在传输层加密并验证身份。启动SSL就是Https 不安全：——泄露，重放攻击 验证后cookie存放账号口令 账号口令加密后Ek（UP）放Cookie可以加上时间戳t，每次服务端验证时间戳 增强认证动态方式！短信、动态（时间同步or计数器）、USBkey、数字证书动态安全令服务器和令牌段共享key和sn，对t进行划分取整。计算F(H(t||key||sn))，H为hash，F为压缩USB私钥不可导出，在里面加密签名 数字证书证书授权中心发行，用来数字签名的文件包含：拥有者公钥，名称和中心的数字签名，对应私钥妥善存储。 lect5 WLAN概述5W6A的梦想，TDMA，CDMA，GSM，3g，4g 最早的无线计算机通信：ALOHA 安全威胁无线射频电波传输，无法物理隔离，只能广播 窃听：开放信道——泄露身份和位置——跟踪 假冒：截获身份信息后，假冒其入网 篡改：修改窃听信息并发送 重放，重路由：复制有效消息再发送or重用；改变路由来捕获 错误路由：路由到错误目的地 删除：截取删除 洪泛：发送大量无关、伪造消息耗尽资源 加密认证技术无加密认证AP 无线网络创建者，相当于无线路由器 STA 连接到无线网络的终端设备站点 SSID Service Set Identifier 便于用户识别的AP标志名，WIFI名。使用者提出正确SSID，AP就接受登入。SSID会被广播，禁用提高安全性 有线对等保密协议WEP802.11b RC4流加密，访问控制+保护隐私。有挑战机制，四次握手 开放系统认证——默认认证方式，对请求认证的人提供明文认证 RC4：流密码，40/112bit的key，用CRC32循环冗余校验 设备和接入点共享默认密钥，每个设备和其他设备要有密钥对关系，分发困难。 WEP加密 CRC32算校验和ICV，串接在明文P后。 24位初始向量IV和40位key连接得到64位数据，输入到虚拟随机数生成器产生一次性密钥KE KE和第一步异或得Y IV||Y传输 WEP解密 24位初始向量IV和40位key连接得到64位数据，输入到虚拟随机数生成器产生一次性密钥KE 把密文和KE做异或得到明文P和校验和ICV 计算明文的CRC32，比较；接受或丢弃 安全性？ SSID下所有STA和AP共享密钥，容易泄露 RC4密码流的IV明文发送，且24位IV太短容易重复 CRC线性非加密，不是安全的杂凑函数（hash）不能认证 RC4位序列密码加密，太容易被攻破 不含序列号，没有帧顺序，重放攻击 WPA1 过渡性，核心是1x和TKIPTKIP认证，WEP包装 企业：802.1x认证 个人：Pre-shared key模式 RC4流密码 128bitkey 动态变化每个数据包的密钥，混合生成不能轻易破译 每个包有独特的48位序列号防范重放 Michael消息认证码MIC，包含帧计数抵抗重放 802.1x CS模式，在终端和AP建立连接之前验证用户身份，需要上层EAP配合认证和分发密钥 WPA2 更安全的CCMP消息认证替代Michael 更安全的AES对称加密替代RC4 支持11g以上 lect6 CIA，VPN网安体系结构 Confidentialit 保密、机密 信息不泄露；数据拓扑流量都需要保密；防止被动攻击； Integrity 完整性 不被篡改or可以检测篡改、插入、重放；防止主动攻击； Availability 可用性 授权用户得到应得资源服务，防止拒绝服务攻击； 对信息系统可用性的攻击； 对路由设备处理能力，buf和链路带宽攻击 X.800：OSI安全框架，定义系统方法提供给网络管理员安全服务：由系统提供的对系统资源特殊处理或通信，通过安全机制实现安全策略 安全机制：免收监听；组织攻击；恢复系统 安全攻击：主被动 服务 服务 机说明 认证 单条：保证发送方真实；通信：保证双方真实+不受干扰和伪装 对等实体认证 保证实体身份；禁止伪装和非授权重放；面向连接 数据源认证 保证来源是来源；保证来源身份合法；不保护数据复制修改；面向无连接 保密 连接or无连接；力度：流、消息、选择字段 防止流量分析（src dst freq len等特征 完整性保护 连接：收发一致；无连接：不被篡改；主动攻击检测而非阻止攻击？ 访问控制 合法才可访问 抗抵赖 接收方证明消息只能由发送方发出；发送方证明消息确实被接收到 可用性 根据系统性能说明，按照授权系统实体要求使用系统和其资源 机制普通&amp;特定 普通：不属于任何协议层or安全服务的机制 特定：特定协议层实现的 VPN Virtual Private Netword 虚拟专用网BG TCPIP安全缺陷 容易监听，篡改，重放，修改IP 源发可以指定中间路由——源路由攻击 序列号猜测，缓冲区溢出 概念：逻辑等价于一条物理的专用长途数据线路，定制化。在公共网络上仿真一条点对点的私有链接。 安全功能 数据机密性 数据完整性 数据源身份认证 重放保护 解决方案（安全协议） 链路层：L2TP PPTP L2F 很少使用 认证终端实体而非流入报文，无法抵抗插入和地址欺骗 没有完整性校验，可能拒绝服务攻击 PPP报文加密但是不支持自动产生、刷新密钥，会被破译 网络层：IPsec IKE 传输层：SSL 零客户端，任何B/S结构（browser和Server） SSL和IPsec结合，网关也常被集成 SSL低成本，但是视频会议非BS无法用ssl vpn 应用层（无法VPN） https ： http+ssl S/MIME 安全邮件 SET 安全交易 lect7 IPsec和IKE网络层：IPsec安全，IKE管理密钥 IPsec保证IP级别的安全性 认证：确保从源发出且未被篡改 保密：加密防止窃听 管理密钥 原来IP：无连接，无顺序（重复、丢失）设备简单无状态 不认证、不完整、不保密，通过IP地址有一些访问控制 威胁：窃听、伪造地址、篡改、重发 实现： 主机实现（OS）：端到端安全；针对每个会话提供安全保障；对应用和用户透明 防火墙上实现：不改OS，为所有应用提供安全服务。在网络层以下 路由器： IPSec体系结构文档认证和加密——通过主IP包头使用扩展包头实现安全特性。 认证扩展头：认证头AH 加密头扩展：封装安全载荷ESP(也认证也加密) 服务为IP层提供安全服务，系统选择协议和算法，并提供密钥 安全关联SA Security Association通信双方对要素的协商，一些安全信息参数集合比如 协议；操作模式；密码算法；认证算法；密钥及有效期； 是单向关系 发到收的，如果交换需要建立两个SA。 安全服务可由AHorESP提供但不能二者都提供？ SA由三个参数唯一确定： 安全参数索引SPI parameters index 和SA相关仅在本地有意义 AH和ESP携带，接收方选择合适的SA来处理 IP目的地址IPDA 单一地址表示SA目的地址 可以是用户端、防火墙or路由 安全协议标识符：是AH or ESP的SA 任何IPsec实现端，都得有SADB来定义每个SA相关的参数。用上述三元组来索引。 SA参数列表 收发IP包时的操作： 在SPDB中通过比较对应域的值（dstsrc的地址和端口 用户标识 数据敏感级别 传输层协议 IPsec协议 IPv6报类、流标签、服务类型）寻找匹配的entry，0或多个。 根据策略来操作：丢弃；bypass IPsec；apply IPsec等 如果存在SA则选定SA和对应的SPI，AH或ESP的选择。。 收到数据包，解析出三元素SPI，DSTaddr和AH|ESP 查找本地的SADB 找到SA条目，把参数和包头中的域比较。 没有查到，输入包丢弃，输出包创建并存入SADB SA的两个库存在OS kernel 通信前必须建立SA，先查SPDB找信息流和联系的SA。有的丢弃有的不加密有的加密；再关联or找SADB选择参数。 多种方式实现IP通信的sec服务； 对于需不需要保护的流量大粒度区分； IP流量和SA相关是通过安全策略数据库SPDB定义的 定义IP流量子集的entry 指向流量对应SA的指针 多个entry和同一个SA相连 多个SA和同一个SPDB entry 相连 每一条SPDB entry由IP集合和上层协议定义，成为选择子SAselector 过滤输出流量，映射到某个SA IPsec 传输模式提供上层协议保护，增加IP包载荷保护。用于两台主机的端到端通信，放到IP头后面和TCP/UDP头前面 ESP加密和认证IP载荷，不包括报头 AH认证IP载荷和部分报头 IPsec 隧道模式原来的包被看成数据直接抱起来成新的大IP包 保护整个IP包，整个数据包被当做新的IP载荷拥有新IP报头，利用隧道传播，中途路由器不能查内部IP报头 ESP加密和认证整个内部IP包 AH认证整个内部IP包和外部IP报头的部分 认证头AH基于消息认证码MAC，双方共享公钥 SN不能允许循环计数，到头就中止SA再次协商，可以反重放。要求按照这个序号建立窗口W（64） AD变长域，是4B整数倍。包含完整性校验值ICV或者包的MAC，可以用HMAC-MD5|SHA1-96 取前96位 IP头的不变部分，AH中终点可预测部分参与计算MAC。其他全0 途径1 直接在服务器和客户站之间使用传输模式认证。只要共享同一个key就好，这个key用在哪了？ 好像在MAC中也需要独特的公钥Key 途径2 服务器不支持认证，工作站需要向防火墙证明自己身份并访问整个内部网络，用隧道模式SA 隧道模式AH 通常在防火墙|路由器上实现前面包裹上新的IP头和AH，没有尾巴 对接受包的处理 解析SA的三元组，在SADB里匹配SA参数，不一致就扔了，找不到也扔了 （opt）滑动窗口的检查序列号 计算ICV比较，不相等扔了，相等交由IP协议栈处理，继续路由… 随时不相符扔了+记录审计 对出去outbound的包处理 从IP协议栈中收到需要转发的包 使用选择子查找SPDB，获取安全策略，也可能直接扔了 需要IPsec，则查找SADB 找到了，选取参数计算ICV 没找到，使用IKE协商建立SA存上，并选取参数计算ICV转发 不需要直接发走 加密和认证头ESP 加密算法：3DES RC5 IDEA CAST Blowfish 对称加密 padding：填充到明文符合加密算法的要求，对齐后面的两个填充长度和nextheader到右对齐。隐藏载荷实际长度，提供流量保护 传输模式IP ESP头 密文 秘密ESP尾巴 可选MAC尾巴（opt） 中间路由只检查前面的IP头 目的节点处理三元组，查SADB找到SA的参数，来恢复数据 隧道模式 保护原来的IP头吗新的IP头 ESP头 加密的（IP头 数据 ESP尾巴） 可选MAC尾巴 对Inboud 最后多一个解密 一开始也要查SPDB 对outbound 中间多一个加密——先加密再ICV 查SPDB 查SADB——用IKE协商建立储存or查到 产生计算序列号值 加密 计算ICV IP——分段转发（根据MTU分片） 路由在中间 安全在两边 安全关联组合单SA实现二者之一，需求：主机间IPSec在安全网关最相同流量分离。即在防火箱拆一层然后在主机可能再拆一层。。 有个SA序列组合成束，每层SPI|SA都不同 传输邻接：IP包多个协议，只一级。即AHESP 隧道迭代：可以一直包装。。。多层嵌套 甚至可以先用传输，然后再隧道包装 IKE管理密钥Internet Key Exchange 管理员手工给系统分配各类密钥 自动，协商。。。 IKE：自动协商交换密钥 + 建立安全关联SA（维护SADB） 服务很多SNMPv3 RIPv2 OSPFv2 精髓：不安全网络上不能直接传，都是算出共享密钥。（核心为DH交换） 混合了三种协议 报文格式from ISAKMP，可以在任何传输orIP层实现，用UDP port500 载荷里面是协商的参数，需要协商的参数都是payload。 下一个payload的类型 两个cookie用来唯一标识密钥交换会话 使用地址、随机数、日期时间等等MD5出来 FLag只用到了低三位 载荷加密 同步密钥交换，如果1则需要A最后给B发建立成功 载荷有认证or没加密只认 报文总长度（头+载荷） 13种载荷： SA，协商安全属性，指出解释DOI和状态 proposal 包含在1 TRansform 包含在2 Key Exchange … IKE体系结构——两个阶段 一阶段：两个IKE实体间建立IKE SA，创建通信信道并验证。提供机密，消息完整和消息源验证服务 需要协商：加密、哈希、认证、DH信息等等 main主：6消息，有身份保护 12：SA协商策略，商量SA之类的协议信息。大部分是使用的算法和限制等。1载荷很长2剩下3个回去 34：密钥生成信息， 带着key exchange和nonce载荷，用DH 56：加密的身份和验证数据，ident身份认证（标识信息主机名等等）和消息认证Hash（hash三组密钥信息） 56的散列载荷hash相同，一阶段成功 积极（快速）：3消息，无需身份，一方地址动态。可以用name验证而无需IP，但是两个都变就不行- 1：发起策略+密钥生成，SA KEY Nonce ID都给过去- 2：密钥生成+身份和验证数据，响应1并加入HASH- 3：身份验证数据，加入HASH。看hash成功就直接完成 二阶段：使用IKESA建立IPsecSA（各种参数）】 快速：3消息。可以协商多个SA，双向双方通信需要8个SA，两边各四个（出入*AHorESP） 协商加密和哈希的算法，验证方法，DHkey，周期和密钥长度等 1：Hash SA ProposalTrans KeyEx Nonce ID… 2：Hash SA ProposalTrans KeyEx Nonce ID… 3：Hash 很像上面的3步快速 IKE的三个工作模式传输端到端节点，均实现IPsec，那么传输模式 隧道网关间用隧道，端不需要IPsec 嵌套端到网关：隧道套着传输模式 IKE工作过程守护进程在后台，被内核或对方IKE唤醒 内核可以指示IKE删除某个SA，此时IKE也会通知对面IKE删除or忽略 总结IKE 层次相当高，位于应用层，用udp500走 不足： 太复杂 只用于Ipsec的建立SA 往返太多，消耗资源 容易被攻击：拒绝、中间人、重放 lect8 SSL相比Ipsec好处，Ipsec在网络层对所有传输都会使用。但是SSL可以选择，有差别的为应用层提供服务 介绍SSL在TCP之上，保护任何TCP上的应用。 IPsec无法处理同端系统中不同应用的安全需求，为两个应用之间提供保密和安全。 SSH强制认证+数据加密也在此，还有SP4和TLSP SSL 安全套阶层安全机制，保护基于WEB 用于CS的身份认证（证书与第三方），消息认证和数据保密 在应用层协议传输之前， SSL协议已经完成了客户端和服务器的身份认证、加密算法和密钥的协商；在此之后，双方建立起了一条安全可信的通信信道，应用层协议所传送的所有数据都会被加密，从而保证了安全 使用案例接受时候相反 SSL体系结构 会话Session，通过握手关联CS，虚拟的连接关系。握手商量xxx 连接Connection：特定信道映射到一个TCP连接，共享一个会话中协商好的信息。连接参数： SSL记录协议主要：保密+完整性 过程：分片（2^14)——压缩后追加HashMAC——对称加密——加上SSL记录协议头——TCP——解密——解压缩（拼接） SSL记录协议头：(内容类型，主次版本，压缩长度） SSL握手协议主要：身份认证（先认证S，C可以不认证），协商算法，协商会话密钥 报文结构 1B类型 3B长度 1+B参数内容 分四个阶段完成握手 建立安全能力 Chello ver,random,sessionid, cipher_suite(KEmethod, hash&amp;encoder), compression Shello same as top 服务端身份认证和密钥交换（可以失败 certificate X.509v3 匿名DH可能不需要） SKE （DH RSA需要交换密钥） certifica_req 需要客户的certi S_hello_done 客户端身份认证和密钥交换 certificate 可选，也可能没有 CKE DH RSA需要交换密钥 certifica_verify 签名此消息 用于配合Certi让服务器验证客户端的数字证书所有权 完成阶段 change_cipher_spec 把pre转化成主密钥，派生出所有密钥 finished change_cipher_spec 你算完我也算完了， finished master secret主密钥，用于生成一堆密钥 CS双方的MAC密钥，加密密钥和MAC初值向量IV SSL告警两个字节 1告警 2致命错误：终止连接但不终止会话，不再会话中建立新连接 包含告警信息的代码 SSL 修改密码协议一个字节 “1”，握手结束后发送，以后记录用刚才的算法和密钥来加密认证。 接收方把挂起会话恢复到当前状态 安全分析 应用层WEB和安全威胁网页服务器与浏览编辑器WWW——HTML、HTTP、URL 特点： 双向互联网 服务器容易受到攻击 金钱和信息丰富且重要 服务器存储安全（用户认证，访问控制，日志） 客户端安全（服务器认证，访问控制和签名） 信息传输安全（IPsec+SSLTLS+MIMEPGPSET） IP级、TCP级和应用级安全 HTTP攻击举例HTTP：主要是规定浏览器和WWW服务器通信规则，裸奔html，当时是信息没有财富 明文传输，不检查完整性 + 无状态，不验证身份——监听明文，篡改劫持，伪造服务器钓鱼 中间人加入并分别建立和通讯双方的连接，可以被随便改——ARP欺骗 ARP协议数据链路层，维护IPMAC映射表 可以伪造ARP frame改变网内任何主机的映射表，来切断通讯并且把自己的物理MAC加入。即发对方以为就是发攻击者 DNS 域名——IP对应 欺骗：所有主机名都对应攻击者的IP HTTPS = HTTP + SSL明文——加密（记录协议加密） 80端口到443端口 无状态连接——用SSL+HTTP协议加密和身份认证的连接 SSL能否保证安全ARP和嗅探都可行，但是看不懂的密文 篡改：密文无法篡改，也看不懂 https有小锁，显示发放的证书来认证服务器身份。如果钓鱼或者恶意代理，没有受信任的证书（钓鱼wifi），有危险 攻击者用自己证书替换服务器证书:没办法，开摆，明文了 会话劫持 偷不到用户密码，但是登陆之后跳转到HTTP页面可以偷取Cookie来冒充用户 SET安全电子交易定制给电子商务安全 涉及到多方：客户、商家、银行、相关管理认证部门 威胁 支付账号密码的窃取 金额更改 商家和支付方的互相确认 双方的抵赖，否认 故意延迟 需求 所有数据的保密性和完整性。银行不应该知道我买的东西，京东不应该知道银行的余额。我买的什么，多少钱就是多少 结算双方身份的认定，唯一确定的身份 不抵赖和否认 可靠快捷 体系结构：社会——管理——技术——应用 SET安全电子交易visa和master card搞的，基于X.509v3证书。私密保密+完整+双方认证+抗抵赖 下半部分是中国银联，属于银行网络系统了。 支付网关：由收款行操作，处理商家的支付报文，属于SET和银行支付网络的接口 收款行去找对应的发卡行协商请求支付 order info 和 payment info 背靠背，互相不可见。必须分开加密和签名，但是又不能分开发不然难以确认。 对不能读信息的一方，只给MD作为验证，但是原文无法解密 双方开户并获得资质证书 【1购买请求】用户向商家发起购买请求 发起请求：ID和卡信息 发起响应：商家私钥，交互ID，整数 购买请求：验证证书， 生成PIOI，把transactionID放入PIOI，然后生成购买请求 商家需要对OI做屏蔽（加密）放入支付网关（收款行） 双签名，两层哈希。连接发送给不同接受者的报文 购买响应 商家收到购买请求，验证订单 【2支付授权】商家通过支付网关，向发卡方请求支付授权 授权请求 PI 双签名 Es 双方证书 银行要验证所有证书来核验双方身份 解密数字信封获得Es，解密authorization block 验证商家前ing 解密payment block数字信封，解密PI 验证双签名 验证transaction ID和PI 从发卡行申请支付 授权响应 授权信息和权标 证书 【3支付获取】商家通过支付网关，向发卡方请求付款 获取请求 支付量，交易ID，权标，商家的签名密钥、证书 获取响应 网关签名，加密获取数据块，网关签名证书","link":"/2022/12/07/2022Fall-netsecintro-final/"},{"title":"2022秋季学期 计算机组成原理 期末复习笔记","text":"计组复习笔记12 InstructionsPC 需要执行的指令，下一条指令程序最小单元：指令，也是计算机硬件执行程序的最小单位全部指令构成指令系统 层次软件系统：高级、汇编、OS、指令系统硬件系统：指令系统、微体系结构、数字逻辑指令系统是软硬件接口 功能分类运算、传输、控制、IO、其他操作码和操作数地址，指令字：二进制表示指令字长：每条指令是x倍机器字长机器字长：计算机能处理的二进制数据位可变长的指令字结构和扩展操作码… 寻址指令中的地址叫形式地址，使用形式地址信息计算or读到的数值才是实际数据（或指令）的实际地址Regor累加器编号 IO设备端口地址 储存器单元地址 性能评定 吞吐率：单位时间完成任务数量 响应时间：完成任务时间 MIPS 每秒几百万条指令处理能力 CPI 每条指令几个周期 CPUTime？ CPUclock？ 测试程序 CRCisc 可变长Risc 等长指令（除了压缩instr） 并行好编译效率高VLIW 超长指令字 组合简短等长的精简指令成超长指令，每次运行一个超长而并发执行多个短指令 最好让reg位置保持不变位置相同 RR的opcode固定 规整计算结果到rd，PC增加 Iimm12符号扩展32位，-2048 2047 移位中imm只有后五位有效位shamt，前七位为0 逻辑移动补0，算数右移补符号位 JALR 符号扩展12到32，把pc+4存到rd，跳rs1+-imml31:1,0 ，相当于先扩展相加后把最低位置0. 跳转范围rs1+-4KB，结合AUIPC可以任意跳了 LB LW 符号扩展后的imml+rs1的位置取字或字节 Srs2存到rs1+符号扩展imm上，此处imm被打散 B比较rs1 rs2，符号扩展~imm12,0其实是imm12:0 ，与PC相加，pc±2^12=4K(B) -4096 4094的2B对齐偏移 如果超过了可以b的条件反转，然后bnxt，jjump J打散的imm20因为其实是20:1后面默认0位为0，JAL 符号扩展，存pc+4到rd然后和pc相加低位置0后跳+-1MB U imm除了U之外都要符号扩展不打散的imm20，lui直接装 auipc：装入高20位后加上pc MMIO通过把IO映射到内存单元，对特殊地址读写就是读写外设。通过外设寄存器和主机交互，表现为内存单元或者端口上的数据读写单元 13 数字逻辑解码器|译码器 2-4,3-8… 选择器，控制信号和数据与后接入或门 比较器：或许是异或+与门 3LUT查找表，实现任何3位逻辑函数，就是根据abc8种情况查找定制的输出 摩尔状态机：输出之和现在状态有关，延迟一拍 米利状态机：输出和现态和输入都有关，快，异步反馈问题 同步电路：全局时钟，有利于静态时序分析，强耦合。不利于面积和低功耗优化，时钟偏斜（和时钟距离不同） 异步电路：多个时钟，不同源or同源不同相，难以静态时序分析，但是更灵活，功耗低 14 ALU寄存器堆——ALU——回到寄存器堆 全加器 1位ALU 4位ALU？真值表组合逻辑or串4个1位 超前进位？特殊进位电路来同时得到计算结果和进位C1234 标志位：ZF SF最高位 OV=¬F1*¬F2*S+F1*F2*¬S溢出@@ 补码减法b的补码取反加一为-b直接加即可 原码乘法高精度（竖式），即移位加。 维护部分积，先从乘数最高位开始，1就加0不动。处理完一位就左移部分积直到处理完乘数 或者： 很可能溢出，怎么办？ 1直接实现：64位被乘数，64位ALU，64位部分积，32位乘数… 浪费空间，每次加法只有一半生效 2 32位被乘数和ALU，64位部分积 其实64位被乘数（不断左移）就是为了对应落在部分积的正确位置。换思路让部分积右移，即alu只往部分积高32位加，加后右移即可 发现部分积在不断右移，而乘数右移之后左边没用，故合并.. 补码乘法？1 补码换原码绝对值，乘法，单独算符号位 2 布斯算法 原理推导 其实就是在标准的部分积-乘数寄存器后追加一位初始0，然后开始看最后一位和附加位。10减01加，右移固定长度后计算完毕（把所有除数出去就完事） 除法异或符号，绝对值做除法 恢复余数法：经典的竖式，被除数减除数后，大于等于零商1，移位。小于零则商0，恢复余数后移位。从来不用。 一般用负余数向下求加减交替法 原理证明： 操作方法？ 原码：首轮尝试 -Y，后面看正负。正商1-Y 负商0加Y。最后修正符号。记得余数要乘上2^-n的系数 补码：首轮根据符号同异。同减，后与除数同号商1减 异号商0加。 如果最后余数为负轮次，加Y修正之 最后 15 实验预备和Verilog FPGA 现场可编程门阵列，以LUT 触发器等为基本单元 LUT本质就是RAM，计算所有结果之后按地址查表输出 面积 和 速度的平衡和互换 现在的FPGA都是为同步电路设计优化的，但从IC设计看同步更加耗资源，没有毛刺信号稳定。 综合后仿真可以标注标准延时文件，估计门延时等等；时序仿真更靠后 Verilog 门级描述（结构）和行为描述 Z不是0不是1，如果进与门则有0为0，其余为X 仿真时#x表示延时xns 1ns/1ps下 代码时间单位/仿真粒度 异步复位：采样独立于时钟，优先权最高，但对毛刺敏感有亚稳态问题 同步复位：相对于时钟，应该有足够长激活时间以在时钟边缘采样到rst 16数据表示和纠错逻辑数据 01字符数据ascii 128 Unicode 16b保留6400个码本地化使用 UTF8变长编码，首字节确定字符长度，开头为几个1和一个0代表字节数。0为单字节，几个1加0是几个字节。后面字节都以10开头，方便自同步。 点阵字体，通过10来绘制汉字；矢量字体，通过平滑曲线连接关键点，填充闭合空间来显示字符 数值数据定点数与浮点数 原 反 补正数相同 0有两个原码和反码 反码为原码取反，补码为反码加一 只有一个负数的原码和补码是相同的即1100 -4 = -8+4 浮点数s exp frac: 1 3 4 or 1 8 23 or 1 11 52 bias = 2^(exp-1) -1 bias：3 127 1023 特殊情况： exp=0 不取-3仍-2，但是0.frac，有正负0 exp=全1且frac=0 表示无穷大，frac其他NAN exp 非0且非全1: 规格化数 正常处理 1.frac exp-bias 浮点算数 特点：不可结合，相等比较只是近似的。比如for中i!=10的条件，递增0.1可能不会停止 检错纠错奇偶校验并行数据传输，k后加1位。使得k+1取1的位数为偶or为奇数 即奇校验的校验位为是否为偶数个1，or偶个1出错为1， 把校验位写前面？ 全部异或——偶校验 码距2 少用一个维度的合法码可以使码距为2，可以得到检错码。 海明码发现并改正一位错：2^r &gt;= k+r+1, 全正确和k+r的某一位出错的情况 实用，也能发现两位错：r中一位来表示1位还是2位错，剩下来指示出错2^r-1 &gt;=k+r 3-4海明码，垃圾。 在正常海明码后面加一个校验位P4为所有其他位的异或。 校验位和对应数据位异或应该全是0为无措，否则找为1的 全校验位为1则一位错，为0有两位错 21 控制器 指令系统操作数x操作数指令（x地址指令） 来源去向：寄存器堆、IO设备或接口的寄存器，主存单元 操作码扩展，可以用1占位用0开始，参考utf8的方案即1110后面是可变 也可以自己设计，从操作数最多的指令开始即可 从多地址到少地址 操作数类型和寻址 指令中包含imm 给出mem地址 寄存器寻址（reg中是实际数据）和间接寻址（寄存器中是内存地址） 变址寻址：变址寄存器值+偏移量 相对寻址：相对于PC和偏移量 间接寻址：指令给出**data 访存两次 基地址寻址：基地址专用寄存器如fp，+偏移量 堆栈寻址：处理sp，加减和读写fp 22 Riscv指令系统算数与逻辑运算、移位操作、数据传送、IO、转移、子程序调用返回、堆栈、其他（条件码、中断、停机、nop、特权） 推荐不强制对齐，小端高对高，高——低 完整64位multi：mulh[[s]u] rdh, rs1, rs2; mul rdl, rs1, rs2 div rem lw sw中addr+off需要按4B对齐 lb会符号扩展！half是2B指令2B对齐，如果u做0扩展 callee：sp fp\\s0 s1-11，函数如果需要，则需要保存下原来值，最后再恢复 caller：ra，t0-t6，a0a1 a2-a7，被调用可以自由用，即func内需要的话随便用 23 指令格式和数据通路 24 单周期cpu指令周期 执行一条指令的时间，有cpi即每个指令需要几个cpu周期 cpu周期 clk时间，甚至可以再分为节拍 cpi=1的单周期，五个步骤挤在一个cpu周期内。各个控制信号在整个指令周期不变 古早技术，利用率低，不实用 考虑：数据通路、控制信号、执行时序 组成部件利用率不高，消耗在维持信号上 时钟周期满足执行时间最长的指令如load比store多wb，以load限制最长周期 25 多周期cpu指令占用自己的步骤数，每个步骤占一个周期，尽量限制单一部件，仅提供当前步骤的控制信号 需要：保存好下一步骤的值——引入寄存器 转到下一步骤——引入状态标记，使用状态机 控制器组成PC IR 指令执行步骤标记：每条指令的步骤和次序 控制信号产生：根据当前状态产生控制信号 硬连线组合逻辑控制器 指令和执行步骤产生控制信号 PC IR 节拍发生Timer 控制信号产生部件，条件包括条件码等 微程序 存储控制信号，依据步骤读出要用的组合 微地址访问读出，指令操作码得到首条微指令地址，然后微指令给出下一步骤地址 读指令 PC地址读到IR load C addr 保存到DR wb的wdata来自C DR或者PC AB寄存器其实是mux后的alua和alub，C暂存最终ALU结构 A的来源：rs1 pc pc_now（用来+4） B：rs2 4 IRimm IR和DR都是读出来的内存数据，C给地址保存到DR，B给数据写入C的地址。 步骤划分 取指可1拍，之后： B型指令：读寄存器堆(RF)、ALU运算(EXE)，可2步完成， R\\J\\U\\I和S型指令：读寄存器堆(RF) 、ALU运算(EXE)和结果写回(WB), 可3步完成， Load指令读内存指令：读寄存器堆(RF) 、ALU算地址(EXE)、读内存数据到DataR(MEM)，把DdataR内容写入寄存器堆(RF), 可4步完成。 26 流水线cpu连接图（1d链表）和时空图（xy表示时间-阶段） 最慢流水段限制时钟周期，必须是连续任务 装入时间第一个任务进入流水线到输出流水线 排空 最后一个任务进入到输出 部件功能级（浮点运算）、处理机级、处理机间级 吞吐率：ips？ 加速比：与串行时的速度比 “每条指令至多需要5个周期” 27-28 流水hazards结构冲突硬件资源冲突——stallor增加资源 1 寄存器同时读写——2R1W独立端口OK or 双沿访问，下降沿写入 后半周期读出FPGA不可 2 内存冲突 IF和MEM——stallall or 区分i和d的内存 or 让mem的指令先走，插入mem气泡，stall住前面指令 数据冲突数据依赖关系的冲突 RAW 写后读。后三条收到影响 后两条需要数据前传（exe已经可用，传给后两条的ID） or 插入两个bub。 后面第三条可以双边访问或者寄存器堆中特殊处理 数据旁路：给rs1 rs2的mux再加两个源头，来自aluy和dmload，其实是前传给了EXE 装入使用冲突 但不可MEM刚装入就前传给EXE，需要等待load。建议插入一个气泡nop。即先把mem放过去，在mem插入bub然后再… 建议汇编直接在load delay slot里面放一条无关指令——汇编器调换顺序，静态调度 或者硬件动态调整顺序，动态调度避免暂停。指令顺序发射——乱序执行——乱序流出。容易不精确的异常 条件 EXE和MEM的rd == ID的rs且不是zero WAW 在 riscv不发生，只有wb才写所以…如果alu算完直接在MEM写，那就冲突 WAR riscv不发生，因为写远在读之后，后面的指令先写前面指令再读，不可能 控制冲突分支、跳转类型指令改PC造成控制冲突——全局冲突 暂停流水：发现分支类就暂停后面指令进入，直到MEM产生正确pc，下一周期才IF 希望尽早判断是否转移and转移PC3 提前分支：在ID阶段加入加法器比较器完成转移地址计算，即把IF清空为nop然后下一阶段ID nop IF 跳转后的instr 分支预测：预测转移失败or成功，如果预测错误要消除影响。 BTB：分支目标缓冲，分支转移成功的指令地址和目标分支地址都保存起来，缓冲区以分支指令地址作为标志。在IF阶段，指令地址和保存标志比较，如果相同认为是分支指令且认为其转移成功。 相当于新的PC保存其下一条指令的地址，利用局部性 两位预测适用多重循环，连续两次错误改变预测方向 异常中断cpu内部异常 外部中断 cpu对程序透明地检测和转移。保存现场、转到恢复程序、恢复现场 多周期可以增加一个检测异常是否发生的步骤。 流水线需要看是哪一步发生了异常 精确（RV）：mepc保存发生异常地址，OS简单，流水复杂 非精确：mepc保存近似pc，os处理 28 expception MMUM简单嵌入——MU安全嵌入——MUS操作系统 用CSRRW同时读写 机器模式最重要的特性是拦截和处理异常 异步中断，mcause最高位为1（一般是软件、计时器超时、外设），同步异常（包括环境调用 缺页等等）为0.mpp设置为u然后mret则从m到u，结束异常处理。 同步：ecall 进入高一层中断处理 ebreak故意触发断点异常 mepc 对于同步异常，mepc指向导致异常的指令；对于中断它指向中断处理后应该恢复执行的位置。 mtvec 异常跳转到的地址向量表。mode0表示跳base，mode1表示跳到base+4*mcause mie 中断的使能 ，有的必须忽略 mip 正准备处理的中断 其中有 MSU e&gt;s&gt;t外部事件软件 E和P 只有U和S的pending可以地址写？？？向低优先级注入中断的手段。挂起中断的清除。 mtval trap value trap的附加信息比如出错地址，异常指令 mscratch 机器存放一个字数据 mstatus 机器状态：包括中断全局使能MIE，异常后的中断开关MPIE（保存中断前的旧值），MS响应中断特权级… 中断处理 设置mepc 根据mtvec设置pc 保存mcause和mtval mstatus保存mpie并mie置0.保存之前权限到mpp并权限改为M 抢占异常处理 处理中打断，转到更高优先级中断，需要保存m系寄存器到栈。在退出前，禁用中断，恢复寄存器 wfi 没有工作，低功耗待机等待中断。停止时钟ornop，适用于循环。 PMP物理内存保护 实现pmpaddr_x和pmpcfg，[i, i+1)的地址查找pmpi+1配置获取权限。M指定U访问的内存 Supervisor 不能用csr指令受到PMP限制，默认异常交给M但是M可以导向S。rv提供异常委托，选择把部分中断和同步异常交给S绕开M mideleg和medeleg寄存器委托给s处理的中断、异常，每一位对应一种异常。sie和sip只有被委托的位才能使用。 页式虚拟内存SV32 VA 10 10 12 PA 12 10 12 PTE 12 10 2 8 satp mode asid ppn22 在OS设置好页表后被启用 PTE低位：VRWX 用户可否U 所有地址空间有效G 访问过A 修改过D satp.ppn, va.ppn0, 00 ==&gt; pte0 pte0.ppn, va.ppn1, 00 ==&gt; pte1 pte1.ppn, va.ppo ==&gt; page entry 31 Dramlu半导体存储器 mos寄生电容+触发器 属于ram 随机访问RAM 顺序访问磁带SAM 直接访问DAM随机+顺序，如磁盘 CAM关联访问，cache 需要：快、大、贱、可靠——层次储存 局部性 时间重复，空间重复，顺序上 一致性和包含性 不同层级的信息一致，外层包含内层 sram 不需刷新 触发器储存 同时送行列地址 热 IO共用管脚 dram 动态 需要刷新（漏电，补充电荷刷新。暂停读写集中刷新或者定时周期性分散刷新） 电容MOS存储 破坏性读出（需要马上写回叫做预充电延迟，影响频率）快速分页组织，行列地址两次给出，行地址可以锁存复用 两次操作 有个row buffer，所以hit row之后只需要col来读出 读写 读：地址；片选和读；保存内容 写：地址；片选和数据；写命令 Dram子系统组成 倒三角 channel DIMM RANK chip bank row/col——双通道，DIMM是一条分为前后两个rank01，rank里8chip，chip里面一堆层叠bank。bank大概是16krow 2kcol 每个unit1B 数据总线 clock*总线宽度就是数据吞吐能力 ddr带宽16B？100Mhz 200MT/s 1.6GBps 控制总线可以用不同的总线周期来区分部件，和操作性质，还有DMA周期等等 写时序 32 33 Sram&amp;Cache 时间局部性：最近被访问的信息，空间：最近访问信息附近的信息，都装到cache里 Cache参数line块 数据交换粒度单位 4~128B hit 时间：访问高层次数据时间 1~4Cycle miss 损失：替换高层数据块+交付cpu时间 命中率八成到99 容量1 256KB 映射方式全相连（无序）标志位是主存有2^m块就m位。所有表项都有单独的比较电路。即需要一个全长的tag，没有idx。 相当于主存中的一块可以映射到Cache的任何地方，即把全部地址作为索引，所有都需要比较器比较。最后选择器选择。 评价：灵活，命中率很高但是电路过于复杂 替换时：不确定换出哪块，需要判断 tag+line offset 直接映射——唯一对应位置按indexO1的索引到，组内使用tag来比较器判断。 评价：每一块都有有直接的字块对应，方式直接，利用率低。标志位短，比较成本低，tag需要addr-cacheidx且仅比较一次。 但是利用率低，命中率低，效率低。 把主存地址中提取部分作为块号，部分为块内地址 n路组相连映射主存中的一块映射到Cache中的N个位置。先索引组，然后里面找tag进行比较，如果相等则命中。组内直接映射 n个比较器和一个n选1数据选择器 替换时：不确定换出哪块，需要判断 n路多，命中率高冲突少，但是复杂，越来越接近全相连了 二路一半容量和直接映射的命中率差不多 一致性保证 Write Through写直达：cache命中后写mem和cache。不命中写mem时候可以同时allo cache 强一致性，低效 Write Back 拖后写 只写cache，被替换时候dirty（主动被动，需要监听总线的操作）时才写给mem保存 适于多写 实现复杂但是效率高 miss原因 必然缺失——预取 无法避免 开机、切换进程、首次访问 容量缺失——扩容 活动数据集超过Cache 冲突缺失——增加路数or容量or更改策略 多个映射到一起，需要腾挪 某一个组块满了，其他组有空闲，就不叫容量 无效缺失 cache数据不对，其他进程修改了主存，监听到并Valid=0 提升命中率 大块 可以更好利用空间局部性，但是装入慢miss惩罚太高。且块太少容易miss，有极值最优点。 块过大影响时间局部性 多级cache提高命中率；分成I和Dcache分别选择； Cache接入 连入总线 简单 便宜 占用总线 单独连接cpu 提高总线效率和并发操作 成本高 结构复杂 一致性状态策略MESI 多个核心之间有本地cache，其他核cache和内存数据 修改：本地写 无效：远程写 共享：远程读 or 远程有副本的本地读 独占：远程无副本的本地读 替换策略FIFO 简单，满足时间局部 LRU 最近最少使用：复杂，满足程序局部性，命中率高 RAND 简单，命中率不低 34 VM解决问题：程序数据量大于物理内存；多个程序共享； 共享和保护：多个进程可能使用相同的VP访问相同（共享库）或者不同的物理页。可以限制不同进程的权限。 页表大小的选择：层次页表|翻转页表，访问频繁所以要实现简单 页表可能给出内存or硬盘位置0 null代表没有被分配 0 硬盘位置代表这部分的数据存在硬盘中，cpu选择空页或者牺牲页（被换出主存前如果被修改过，则写到硬盘中）然后从磁盘里把这部分拷贝到页面同时标注页表valid1 TLBsfencevma 通知cpu页表可能已经被更改 rs1虚拟地址 rs2进程ASID TLB缺失 暂停流水线，通知OS？，读页表，TLB更新，返回user，重新访问就hit了——多路组相连and扩容 缺页全流程 触发缺页异常，硬件设置好CSR后交由对应OShandler。（主存已满时，OS选择替换页，如果dirty则CPU请求把该页内容写入硬盘）CPU请求硬盘读入对应页到内存对应页，更新页表项。同时CPU硬件上更新对应TLB，返回到mepc地址，此时再次尝试时TLB已经命中。 读写硬盘过程：cpu唤醒IO硬件，硬盘通过IO触发完成中断。 页面大小选择小页：减少内部碎片，需要更大页表 趋势：增大页面——RAM便宜内存大，内外存差别大，程序员需要大空间 页面替换：LRU，最多使用到最少使用排序。访问页帧移到表头，替换时替表尾部。替换非dirty 段式存储管理VA： 段号（可以有两位表示优先级）+段内地址，每个段segment按逻辑关系分配长度，不定长，在段表中规定。 逻辑段共享，按照需求划分，页表方便管理。段表没有内部碎片，页表没有外部碎片 STE：段号 段长 段地址，段号和段内地址都有可能越界 段页式存储 先分段 再分页：段号 也号 页内偏移 35 外存|辅存非易失性存储，粒度大，以数据块为单位 随机访问vs串行访问。各自or共用读写设备（顺序and直接） 磁记录方式 RZ归零正负脉冲10，中间0 NRZ一直正负脉冲 NRZ1见到1翻转 PM相调制中间上0下1 FM调频，1的中心翻转 0不翻转 位位间都翻转 MFM两个及以上0位周期起始翻转 磁盘旋转托盘磁颗粒储存，移动读写头来访问。 相比软盘面积大 密度大 转速快 盘片可组合 访问过程 寻道（读写头移动8-20ms） 旋转寻找扇区（等待磁盘旋转到扇区） 数据传输（多个扇区）1kB扇区是最小访问单位——外磁道可以比内多一些扇区 时间 寻道+旋转+传输+控制延迟 额外开销大，尽量一次多传相邻扇区，或并行 小扇区：损坏代价；检错效率；灵活适应OS页面 访问磁盘过程 由缺页引起之后： OS选择一页换出，查看是否为脏页 dirty页需要写回磁盘 OS申请IO总线 获得批准后发送写命令给IO设备，传送写数据 IO控制器根据命令握手协议，接受数据 根据地址移动到正确柱面、加载数据进buffer 寻道到正确磁道，旋转到扇区开始写入并不断计算校验码 继续申请读入所需页 申请总线 发送读命令和地址等 IO接受，寻道，移动读写头 读数据并校验 磁盘申请总线 授权后送回数据 可用 能正常使用的几率——增加冗余如校验码 可靠 故障几率——改善环境，减少复杂 RAIDraid0 模拟虚拟磁盘划成带strip，每个strip有k扇区。相当于0123往下数数，适于大量数据请求，没有冗余和可靠性。 raid1 单纯四块主盘四块备份盘，写性能低，读性能两倍。成本高，可恢复。 raid2 4位半字节用海明码成7位字，124校验。然后磁头旋转同步写在七块盘上。需要多个控制器。严格同步 raid3 简化，对每个（半）字校验放在校验盘上，严格同步。用奇偶校验，能够修复单个磁盘bit1 bit2 b3 b4 Parity。瓶颈在校验盘，无论写谁都要算写校验盘 raid4 从bit到strip，生成异或的校验带。不需要同步，防止单盘崩溃但是字节纠错能力差。校验盘负载过重 raid5 分布校验带，控制和修复更复杂。从右到左分别当校验盘。 raid6 仍然分散校验带，但二维校验，3个数据2个校验位可以修复两个磁盘错。或者4-2异或斜向校验等等 SSD不用动 安静 低功耗 高性能 抗震 擦除有限 固态电子存储芯片阵列——控制+存储（FLASH DRAM） 格雷码编码，内部也是个小计算机。 package-Die-Plane-Block-Page,最小读写单位。读写在4k-16k us延迟 擦除可以到block ms延迟 FTL层负责翻译地址，维护磨损均衡。写入同一地址不会在原来的page，跨很多。原来invalid，写入前擦除。 垃圾收集：把die block中有用的数据拷出来，然后整体翻新成free 41 IO程序直接控制 cpu主动去轮询查uart串口，在程序里通过特定指令（mmio或专用）来轮询状态并等待——接受or发送——处理 低成本 低效率 cpu资源阻塞占用 适用于早期计算机的中高速设备 程序中断 设备自己报告完整过程 外部设备中断请求：设置中断触发器。每个中断源有1个中断触发器，也对应1个中断屏蔽触发器 中断响应： 条件：允许+当前指令结束（对多周期）；优先级满足 过程：关闭pending中断；硬件的中断隐含指令，相当于在每个WB后看看有无中断，保存断点 根据中断源转到软件中断handler 关中断，保存现场上下文，各种regs，转handler 开中断；运行对应中断处理；关中断； 恢复断点现场 开中断；返回断点 可能分别有响应优先级和服务优先级。即响应中断的优先级低但是服务进行的时候屏蔽很多中断，不可以被打断 中断接口硬件实现 中断请求和屏蔽寄存器 优先级排队线路 数据缓冲寄存器 中断控制和工作状态逻辑 设备选择器 中断向量表：服务程序的入口地址 相关概念 中断触发器和状态寄存器 中断优先级——响应顺序 禁止和屏蔽（允许触发器EIDI 选择封锁） 评价和适用提高效率，可以同时管理多个设备；传输速度不高量不大；对CPU干扰大。因为数据都需要cpu经手传输，比如什么中断服务程序。 硬件故障；cpu和外设并行工作；实时处理；app和os；多处理机的机间联系；多道和分时 怎么能不让cpu来做？尤其在页式交换？ DMA直接存储访问IO设备和主存的直接数据通路，专设硬件。传输过程DMA自己控制，需要主存支持 成组传送（burst）。开始和结束时需要程序or中断来预处理和后处理 仍然是通过bus传送，怎么协调？工作方式：独占总线（等我传完）or周期窃取（每次传输后释放，一起竞争总线） 使用与连续地址的大数据量传输，解放CPU io可能通过中断向cpu发出请求表示数据准备好，cpu告诉dma任务信息（硬盘、地址adr、主存地址mar、数据量word count，dbr数据缓冲，csr状态寄存器等等）。 dma卡自己请求总线完成任务，然后告诉cpu传输完（申请中断），cpu再去处理这些数据。 工作过程 CPU预处理：启动并给任务信息 将内存起始地址，设备地址，数据个数等送到DMA启动设备 数据传送 cpu继续执行主程序，dma控制同时完成数据传送 申请总线直到允许，地址送到总线，数据送IO；主存地址+1，WC内容-1. 传完了 中断服务程序进行DMA结束处理 评价DMA需要连续的物理地址，但是cpu拿的是VA，其物理地址不一定连续。cpu的VA需要DMA虚实转换，需要访问tlb，产生冲突。 Cache一致性、包含性？层次问题： 主存数据并不一定最新，可能在cache中 主存更新后的cache失效，如果还要管cache性能低 DMA与设备是一对一的，多设备需要多个DMA，同时工作可能会冲突。 对CPU打扰适中，初始化和周期挪用，无法适用大量高速设备 通道控制方式——1个DMA集成管理多个设备通道命令IO处理机，有自己的命令，一对多，适应不同种类的和不同速度，其实是专用cpu。 指定连入外设，操作外设；传入外设IO的位置以及主存缓冲区地址；控制外设和主存交换数据；检查外设状态； 字节多路通道 简单共享、分时处理，低中速字符设备 选择通道 选择外设独占整个通道，成组传输数据块，效率高的快速设备 数组多路通道 结合前两种。复杂控制但高效 外围处理机通道型处理机：共享内存 外围处理机：独立IO，帮助大型机专心计算 总评价性能、可扩展、可适应（设备有无、故障） 考虑驱动、依赖等等，尽量使用抽象统一标准，虚拟化管理 42 BUS概念cpu和其他部分的接口 性能：延迟、吞吐量、设备和系统的连接关系、层次存储、OS 好处 复杂外设：使用统一总线标准，便于扩展和兼容 降低成本，可以多个设备共享 设计简单 不足 总线带宽限制吞吐量 最高速度决定因素： 总线长度 负载设备数 负载设备特性：延迟差异、数据传输速率差异 单总线设计：主板总线处理器和mem和io都连接，简单低成本，但是速度太慢，成为系统瓶颈 双总线：处理器主存总线和IO总线麦金塔II 两极总线，设备并不直接连接到处理器主存总线上，通过总线适配器引出单独的IO总线。 三总线：处理器主存、主板总线、IO总线三级总线，mem-PCI-usb、ethernet、disk 大大减少处理器主存总线负载， 现代PC采用北桥接入高速设备，南桥接入低速设备。但是现在北桥基本都被继承进cpu直接接高速设备 总线类型处理器主存，专用短、高速、专用于主存直连处理器、针对cache块优化设计 IO 行业标准长慢，适应性好、通过桥or主板总线连接主存总线 主板总线 高速设备允许处理器、主存和IO设备互连，所有组件都连接在这条总线上 有价格优势？ 总线构成控制线：总线请求和数据接受信号；指明数据线的信息类型 数据线：传送信息，数据和地址，复杂命令 总线标准非常多，抽象设计，影响性价比可靠性。需要统一、可扩展、兼容、协调控制 PCI；EISA；SCSI；USB；Bluetooth… 总线层次结构 事务协议；时序信号规范；导线；电气信号规范；接口物理机械特性； 总线概念主设备 控制总线，发起总线事务（发起命令和地址+数据传输） 从设备 响应请求 通信协议 定义总线传输中的时间顺序和时序要求 异步同步 控制信号作为总控，适应不同速度，距离长，需要握手 共同时钟在控制线里，逻辑简单高速，但所有设备需要按这个时钟工作；总线需要够短 同步协议最理想 完全同步，所有设备速度一样。req grant 上升沿关闭req G后直接给addr和cmd，很快得到data 典型同步 给出cmd和addr后，wait信号直到数据准备好，wait为0（wb协议）根据时钟信号得有效数据。即从设备指示什么时候开始传送… 同步定时 异步协议沟通通过握手信号解决，主要是ack和rdy。 外设读取主存的过程： 外设req 主存读到地址发出ack 外设释放req和数据 主存关闭ack 主存把数据上bus并datardy 外设读到之后ack 主存关闭rdy 外设关闭ack 总线仲裁要求主设备请求——授权并使用——完成后通知仲裁器释放请求 优先级和公平性 古典简单处理器是唯一主设备，控制所有请求，被卷入每一个总线事务。 集中仲裁——菊链仲裁统一bus arbiter，接入各个设备release request的线或。并不知道谁在req，只要没在占用就grant通过。有绝对的优先级。按照优先级级联grant信号。 每个设备的req和release线或在一起，arbiter不区分。grant授权按照高到低串联一起，高优先级可以截断授权。 无占用就发放grant 不公平，低优先级用不到，授权信号逐级限制速度 集中仲裁——集中平行集中接入所有设备的请求和授权，用于所有处理器主存总线和高速输入输出线 分布仲裁——自我选择、碰撞检测把自己的标识符放在总线上 增加总线带宽增加总线（数据）宽度增加每个周期的传送数据量，成本高 分开设置数据和地址总线同时传送地址、数据，成本高 采用成组传送每个事务传多个data单元，一开始传一个地址，传完所有数据再释放。 复杂度高，延长后续总线请求的等待时间 相当于一个地址之后一组数据而不是一个du 多Master总线提高事务数量 当前事务中仲裁下一事务（仲裁重叠，提前仲裁） 总线占用：没有其他主设备，自己一直占完成多个事务 地址、数据传送重叠 PCI总线外部组件互联总线，33MHz-133MB|66-528，正边沿采样 重叠集中平行仲裁Req#和Gnt# 32位地址和数据线互用AD，分为init和tar frame有效传输信号，地址段在frame开始有效，在授权后开启。第一周期主设备cmd和addr，两个设备准备好对应各自的rdy。均rdy后上升沿开始传送，结束传送时关闭frame devsel#表示target设备已收到命令，可以响应，TRDY接受 T4读到第一个数据，可以改变CBE#的值。 优化？ 类似risc，并行仲裁和传输数据 为上一个主设备保留授权直到其他init 授权设备不需要再次申请仲裁 仲裁时长） 通过rdy延长传输流，tar也可以通过stop abort retry等信号终止，主设备通过FRAME# 仲裁器通过GNT 等对慢速设备，请求后暂时释放总线 PCI其他问题中断、cache一致性(IO multicore)、加锁(分时操作）、可配置地址空间 发展趋势逻辑上是总线，物理上是交换，采用点到点标准 DMA 独占总线：发cpu信号，控制器请求总线并一次性传输，再次通知cpu并释放总线 周期窃取：DMA优先级更高）有dma请求时IO设备随时挪用几个周期来一点点传， 交替访内：cpu周期专门分开，dma和cpu分别访问内存 43 接口和外设接口功能 总线和外部设备的连接识别和选定设备，规定地址码编号； 控制和通信机制； 数据缓冲； 特别需求如屏蔽差异 通用可编程接口电路 内部：识别电路、数据缓冲寄存器；控制、状态寄存器；中断电路；其他 串行接口8251A内（同步符）外（硬件同步信号）同步异步（起始停止位、波特率）均可 5-8bits/word 异步时支持停止位、假启动（0不够长）、全双工独立线、双缓冲发射接受、检错。 空闲保持高电平；波特率因子即传送一个二进制位需要多少个时钟 rst后根据8bit的方式控制字来实现编程，确定工作模式 命令字 正式开始工作的8bit 状态字 实时表示状态的8个bit USB最多127设备，实时，热插拔，同步 根hub定时查询接口，如果有接入则分配地址。设备上有rom保存参数，由os中驱动管理。 只有一个master，轮询，低速 帧类型：控制、SOF包时间同步、块传送、中断；F1读命令addr；F2设备返回data SYN PID payload checksum；ack确认；F3往设备写数据 键盘 按下为0，对应编码，中断工作 显示器 高速设备，真彩色需要3B，专用接口 打印机 激光照射硒鼓放电，不能吸墨粉为空白。慢速总线，并行接口","link":"/2023/02/23/2022Fall-organization-final/"},{"title":"2023年9月记","text":"","link":"/2023/09/03/202305DLTCache/"},{"title":"2023年9月记","text":"9.20 周三9.18 周一9.17 周日9.15 周五昨天承诺了学长今晚就能跑初步的实验数据，所以rush了一天。 9.13 周三下午和晚上把min的代码写了个七七八八。 下午把安全测试答了，找行政老师加上了工位和服务器房间的门禁。在位置旁边贴了个大名牌，算是有点归属感。和之前“暂居”在FIT的感受还是不同的。 晚上取快递、洗衣服、睡半小时、吃水果捞然后洗澡洗头去做同学的试验。实验前半小时“用洗发水洗三遍抓三遍”就离谱。这辈子都没把头洗这么干净过。 戴了个恐怖的大帽子然后一个一个触点抹电极膏，看着电脑上每个点的电阻降低到蓝色阈值以下。抹的过程还是很顺利的，20分钟就全蓝了。一开始的脑电波非常的平稳，“好久没见到这么平稳优质的波形了” 但是上实验任务后，自己都能感觉到心率飙升，波形也变得混乱无章。虽然心态到后面已经很放松，但还是保持了像游戏、考试时候的高度专注。。。被否定了不能用之后只进行了25分钟的第一个试验就被迫终止了。一看头上墨迹得像是打了摩斯和盐粒“层峦叠嶂”，去洗手间用凉水洗头洗得头皮发麻，体验很差。 话说对实验的要求这么高，那得到的结论真的具有普适性吗（）。 9.12 周二上午终于把两个基线之一跑通了，下午也de通了多机多线程预取的版本。开始写min的代码… 本来想在实验室待久一点的，但是千万不能熬夜。周日晚上的债现在还没还清，晚上五点多简直是要昏倒的状态，完全没办法工作，遂回宿舍睡了一个小时。然后在宿舍又干了一会。。。 9.11 周一昨天下午才开始准备的英文答辩，半夜熬到四点去背稿+调框架，还是没跑出来cvy的基本版本，还把作息搞得一团糟。 还是没能一个词一个词的背出答辩稿。不过现场马老师维持的氛围比较轻松，英文讲自己的PPT后用中文问一些无关痛痒的问题，让人的心里比较放松。 靠着PPT的一些提示和胡编乱造应付过去了答辩，竟然只问了“这个项目有投稿规划吗”这一个问题。想来可能是跟我也不太熟，而且我已经把最高频的问题在pre的最后说了出来，即所谓的个人分工。 中午实在是太困了，睡了半小时。没调出来就没什么好交差的，没敢去实验室。。。一直在宿舍疯狂debug 9.8 周五这三天都在从零开始写这个框架，基本把第一种策略的代码写完了。 被座位前的空调吹得脑袋疼，五点多就回宿舍了。 9.6 周三来工位，上周五学长指出了框架很多混乱的问题，遂决定重写。第一天主要是重新想清楚构架，哪部分交由python哪部分放在C++等等。 9.5 周二又是一天的用户实验，这次紧凑了时间之后从10.00做到晚上8.30就解放了，每组50分钟做了10个人。终于和人机交互正式再见了。从大二开始在人机交互实习，标注数据、主持实验的Dirty Work我是再也不想做了。说的难听点就是“我奶奶都能做的工作，我为什么要做？”。遇到的学长学姐都是好人，只是这个方向与人打交道，Dirty&amp;Boring的工作天然就比其他方向多很多。如果不是作为项目Leader的研究生，也不是作为Advisor的“老板级别”那只能沦为打工人。可能最好的路径就是一边打工一边多积累概念，尽早开始自己主导的工作。 9.3 周日又是摸鱼的一天，虽说是摸鱼但是其实一天做了9组用户实验。 人机交互的实验真的是熬人，一天的时间脑子就没有高频运转过，但是人却很累。昨天3点才睡今天9点就要支棱着爬起来，然后从10.00-22.20就全浪费在FIT的会议室里了。 对每个用户说相同的话，做相同的引导，偶尔搭茬让被试不至于因为无聊而损失实验质量。虽然都是些不耗体力和脑力的活计，但就是很耗“精力”，让你没法专心的做某些有难度的事情，只能搞点碎片化的无聊东西。本来周五谢老师说让我好好计划下整体项目的框架周一给他讲，目前看没有一点时间。明天和学长的Weekly Meeting只能摆烂等死了吗？ 自以为NamesInLife是个很有趣的项目，但又担心Po出来会有各种问题。如果每个人都有一张是不是最好的社交网络分析的源数据，或者说如果能有神级的关系建模就直接算出我这一辈子会接触到的人？其实主要担心的还是身边的问题，哪个人该出现没出现之类的。 本来想把后面的实验都交给同组的学长，反正我已经沦落到第四作者了。晚上看到被逼急的学长还是心软了一下，为这种事情吵架不值得，再来做一天实验吧，然后和HCI彻底告别。 9.1 周五8.30 周三本来想复试结束后好好放松歇一天的，虽说是形式居多但是还是战战兢兢地准备了半天，想趁着这天出去玩。然后昨天面试完马上就被谢老师push了进度，只能答应今天立马去接着写。昨天上午刚面试完，中午请来清华玩的同学吃了饭，然后一直肝暑研英文报告到晚上十点，今天睡一上午之后又来东主楼接着卷，这一天天的。 好消息是拥有了自己的工位，虽然可能年底就搬新系馆了，但好歹也代表组里对自己的一种承认吧。有工位也能push着自己多去工作。。。明天拿点东西过来稍微布置一下，这个屏幕素质太低了看着眼镜难受，尺寸又小，但初来乍到也不好意思跟老师要预算要显示器啊。买点笔记本支架以及拓展坞之类的吧，只在不行把宿舍的显示器搬过来（x） 8.29 周二面试，比预想的平淡 上午9.18专面，10.12综面，早早结束整个复试。早上七点起来顺着ppt讲，虽然还是比较摆烂，三分钟打鱼五分钟晒网。 专业面试门前，致理的同学们穿的都是全身正装，略有压力。让我们打45份资料但现场只有十来个老师，这种事情是真浪费啊。果然如先前所料，在科研经历部分扯了一大堆人机交互的概念之后，现场搞系统、体系结构和互联网的导师们都没什么感觉。汪东升老师cue流程的样子好严肃，一点都不像上课嘻嘻哈哈轻松幽默的样子。裴丹老师问了两个不痛不痒的问题，汪老师问了下科研经历和系统的关系。陆老师倒是没有提问。最专业性的问题竟然是座位靠后面一位看起来最年轻的老师（或者博后）提问的，让我具体阐释了一下ppt最后关于手头system项目的答题思路。总体还是非常水的。 综合面试忘了留几份自述，上面的志愿者趁下一位同学的间隙帮我拿了五份出来。综面门口的志愿者竟然是同组同导师的上届学长，实在是很有缘分，临走加了微信。综面早就听说只是探查你读博的心态等综合素质，只是担心我这种哑巴聋子英语者不能流畅地回答英语专业问题。还好1min自我介绍之后只是让朗读了一篇文献摘要，一堆什么convolutional啥啥，AlexNet，GoogleNet和VGG之类的。出声读的时候也没来得及反应文字的意思，不过也没有具体提问，随便糊了两句就过去了。之后就是就着自述问了一些没啥用的问题，比如解释一下里面你擅长的科目，机试怎么样，读博的最大motivation是什么等等。看老师们笑得很放松，我也没有太严肃地组织语言，笑着随便扯两句就混了过去。 中午和高中同学f来清华吃了饭。f高考有些发挥失常，但是看来在大学还是太优秀了。成绩卷到Top之后也拿了浙大的硕士offer和中科院空天所的直博offer，实在是佩服。请她去玉树吃了个饭叙了叙旧，感慨时间飞快。高中我们也没面对面吃过饭，上次往前看能看到f同学的时候还是高中有一段坐前后桌的时期。高中同学们有人保研有人考研，希望大家（包括我）都能顺利上岸。 8.28 周一机试，刺激 T1 看了一眼，有点不敢相信，题面贼简单，瞄了眼数据范围感觉一整个题都是签到？直接撸Python！先搞一个6!的集合然后开始过滤，没想到那个语法也懒得查就写了个dfs来创建情况。然后一行一行过滤就够了。第一遍提交在vertical少了一半情况所以乘二处理发现只有90，改成常规的笨蛋if联立然后ac过了。 T2 看起来并不复杂的模拟，感觉细节也不多。但吸引和排斥棋子复杂度略高，直接Naive写每次操作都O(棋盘)肯定会TLE。想了好几个O(Log(棋盘))的做法，大概全都是维护棋子周围最近的棋子情况，最后决定用C++的std::map写。没想到Lower/UpperBound但是Iter++对于内部有序的红黑树倒也问题不大。写了二十分钟怕调不出来暴零，用二三十分钟撸了个暴力版本过了56分。之后写了俩小时也没调出来，还是工程量不小，应该好好规划更合理的代码结构的。 T3 没怎么看，也没怎么想，估计想了也不怎么会。 最终分数定格在156，感觉应该是“把该拿的签到分都拿了”的合理水平。出考场后一堆有牌子致理大佬互相“卖弱”着说出了自己235到275的成绩，遂自闭。到宿舍发现其实在没有信竞基础的同学中貌似属于合理水平，遂开摆，打游戏&amp;把先前的PPT拿出来准备面试。","link":"/2023/09/03/202309-Diary/"},{"title":"2022纯季学期 数字逻辑电路 期末复习笔记","text":"markdown丢失图片，可直接下载pdf版 Lect02码制8421 BCD 有权 权为8421 后六个数不允许出现表示十进制 一个一个转 5421 有权 5 = 1000 一半以后首位是1 2421 有权 只能表示0-9 一半以后首位是1 4=0100 5=1011 余3 无权 = 8421+0011 相加时注意和减3 进位则加3 为什么？4位才是1个10进制位 直接相加并没有道理 其他有权码甚至不能正确判断相加的进位。余3因为两个余3就是一个6,10+6=16可以进位并且抵消低位的余3 格雷码 无权码 多形式 ：任何相邻的十进制数格雷码仅有1位不同 减少代码变化中电路书瞬间产生的错误，可靠性高 典型格雷不能9回1，修改格雷不从0000开始 格雷码1：除最高位之外中线对称 45 36 27 18 90 典型格雷码：对任意长的二进制数编码（除10进制是对BCD） G=B_i+1 xor Bi 每个位都是自己异或高位 最高位直接拿来用（或者假设虚高位是0） 解码？ 修改格雷码：从余3开始编典型格雷码，为了前后循环 3和12衔接，也可满足中线对称。 字符编码 7位ASCII 教材P13 高3位区分控制字符、数字符号、大写英文、小写 Chap 2 逻辑代数2.1 基本运算公式 n输入的不同逻辑共有多少种？ ​ 相当于对于定义域在所有输入组合上，有多少种不同的函数关系？2^2^n 同或：not（xor） 相同取1，不同为0 AB+!A!B 互补——A与!A 1律 0律 重叠律A A 双非（对合） 交换 结合 分配 不加括号也是&amp;先算，即使在后面也可以&amp;对|分配 自己+自己求反&amp;条件B = 自己+条件B自己+自己&amp;条件B = 自己 反演规则反函数 与或互换；变量求反；01互换即可 得到反函数 对偶规则 与或互换；01互换；得到对偶式 （F’’=F; F=G =&gt; F’ = G’) 2.2 公式法化简——吸收！包含！ 貌似还是用与或去化简然后狄摩根成或与。。 化简不动的时候试试拆分一个假1变成A+!A的形式： 尤其是在很对称工整的形式里面化简，化成不对称不公整但是可以凑一起的形式 Lect 3最小项 n个变量与 从000开始到111排序 三变量0-7 C是最高位 只有一组取值为1剩下都是0 任何逻辑函数表示为唯一一组最小项的或 某个最小项不是在F中就是在F的反函数中，用m_i 来表示 下图0-7 最大项 n个变量或一起，唯一一组为0 从0到7 C最高位 任何F都是最大项之积（与），标准或与 大家与一起必为0 m和M之间是求反的关系 M_i = ! m_i 而sigmami和paiMi为对偶式 按循环码顺序，首尾满足格雷性质，00 01 11 10 110 111 101 100 画图 填数 合并 先大后小，能大就大——多检查上下左右边界 不重不漏 多输出化简：在与或中尽量找公共或项让多个函数共享，容易最简，并不是单个最简 无关项：打X，可以1 Lect4 与非门与外特征3.1 引言输出取决于输入逻辑组合，和过去状态无关，只有关于当前 实际情况：前后沿存在延迟且不相等 集成电路？ 集成度18月翻一番（Moore Law）XXSI 0S\\12 M\\100 L\\10,000 VL \\1,000,000 UL 三维集成延续摩尔定律——功耗太高（电力、热问题、延迟、可靠性 系统功耗是关键因素，低功耗设计环节，优化、封装 3.2 门电路74LSXX元件速查 00 30 74LS139 138 154 LECT5 P37 74LS85 四位比较器 2*4bitAB输入，前面大小等于输入以及后面大小等于输出 76163 标准四位二进制计数器 与非门的封锁 0即封锁为1 与或非门的封锁 1即封锁为0 与或非的数据选择，在两路数据分别与上C和!C即可控制，1为选择端 正逻辑和负逻辑，用1表示高电平为正逻辑 简单二值逻辑 开关：闭合为L 打开H 输出在Vcc一侧 晶体管：截止、放大、饱和、倒置（不用）Lect4 P50 与非门的外部特性 开关特性：扇入（可用输入）、扇出（驱动数）、传输延迟（输入传输到输出的时间，速度和最大传输延迟反比）、功耗 传输延迟：一般参考HL的中间电平来参考时间点，t_PHL t_PLH不同，t_pd=max(t_PHL, t_PLH) 测量延迟时间？一个输入即可，tpd = （tpd1+tpd2）/2n 自激励震荡电路：奇数个非门串联，周期为n*单个总延迟 转移特性：门电路中输出电压随输入电压的变化特性Vin-Vout Vout急剧改变的门槛电压、阈值电压VT 直流参数：0输入电流&lt;=1.6mA 1输出IOH&lt;=400uA Voh&gt;=3V… 一般高电压H的时候要求的电流比较小，在几十几百uA左右 输入电流比输入小上十倍差不多（因为正常负载能力在10） *技术参数：噪音容限 叠加到正常输入的外部噪声电压，不会造成不可预料变化 与非门电路级联 负载计算 计算负载能力？N=IOH/IIH = 400uA/40uA = 10 输出1的情况 输入0 则IOL/IIL = 16/1.6mA = 10 输出0的情况，电流方向反 负载太大？非正常 低电平变高 高电平变低整个逻辑工作异常 电路设计的“线与”问题 需要多个外设输出连接一个输入总线，要求一个发送数据D时候其他都为1，线与在一起为1*1*D 即可 普通与非门：不能线与，Vcc和GND形成通路有50mA的电流损坏T4,5 图腾结构不能线与的理解：有H有L会有大电流流过烧坏 使用OC门（集电极开路输出的门电路）？？？速度慢 三态门TSC 保留totem输出结构但是可以输出线与的特点，速度快 叫G非的控制端，为0的时候切换为高组态，平时1的时候正常与非门 有的时候G非为0阻断，有时候是1阻断切换高阻态，看有无圈圈。总的来说是在与门接受0的时候阻断 多个三台门线与的时候：要先都到高阻态再有个别到正常态否则出现“浪涌电流”影响工作 电流方向！=数据流向 Lect5 译码器 数据选择器3.3 常用的中规模组合逻辑电路3.3.1 译码器 变量译码（所有组合2-4 3-8 4-16)、码制译码、显示译码 变量译码器 只有一个输入为0 输入只能接1个负载，所以加1级缓冲之后再译码。用的都是与非门所以化简之后的表达式要加大非。 应用 CPU2bit控制信号到译码器，连接4bit控制信号到4个设备上 有使能端的2-4译码 E非=1时 所有Y为1 E非的时候为disable而不是enable 则输入为1时候连到与门里面是0封锁 ——扩展、选通 多片2-4扩展3-8 高位输入C选片 AB译码 5片2-4扩展4-16 用高位CD来接入2-4选片，剩下AB译码 选通——解决竞争与冒险 A和A非输入，与非产生负向尖峰Spike 或非会出现正向尖峰：用EN解决 有时还会有“0”重叠Overlap现象，就同一时刻选择器中产生两个0，因为A’B’这种会有两极延迟相比于AB，导致AB和A’B’产生0重叠的危险 注意画尖峰的时候不光前面的延迟，产生尖峰本身也要有延迟 如果AB的改变没有同时到来存在skew的偏移，尖峰更宽 overlap两段 t_spike = t_skew+delay*1 t_overlap = delay*1 用使能端消除 AB变化中覆盖变化的EN非 = 1 强制Y0 = Y3 = 1 消干扰 这个使能信号要早于等于变量变化到来，对晚变化的信号至少滞后1级门延迟 记得覆盖掉变化，但是会使得输出有效波形变窄（有效时间短) 3-8译码器 一样的写ABC连接三输入与非门即可 扩展4-16？ 用高位D选片，低三位译码。。 多使能端的译码器？3EN的3-8：E2A+E2B为使不能1封锁//E1是使能0封锁 这样的选片更方便，直接使能和使不能连接高位D，总的使不能连接到分片的使不能上。 3-8译码分配地址07 256 CPU地址换算到每个ROM中的04共32地址空间 cpu高三位用来选片（CE非），低5位用来寻址 译码器作为数据分配器（一分多） 使能端为Data，C1C2控制多输出 Data变，C1C2选择把当前位分配给哪一个通道，如果通道恒1则被封锁 4-16译码器 真值表/功能表 组合逻辑中差不多，列所有输入和对应的输出 有两个使不能端，有一个1就锁死全1 问题：负载大，A非要负载9（2^n/2+1)个门，A要负载8个门2^n/2，使能端负载16门2^n 当输入变量增多，单级译码器不好实现，负载太大了。一般采用多级译码 4-16的多级译码，先前后翻译两个 先把四位输入翻译成EFGH WXYZ的两组合共8种有效值，再解码2-4 每个A只有4个负载降低了一半，每个与门也是4负载。相当于先粗分类成4+4类打包，然后讨论这4+4的两两组合每个对应一种结果 8-256的分级？ 划分为（4-4）对四输入粗分类成（16-16）然后讨论16*16的组合结果 每个A带8个负载 A非带9个 每个与门16个 码制译码器 编码换编码，如二换十进制译码（8421BCD to 1 bit Dec) 不完全译码比较简单，有不少X项用来化简但是完全的必须每个连4位 显示译码器 以共阳极，Low亮为例 4bit BCD转换为7bit亮灯（码制）对每一个输出都化简表达式即得。。 3.3.2 数据选择器（多选一\\多选多）4选1 四个D 两个控制S 一个输出Y 写出（化简）Y 连接即得 EN为1的时候使不能，输出恒为0 有两个EN的双4选1，提供正反两个输出，用3个双4选1得到一个16选4 16路输入，4个控制，这个选择 的过程是从输出到入的。从1分成4然后每个都是一个1分4（无EN） 有使能端时候，S23译码成四个选择器的EN，然后同时3个使不能，这样四个四选一其中三个都是0，如果三态门可以直接“线与” 总线发送控制 译码器是CPU往多个外设分配信息，这个是多个外设向CPU发送数据选择 译码器：看成N个输入组成的2^N个最小项。加一层与非即可实现与或逻辑 可以实现与或表达式的逻辑 一个译码器选择几个最小项接入与非即可 数据选择器 逻辑是与或表达 N个控制端的2^N最小项 和2^N个输入组成的与或，可以用数据来调节01。只需把含有的最小项对应的D进1就好。 甚至8选1可以实现四变量函数：三个控制+一个数据输入 把对应的ABC代入函数得到1 0 或者D D非，然后把这个结果放到对应Di上 Lect6 编码器 比较器 奇偶校验3.3.3编码器 编码器原理 反向译码，对应编码如4-2 8-3 10-BCD等等 应用在CPU控制端告诉那个外设在上传数据（只一个0 其他都1） 键盘的输入检测，哪个键被按下… 2-4编码的时候，如果取大非可以直接对里面的取补 8-3类似？？？ 8421编码器 0-9的十个信号转成4 bit 8421码 L6 P12 A+B+C+D = AB或非 CD或非再与非到一起 优先编码器：两条及以上为0的时候，优先输出高位编码 模拟键盘，如果同时被按下输出高位编码，以3-8编码为例 除了8个输入，还需要 使不能Ei非， 输出有效Gs（当本八位有有效输出的时候为0，可以区分是0被按下还是没有按键被按下的状态），输出级联E0（如果是0则允许级联，意思是没有按键被按下且没有使不能） 如果7是0则剩下无所谓，一定翻译000出去（反码编码，平时111） 由于反码编码，化简表达式也是化简Ai非=找0行 级联 高位板子允许低位级联把Eo连到低位Ei使不能 允许0的时候低位使能正常工作。高位级联接低位使能 两个有效与为总的有效 注意还是个3-8编码，编码结果只能接低三位，高位要高位板子的是否按下的有效Gs判断。切换的是提供低三位的片 应用 按照优先级编码，中断相应，键盘输入读取等 3.3.4数据比较器可以级联，以4位为例，高位比不出来才比低位 单bit比较：&gt;10 &lt;01 not xor同或为1 设计的级联是低位连接高位，即最高的四位作为最终输出 如果当前片比不出来才会去读取输入结果，否则以当前片结果为准 3.3.5 奇偶校验8个输入xor到4个xor到2个xor到一个即为结果，1是奇数 如果多位则在对应层级补进去 组合逻辑电路的竞争冒险竞争 输入信号由于延迟，走不同路影响到输出的时间不同。 非临界 不产生错误输出 临界 产生错误输出 冒险 由竞争导致了错误信号 ！组合电路中的险象是瞬态、暂时的尖脉冲，稳定后可恢复正常逻辑关系 判断存在险象 代数法：函数表达式可能存在X和X非 尝试消除其他变量得到X+X非或者X*X非的形式 卡诺图 把函数表达式化成卡诺圈进去，如果有圈相切（相邻但是不被同圈包含) 那这两个相邻项就是危险的 避免险象 增加冗余项 卡诺圈相切的时候手动把他们圈一起，冗余项可以保证当只有一个输入量变化的时候不再产生险象。在代数上理解是：把化简到A+A非 时候限制的其他条件加这么一项 电容滤波 过滤高频信号 要求惯性环节时间常数τ大于尖脉冲 不要太大否则畸变严重 选通 在最终结果的与门上再增加一路选通脉冲的输入，我只在电路稳定之后出现选通高电平脉冲，避开险象脉冲 3.3.6 可编程逻辑器件PLD包括ROM PLA逻辑阵列 PAL 阵列逻辑 GAL通用阵列逻辑 ）L6 P60 ROM 写入后只读（简单、规律、大容量） 区别可读可写RAM 与阵列+或阵列，输入后与阵列附近只有一条是1的其他都0 然后每个输出都是或阵列，可以直接出 其实本质上是对不同输入的分情况讨论，上面按照从小到大排列输入，下面每一列都是一种输出结果。讨论好标上对应点出去就好了 应用 比如翻译8421到格雷码之类 3输入4输出的rom为84的rom 可以*实现0-7的平方 储存计算机程序，每个地址（一列）为一个字节8bit PLA可编程逻辑阵列 逻辑压缩 PROM或阵列可编程 PAL是与阵列可编程或阵列固定，分组合的和时序的 GAL是可以同时实现组合+时序的芯片 rom是完全讨论的，输入相当于是地址需要完全寻址2^N PLA是压缩的，逻辑函数需要什么我们才保留什么，我们需要最简与或表达式。 每一列代表输出中的一项，上面是项的与表示，下面输出的或 储存讨论的信息的时候也可以压缩最简单的输出项表达式，然后用每一列代表一个乘积项最后或在一起。一组地址多个P ok Lect7 运算器3.3.6 加法器半加器：不考虑进位，异或就好了 一位全加器 写出表达式不化简直接得 卡诺图化简一下 都表示成与非、与或非等形式。直接找的是F非和C非（找0）这样都是2级门延迟 尝试用Cn表示Fn，即先把Cn算出来之后用其结果和ABC组合得Fn 注意这里一种思路是写Cn和Fn，另一种是写Cn非和Fn非 四位串行加法器 如果都用方案2 最终F4 C4都是8级门延迟 都用方案3，最终为F4 9级 C4 8级 方案34 交叉串联呢？C1两级但是C1非其实1级就好直接扔D得到C2也是2级。C3非一级就好C3 C4都是4级 那么C5就是5级 这种方式主要是交替利用C和C非作为传递使得C的计算飞快。F总是当前的C+1级即可 超前进位加法器 提前算出C1234 在表达式中看出： 搞一个产生进位函数G=XY 传递进位函数P=X+Y 记得写表达式的时候直接找C = 大非（XXX） XXX为C非的表达式 Ci都是2级 Fi都是3级 16位加法器 记得算延迟都要先算各级的C再算F 4个超前进位4位加法器也可以再加一个超前进位器 P34为构成方法 这时C4 8 12 16的延迟都是3 F1-4是3 后面都是6级 p146 SN74182 超前进位扩展器专用器件 3.3.7 算术运算逻辑单元 4位功能控制：加减 比较 与或非 移位 核心是四位并行加法器 控制进位逻辑（简单但少 10得同或结果时：X+Y （非00即可）和 !(XY) （非11即可）与 然后和1进行异或。 11得与结果时： !(XY) 和1取异或 改变Gi 和 Pi获得多种运算能力（多但复杂 四个S是控制如何产生Gi和Pi的 M状态控制 ，是否进行逻辑运算 L7 P51 有各种16种的运算 书P141 的元件74181 Lect9RS基本触发器 问题：0 0时非正常状态（本时刻一定是11，下一时刻如果11读取 就为不定状态了） 11读取 两个与非交叉 时钟控制方式：电位触发、边沿触发、主从触发器 功能分类：D、R-S、J-K、T（Toggle） 重点：边沿触发的D和JK触发器 如何解决00时的异常？限制输入or保持稳定不坏 电位方式触发 Clock Pulse修改R-S的输入，增加使能端，就EN=1的时候一定是保持状态，优化成与非，E成为真正使能，0的时候一定是11保持 这时候的修改RS电位触发器变成了00保持 11异常 改进？单端输入，一定控制两个输入是相反的，改成D 但是延迟太大了吧，D到Q非最大要4级，再改进得到 电位D触发器 E仍然是使能，0的时候是保持（读取） 问题：抗干扰差 使能脉冲某个跳变来时，输出才变化为输入的值 正边沿D触发器 某个约定跳变来才接受数据，没约定跳变就保持 CP = 0 时 上面为基本RS的11状态，保持 如果正边沿到来，在信号到来产生一级门作用的时候改变状态 其余情况在CP = 1 的时候D发生两种改变都不能改变上面的电路状态。分别由两根锁死阻塞线来限制 CP负边沿跳变的时候，34门都输出11为传统RS的保持状态 开关特性 数据建立时间tsu = set up 数据接受的时候要稳定保证门3、4接受好数据(尤其门4要56处理完之后），有tsu&gt;=tpd5+tpd6 2*delay 数据保持时间th = hold 要等待阻塞线正常工作之后才能撤除这个有效的Data值 如D = 1，必须等门4的阻塞线封锁住3和6才好则 th&gt;=max(tpd3,tpd4) 1*delay 传输延迟参数tpd = pass delay 分别讨论输出HL还是LH CP到Q还是Q非 共四种 主要看两条阻塞线，CP=1时有一条为0则代表一种状态，D只能被阻塞在5或者6门。当低电平两条线都是1时候56都打开才允许数据进入。 故低电平要保证D通过5和6就位在34门口，低电平&gt;=tsu且tsu只能在低电平区间 高电平要保证thold形成好封锁&gt;=thold在高电平期间 tpd cpQ 也需要在高电平时间，在高电平让输出稳定下来47 为的是给下一个器件就位比如下一个触发器的输入就位。所以如果两个触发器之间有组合逻辑电路，这里的延迟仍需要算在tpdcp-&gt;Q上。 多个FF最高时钟频率？ Tcp-min = tsu Tcp+min = max(th , tpdcp-&gt;Q+tpdG（组合逻辑电路延迟）) Lect10 负边沿JK，主从触发器 00保持11翻转 JK分别为Set Reset P4-P9 为操作的结构原理 异步是不需要等CP的强制清零，0是选中态，正常为11 主从触发器 两极电位串联 CP=1主触发器接受从封锁(+电位) 负跳变主封锁从触发器接受主触发器的状态（负跳变） 主从RS触发器 17为加入异步 21有划归到主从RS的方法 主从JK功能表与主从RS相同，只是11支持翻转 只是在正时钟周期中JK不变化的前提下给出，不然能不满足功能表，抗干扰差 主从VS边沿 主从似乎是负边沿因为正边沿接受负跳变才状态变化，但是触发方式不同。主从在负跳变时反应的是从触发器的状态可不一定是JK等输入的状态 经常从触发器在负边沿读主的时候，反应的是正边沿中的第一次变化（第二次有时候由于从触发器QQ非没变导致JQ非=0 KQ=0而不发生变化，即最多可以发生和原来Q不同的一次变化比如把Q的1换成0，但是不能变第二次了会hold） 分析具体变化看下面这张图（注意从的之前状态） 所以主从适合正脉冲窄，短高电平的情况 T触发器 Trigger cp来就翻转，一般都是边沿（由DorJK构成） D的翻转需要Q非接D JK=11自带翻转 CP由功能控制T和真实时钟cp与成，T=1时Toggle模式 触发器的功能互换？ 功能需求=》用卡诺图写出Qn+1与Qn和输入之间的关系，再转换成激励表达式接入电路即可。 D转JK Lect11 同步时序电路的分析与设计 统一CP，约定脉冲改变整体的状态且只改变一次 功能表（含Q真值表） 输入（激励）+Qn 得到 输出+Qn+1 现在的状态+不同的激励能造成什么样的结果（未来状态） 状态表 卡诺图中一维是激励，一维是Qn 表中内容是Qn+1 现在状态+不同的激励造成什么样的未来状态 状态图 圈里面是状态（Qn）转移边上有 输入/输出 状态方程 Qn+1 = 激励条件（D) 下一个状态的决定方程 激励表Qn Qn+1 得到 激励项（例如D、JK） 状态的不同转移需要什么样的激励条件 逻辑图——状态图——文字描述（设计为逆） 同步时序电路分析 根据电路图列出触发器激励函数表达式D= 和电路输出函数**F=**f（Q) 输入怎么影响D Q怎么影响输出 建立Qn+1表达式（根据上面的激励）以及状态表（类似真值功能表，Qn和输入得到激励得到次态和输出的表格） 常用Qn+1 = D // Qn+1 = J !Qn + !K Qn 状态（转移）图 记得画完整 由状态图和次态、输出表达式带来的时序图（规定cp和输入，画Qn和输出的波形） 分析输出和输入的关系说明逻辑功能 可以先明确里面状态、中间态的含义（如保存上一位的进位结果） 不完全的（6状态集合）也可以叫3位格雷码计数器 两个状态互换为clk的2分频 这样属于不能自启动的格雷码计数器（不保证一定能进入主循环） 这是能够自启动的4位二进制计数器 JK更方便实现“取反“ 把几个D触发器串行接好，低Q进高D，最高！Q进最低D得计数器 如何修复自启动？？？ 同步时序电路设计 确定输入输出变量 原始状态图和状态表（可能并不最简）状态表： 状态化简，画出最简的状态图和状态表 对于完全相同的行，合并其状态，直至不能这么做， 状态表和状态图：一般每个转移边对应表中一行 状态分配：给每个状态用一串二进制来编码 求出激励函数和输出函数 化简前就检查好能否自启动 根据状态图 画一个大号的功能表（真值）分别为 输入 Qn| Qn+1|激励DorJK（由Qn+1）|输出（由Qn和输入） 根据后两列可以求出激励的表达式和Z的表达式 这时候可以用卡诺图来化简 横纵二维都是输入和各位Qn，里面是各个Qn+1。能直接写出来的就直接写 画（电路）逻辑图 计数器 对CP脉冲计数，每次变化一次状态同步、异步；加法、减法、可逆；二进制、十进制、任意进制； 同步四位二进制计数器 偶尔需要“实用” 这里的Q0Q1都是二、四分频 用JK触发器设计时，经常统一JK即可，而 十进制计数器 编码、化简即可 可逆计数器 一个输入X表示是否正向计数 满1111之后进位Z为1 用X表示模式的时候，经常可以两边化简完之后用XF1+!XF2来调节 设计计数器的问题——自启动 修正状态图，改变激励表 Lect13 集成化的4位二进制计数器需要：异步、同步清零；同步置数；计数；保持；扩展；进位 仍然是0是确认态，常态为111 RC是进位在1111or1001时，这样下一时刻cp来了可以一起动。 T 串行控制：低位RC接入高位的T，常态是0即FFHold状态 片间的进位RC逐片传递导致计数频率不能太高，RC每一片都要延迟 P并行控制：即快速扩展，分析进位条件是所有低位片都是1111 只有当TP都是1的时候本片才进位，最低位RC连各个P，然后T都是RC（次低片可以直接1）当最低片1111（RC=1）且上一位RC=1时本片进入进位预备状态。 这样就是除了最低位，每片到1111之后就已经在RC—HighT预备好了 随时等待最低位的1111就位得到P=1时候进入预备，只需一个延迟 但是最高位的RC并不代表整体的进位。。 集成化的标准计数器接口与功能表： Rd!：触发器提供or（谨慎）组合逻辑直接清零Rd*Q这种 CLR：从激励方程入手，直接在D上修改，下次检测就可以改了 Load：接着改激励方程，L!(输入)+L（Q） TP:接着改激励方程记得改RC，保持的时候D取自己的Q 用76163自动循环状态 在到一定值之后启动置数预备Load，置0000 产生固定序列信号如101001 用上面自动循环状态的计数器 常规方法，用DorJK 循环移位设计，用QQQ表示长3子串然后循环起来（记得循环到下一个的前三位），注意不能一对多 101001101001 输出随便接其中一个Q即可 Lect14-1 寄存器——存储基本寄存器 基本4D寄存器，需要异步清零（!Rd=0）和置数（!Rd=1) 记得减少对外负载，但是数据不在的时候不能保留了呜呜呜 !Rd异步清零 !E置数 CP时钟 11的时候Qn+1 = Qn否则Dn 置数、保持还能选择？加Select输入可以选择数据源 再加个使不能 !OE = 1的时候为高阻态P13 两个相反的寄存器作为输入输出，让两个E和OE相反来控制 移位寄存器需要寄存器有移位功能，每一个cp脉冲，寄存器数据顺序向左（右）移动一位，要采用边沿触发（or主从触发器） 串入变并出的移位，每一个Q接高位D，但是不循环移位（叫右移其实是左移。。） 并入并出的双向移位Reg 双向用S0S1控制 1就是哪个方向，11置数 应用：用移位寄存器设计信号发生器101000 选用串进并出的 取n=3得到 101 010 100 000 001 010有重复010无法区分，增加位数 n=4得到 1010 0100 1000 0001 0010 0101无重复，每次通过Q0123讨论出一个下一位要移进去的数字，做出6/16的卡诺图化简D，下一个是Q0讨论即可。 发现并不能自启动。有3个非工作循环。对非工作循环中任取一个状态，让次态进入工作循环比如0000=&gt;0001进入（移入1）卡诺图7/16 记得考虑怎么样比较好通过移位方式进入工作循环 Lect14-2 Ch5可编程逻辑电路ROM只读存储器 40PROM与阵列固定（地址译码固定）或可编程（储存信息可以改） 就是全部的输入情况来分情况讨论 计算点数的时候记得与阵列算非 PLA可编程逻辑阵列 47 与或均可编程 组合逻辑表示D压缩，只表示最小项甚至只表示乘积项即可，不是最小项 先找Fi的最简与或表达式然后找乘积项，一条竖线表示一个乘积项上面与上乘积项的表达式。下面每个输出（一行）自取乘积的sum 计算点数（交叉）：2*输入*P+输出*P 计算容量：输入数目* P项数目*输出数 4* PAL可编程阵列逻辑 与可编程或固定 72决定好了每个输出取哪几个P项然后自己编写P项 有反馈的寄存器PAL可以实现时序逻辑但不能组合 演变过程P78 GAL通用可编程阵列逻辑 80 与可编程或固定输出控制OLMC+反馈结构+多次可编程+集成度++ 需要：输入、输出、与阵列、输出逻辑宏单元 GAL16V8@20pin 16入（右侧8个在OLMC下通用出入） 8出 8个OLMC（或阵列in it） P86逻辑图 总的电路经验 xor：想逐位加法、01个数等等，化简的时候多用xor简化，逐位判同（尤其是计数、加法） 每两位xor：典型格雷码 分析组合电路：不一定顺着看输入，试试顺着看输出？ 模式控制：多在激励方程上之际修改，如置数、清零、数据选择。优先的放外面 组合逻辑电路分析与设计：表达式、功能表、描述 对BCD分级译码：先译AD，因为1xx0和1xx1唯一为8和9 分级选数据和分级译码都一样，一定看好怎么分、分谁 比如S3210选D0~9，可以先用S3区别0123和89XX互换 其实BCD译码和数据选择都是对控制端的讨论和翻译 组合电路的开关参数：XX输入到XX输出的延时 2个四选一模拟3输入函数？ 16并4并1：算大PG需2，算C4 8 12 16需3 各片算C需要2 算F1共6 状态表： 时序图没有初始状态就假设一个","link":"/2022/06/18/2022Spring-dlc-final/"},{"title":"Hello World by hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/1970/01/01/hello-world-by-hexo/"},{"title":"Hello World","text":"一直拖着的个人站因为很早之前就买了比较喜欢的域名，一直想尝试建一个自己的网站。最开始计划假设在阿里云的免费ecs服务器，配置下Nginx反向代理应该能用简短的域名访问，但太麻烦一直搁置。直到昨天终于发现Github Pages也有绑定自己域名的功能，遂花了两三个小时搞了这个像是博客的网站用来取悦自己（x）。 虽然很难做到，但希望能坚持维护下去，偶尔发布点记录和想法，留给以后的自己看。 内容规划按计划来说，要先把自己写的markdown格式的一些文字内容搬上来，看上去像个样。但是日常记录太过私人貌似不能放到互联网上，而课程笔记和期末复习又很无聊，那就先空着吧，开摆！","link":"/2023/09/02/hello-world/"},{"title":"2023春季学期 网络编程技术 期末复习笔记","text":"W3 3-1UDP用途 只因你太美 简单的应答协议 DNS，DNS的16位ID用来请求应答匹配，太短了容易伪造 最新的QUIC协议 UDP socket套接字编程五元组定义完整会话：2ports 2addr Protocol 字节序：尤其控制信息，统一使用网络字节序big endian 服务器常常需要bind地址，而客户端不必要。 tolen 对方地址长度 Bind和Socket首字母大写？表示对原有socket的封装， MAXLINE长度后，recvline[n]=0来防止溢出 编程考虑问题：版本号、可靠、安全、性能、一致性… UNP超时重传在编程实践中落后：1.粒度太粗，超时重传要几秒的检测，不可忍受 2.Risk Condition 依赖于事件发生次序？在不可靠网络中次序不定；andOS调度出去的时间超时等等 取而代之的是setsockopt建立读写超时即套接字选项 设计文件传输？可靠性 性能（并发性） W5 3-1代码分析角度 recv接入char数组， 2-15 没有检查接受长度是否超过缓冲区（缓冲区应该是最大有效长度+1） 2-15 没有用0手动截断导致转string或后续的溢出错误 2-15 没有检查recv是否为有效长度（可能0） 2-32 recv直接读入结构体，要检查格式化的正确与否（对齐等） TCP SOCK_STREAMCodingClientsocket connect 服务器地址 read or write close Serversocket bind listen（sock, backlog未决队列即未完成三次握手的SYN） accept read or write close Danger 一个连接出错整个服务器退出syserr等 通过sigaction设置SIGIGN（SIGPIPE）来防止向已经关闭的socket写 重启会导致address already in use，在关闭连接后还要等待2MSL 约 4min——设置SO_REUSEADDR允许2MSL内被绑定，可以多个服务器绑定一个端口但是本地IP地址不同 设置SIGCHLD回收子僵尸进程 waitpid 设置setsockopt的RCVTIMEO和SNDTIMEO避免发带连接 KEEPALIVE保活报文测试 SOLINGER避免FIN阶段对方不回复的发呆连接，设置为1,0即可 SO_REUSEPORT 负载均衡每一个进程有一个独立的监听socket，并且bind相同的ip:port，独立的listen()和accept()；提高接收连接的能力。 一致性 安全性能 FTP慢： 小数据包延迟大Nagle算法延迟发送直到ACK才发或者超时才发，避免一堆小包 延迟确认ack浪费，所以捎带确认，超时再ack 导致客户端先发一个包，然后下一个包太小不发送，服务器没收到请求不ack。直到服务器超时ack了，客户端才请求服务器才回应。 TCP_NODELAY来关闭NAGLE TCP_CORK阻塞不足MSS的小包，手动开关来控制 SO_RCVBUF SNDBUF手动修改缓冲大小，在连接前设置，至少4个MSS 进程并发服务器主进程loop accept+fork新进程处理连接，主进程要关闭acceptedsocket而子进程关闭监听socket。 prefork先fork一堆来监听，一个accept处理。。。其他接着听 主进程accept通过socket传输 子进程各个accept通过进程锁保证互斥（文件锁或者进程mutex），给fd上锁 避免accept的重复堵塞 BSD acceptfilter系统SO_ACCEPTFILTER SOL_SOCKET Linux：TCP_DEFER_ACCEPT accf_data: listen socket在收到client的数据后才可读 accf_dns: listen socket在收到一个完整的DNS请求后才 可读 accf_http: listen socket在收到一个完整的HTTP请求后才可读 UDP SOCK_DGRAMCoding地址中含地址+端口 int sock = socket(AF_INET,SOCK_DGRAM, 0) 申请套接字描述符 bind(mysock, (sockaddr *) myaddr,sizeof(myaddr)); 绑定套接字到端口，服务端 int sendto(int sd, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen); 发送消息到指定地址 int recv(int sd, void *buf, size_t len, int flags); int recvfrom(int sd, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen); Clientsocket sendto 自动选择己方端口，需指明对方地址 recvfrom ？？从某个特定地址接受，如果不在乎对方地址设置地址和addrlen为null。也可能是放来源地址的 Server12345678int mysock;struct sockaddr_in myaddr;mysock = socket(AF_INET,SOCK_DGRAM,0);memset(&amp;myaddr, 0, sizeof(myaddr));myaddr.sin_family = AF_INET;myaddr.sin_port = htons( 53 );myaddr.sin_addr = htonl( INADDR_ANY );bind(mysock, (sockaddr*) myaddr,sizeof(myaddr)); INADDR_ANY 即0.0.0.0 监听任何来的地址socket bind recvfrom sendto Danger问题可靠性数据丢失，recv阻塞等待——设置超时重传时间 不要用alrm设置超时，被调度出运行且超时 使用选项setsockopt int setsockopt( int sockfd, int level, int optname,constvoid *opval, socklen_t optlen); SO_RCVTIMEO, SO_SNDTIMEO 指定时间没有可读就结束返回错误 指定时间数据没法出去结束返回错误 int select (int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *);限时读，直到有fd可读 FD_ISSET fd在fdset中的状态是否变化为可读 数据对应（可靠）标识号 Finallect1互联网的经验： 问题驱动 成本低 核弹和分布式系统 遵循规律 18 吉尔德定律主干网带宽6 n^2 演化成长 接入终端丰富 协议栈演化 绝非偶然 OSI：权威机构ISO 严谨设计 区分服务协议接口 互联网侧重异构网络的互联 lect2 协议设计角色：客户端、xx类服务器 体系结构：颗粒化：控制、数据分离） 传输统一（相同传输层） 功能选项化（考虑到但不实现） 状态：一问一答，有依赖的一问一答 PDU协议数据单元一次会话传递：边界！TCP数据流切割为各个协议原语、UDP报文和原语的对应——固定格式与分隔符、指定可变长度、传输层指定一次TCP连接和报文 编码、传输 协议设计准则 原语、消息类型（状态）编号：区分原语，指示错误 一定要有标准的协议规范否则任何都是合法 并发性能：区分多个用户的多次服务UDP，区分一个用户两次服务 会话ID 指定会话开始的位置 性能 分块ID 认证安全 UDP定义协议规范，能够判定是否合规，丢弃不合规 认证信息 压缩加密 可扩展性 协议版本号 报文类型 扩展项 编码 区分控制信息和内容信息——规定文本格式 序列化（字节序！！） 可靠传输 校验和 hash值 请求应答匹配 ID Protobuf默认小端字节序 [rule] [type] [name] = [tag] message rsp{ required bytes fuck = 1; } 7bit varint 首bit为0表示下一个是新信息，否则是1表示下一个也用来表示此数字 udp性能好并发好，复杂 tcp简单，可靠但固化 http最简单 性能差 QUIC优化TCP+TLS？？更快但等价 简易 可扩展和演化 互操作性 lect3 UDP编程8B 包头 无连接 多路复用 可选差错控制 没有拥塞、流量控制 支持组播广播 DNS 不可靠：丢包、乱序、抖动、内容改变 信号系统：异步事件 INT 用户前台 KILL杀死 HUP 重启 QUIT建立core的退出 WINCH 忽略信号 窗口大小发生变化 SIGALARM 终止进程 计时器到时 hup disconnet时 lect4 UDP编程2安全性假冒服务器回复 拒绝服务攻击 一致性切割协议的字符 长度限制：MTU MAXLINE UDP 长请求所有数据返回还是部分返回 recv中的MSG_TRUNC flag，返回截断前的长度 服务器尽早识别不合法用户，区分业务类型和时间 客户端分担服务器功能，尽量过滤异常请求 224.0.0.1子网所有系统 .2为所有路由器 IGMP协议报告组播组的加入与退出，路由器定期询问主机响应，不主动退出而是询问发现 lect5 TCP网络编程不支持组播广播 lect7 多线程编程int pthread_create( pthread_t tid, pthread_attr attr, void ( start_routine )(void), void* arg ) pthread_detach 从主控线程分离，自己回收资源，防止僵尸。否则要等待主控线程join pthread_attr 线程属性 如PTHREAD_SCOPE_PROCESS进程级或系统级争cpu gethostbyname线程不安全，使用全局变量指针，后面把前面覆盖，不要用！用两次或者多线程用都不安全——gethostbyname_r 共享数据的data race多个写，非原子的单个写（经常一条编译成多条），指令重排（线程内不冲突就重排但是线程间冲突）——使用锁和条件变量 使用mutex时的死循环甚至死锁 ？？ pre threaded 主线程accept 通过工作队列（命名队列）传递 各个子进程accept通过互斥锁保证互斥 lect8 Event多路复用selectselect检测事件：可读、FIN（read返回0，endoffile）、RST的read-1、accept 可写或者写端关闭 用于TCP Server的select，一开始只有listen fd用于监听accept可接受新connfd。 套接字数目有限制 FDSETSIZE 1024无法更改——poll没有限制size，int poll(struct pollfd *fdarray, unsigned long nfds, int timeout); /return : count of ready descriptors, 0 on timeout, -1 on error/ pollfd包含fd，events和recents，指定验证的条件 阻塞非阻塞读写 阻塞IO非阻塞io file control val = fcntl(sockfd, F_GETFL, 0); fcntl(sockfd, F_SETFL, val | O_NONBLOCK); 用这玩意取出老状态bit，与上新状态位再放回去。 进一步提高效率epoll不用来回copy fdset ET EPOLLET 只有监视句柄发生事件才报告，必须非阻塞读写防止一个阻塞饿死所有其他。纯正的事件触发 当read(2)或者write(2)返回EAGAIN时才需要挂起？ LT 默认，阻不阻塞都支持，传统的select。检测缓冲区有没有没读完的东西epoll create()创建空监控fd table ctl（ADD） epoll wait 工作方式：边缘触发ET或者等级触发LT lect9 IPV6任播取代广播 服务器纯v6 通过把v4地址映射到v6来服务v4 0:0:0:0:0:FFFF:210.25.132.100 全0作为srcaddr可以，不能目的，不能分配 IN6ADDR_ANY_INIT loop地址：::1 给自己发，只能节点内部，类似loopback inet_pton和aton 协议无关服务器编程同时监听v4和v6 基于域名的切换 resolver查A和AAAA getaddrinfo替代gethostbyname，域名或ip地址，返回一个链表多个地址 sockaddr_storage足够大的通用地址存储结构 16B的sockaddr 28B的sockaddr in6 128B的sockaddr storage getnameinfo 解析sockaddr给出的域名或者服务名，返回host和service n是规范化格式 aton ntop等等 IPV6_V6ONLY lect10 安全编程1协议缺陷内存操作缓冲区溢出 动态内存操作 读越界 缓冲区溢出，不要相信不可靠信息 整数安全溢出、截断、符号 lect11 安全编程2格式化字符串格式化的字符串 不能交给用户，因为参数可变长可以偷栈信息 代码注入command命令中含有用户的string race conditionmysql_real_escape_string不能解决所有问题 使用prepare类型的调用接口，可以将数据和控制分开 使用’?’来作为占位符号，实际用时填入相应的数据 使用ORM 对象关系映射（Object Relational Mapping），将数据库中的数据映射为对象 ValgrindDRD 用于检测多线程编程中的常见错误 lect12lect13代码挑错 可能可以read但是无法readline","link":"/2023/06/07/2023Spring-nct-final/"},{"title":"2023春季学期 操作系统 期中期末复习笔记","text":"3-2API App Programming Interface BI 二进制接口 ABI 应用程序可以使用的OS提供orAEE提供的服务 SBI 操作系统可以使用的硬件服务 EE 执行环境 HAL硬件抽象层 左：类似遥控器、蓝牙耳机，非常简单的小设备，不需要通用性。不需要操作系统直接工作在硬件提供的AEE环境中 中：传统的基于操作系统的架构 右：多os服务器，基于虚拟机 简单小设备，专用（蓝牙耳机、遥控器）Mmode写死——嵌入式设备，需要偶尔更新，独立性（信用卡刷卡机）U+M——移动电话USM——数据中心服务器USHM Hypervisor 硬件线程 Hart 相当于处理器的一个core User 基本计算，不能用硬件、特权，不能影响其他app Supervisor|Kernel 足够的硬件操纵能力；限制APP执行访问；kernel特权级，影响应用程序 Hypervisor|VM 限制OS的访存；影响OS Machine|PM 控制物理内存、关机；LibOS实验的编程模式；BootLoader BIOS 影响上层软件 csr寄存器最多4096个CSR 三态编程怎么实现断点和单步跟踪的调试？？？ 3-3 批处理操作系统把APP和OS彻底隔离开，APP执行完后让os知晓并引导加载下一个app。 LIBOS 隔离应用和硬件 简化应用访问硬件的难度和复杂性8040是用户库入口，初始化后进入app主程序 LabNotesLab1syscall通用 syscall_write 指定调用id和安排寄存器等等 lib中进一步封装为write，像是std console中通过宏直接包装成println 在加载用户态程序到80400000时，由于修改了Imem部分的内存。Icache以为其对应的指令部分内存是不能改变的，但是这里我们注入新app指令导致必须清空icache。否则导致缓存和数据不一致 更改内存时候一定刷新对应cache的内容 异常处理 alltraps 保存上下文 rust traphandler 0414-0417 Midterm ReviewLect1控制：给app提供服务，防止错误，方便用户 资源管理：管理 服务 解决访问冲突 并发、共享、虚拟、异步 个人电脑不那么重视CPU利用率，而是与用户交互的友好 分布式系统，关注系统利用率、网络存储计算效率 走向网络 MS-DOS 应用系统混杂，汇编 单体分层：硬件驱动到用户界面 微内核：尽可能把内核功能移到用户空间，内核提供基础服务，即对端的高层实现。用户模块用消息传递通信，灵活但是性能差。里面都是LPC和HAL 外核：保护与控制分离，应用管理资源，功能都交给APP实现？？？ 虚拟机：VMM平台上面跑很多虚拟机，是计算机的副本 fork创建进程返回子进程PID，如果自己是子进程返回0 exit|wait等待子进程 kill getpid sleep exec不返回，用这个新文件取代当前进程，丢弃当前data和instr 可以forkexec sbrk 增加进程内存n个字节，返回新内存的开始addr open write read close dup pipe创建管道相当于两个fd，fd1写入 fd2读取 chdir更改当前目录 man命令 1查shell命令 2查系统调用 后面跟名字 fork中 Lect2LibOS以库形式提供给应用程序 批处理：内存单道但自动加载一个个 多道：内存多道，依次执行 分时多任务：轮流执行 地址空间抽象：内存空间隔离 超越物理内存 进城抽象：动态创建 多处理器并行 文件抽象：便捷持久存储 2-3 硬件软件启动BOOT qemu bios一小段汇编初始化 开机进入bootloader即rustsbi-qemu.bin 加载os loader target即开机用bootloader家在什么东西，加载到80200000开始的地方 2-4 LibOS 以库的形式实现OS，上面是APP 栈帧最开始一般是ra和prev fp上一个栈帧的起始地址。 进入某函数先在栈中保存ra，属于prologue Lect3 特权级隔离与批处理3-1 硬件和OS中间是指令集和寄存器，系统调用是os和app的边界——安全 隔离的好处：程序监控破坏另一程序；程序破坏系统；恶意程序病毒bug 每个程序不影响其他程序和os的执行和信息，但也需要共享数据和资源，建立边界 软件|硬件|网络的隔离；控制|数据|时间|破坏隔离——特权级|地址空间|中断处理|异常处理 异步中断，同步异常，中断可以不来自运行的某一条指令，来自外设、时钟等 中断，执行完当前指令后转移到中断处理，然后去下一条指令。用户透明 异常，处理后恢复到本条指令 系统调用，同步异步都行，恢复到下一条指令，属于广义的（同步）中断，但是硬件上为异常的处理 3-2 OS看RV APP ABI OS SBI SEE HAL Hardware Umode 非特权级模式 Smode 特权级模式，足够的硬件控制能力，可以限制APP，影响app执行 Hmode 限制OS的内存空间，影响OS Mmode 限制一切os和软件 bootloader或者bios 最主要是拦截处理中断异常 要求精确异常处理，之前完整执行+之后没执行 高特权可以委托低特权模式软件处理中断 CSRs非特权指令不可访问 4096个最多 用户态大部分不可访问 tvec 向量表，指示跳转目标 epc 发生trap的地址 cause 种类：是否中断+code ie 中断使能 ip 中断请求（等待处理） tval trap的value附加信息 scratch用于存放信息 status 跟踪记录当前硬件线程的状态；保存全局中断和其他状态。比如之前的特权级，控制全局中断的禁用和恢复 fence.i 非特权指令 中断标记 硬件设置，调用服务。软件保存，处理，清楚标记后恢复 开销：建立中断异常和对应服务；内核堆栈建立；验证系统调用参数；内核态用户态数据拷贝；内存状态改变后刷新TLB和Cache 硬件响应 默认都导向Mmode，但是M可以重新导向Smode。RV可以直接中断异常委托机制来把一些中单直接交给S绕过M。如mideleg和medeleg 设置1就把对应的中断异常直接委托S 存epc（异常指令or应跳转到的位置），跳转到tvec 设置mcause 设置mtval比如出错地址 status的MIEorSIE为0禁用中断保证原子操作，MPIE留之前的。记录之前的权限到MPP或者SPPsatp mode 开启分页 页表级数 ASID 可选，避免进程切换刷新TLB PPN 根页表物理页号 3-3 实践 批处理操作系统 ch2 BatchOS自动加载运行多个程序 硬件特权级保护来保护os ebreak指令专门产生异常来调试，断点陷入异常 应用程序地址从8040开始 加载应用程序后必须清理icache 内核栈与用户栈，换栈 使用scratch作为中转 Trap上下文 CTX：32个通用寄存器 status和sepc 在ecall之后瞬间改变了sepc等几个csr，进入traphandler 在__alltraps瞬间换到内核栈 保存除了sp和tp之外所有reg到内核栈，以及sepc和status，然后是scratch中的usersp，把此sp指向ctx作为a0参数调用traphandler分发执行 在内核栈上处理此trap __restore恢复ctx后sret回去应用切换 runnextapp 构造一个trapctx 其中sepc为8040，sp设置为用户栈 把以上ctx压入当前的内核栈并传入restore的顶指针，其实就是栈顶 restore恢复并换栈 栈顶设为a0 从内核栈载入status和sepc，把用户栈sp存入scratch 恢复除了sp tp之外的reg，释放sp 换为用户栈 sret Lect4 10-124-1 进程和进程模型内存驻留多个各执行程序共享cpu，协作调度（yield）os不会打断；抢占式：进程被动放弃，时间片轮转使用，硬件中断 进程==任务！=Job Task = 程序+执行状态（控制流 数据 上下文），需要cpu+内存 TCB任务控制块orPCB进程控制块 进程状态：未初始化 就绪空闲 执行中 已退出 4-2 实践 多道和分时多任务 ch3 MultiProgOS每个应用的addr都不同，大概是base+0x20000*index 在内核初始化的时候就被加载到这些base处 TaskCTX 保存执行状态的上下文，包括ra sp callee saved，并不存在stack中而是在memory 数据段，非动态分配的。这里的ra是switch的返回地址即上次任务切换发生的指令 这里的sp是task对应的内核栈 switch不涉及特权级切换，一直在Smode，只保存calleesaved 使用switch切换，kernel会切换trap控制流，和普通函数的区别是会换栈，相当于usercodes中间call switch函数… 为什么call switch的时候sp在内核栈上？？？——这时候存的寄存器都是trap后的？ 保存信息到TCB的task ctx，存到a0对应的位置上，包括把sp和ra以及12regs存进去 读取下一个taskctx指向的taskB，恢复这个ctx的ra sp和s0与s11 之后sp已经指向了B的kernelstack ret到ra普通控制流：程序执行序列 异常控制流：os程序员，控制流突变，执行环境切换Trap 控制流会对应上下文ctx，如函数调用在userstack存栈帧，trap处理在内核栈存trapctx，任务切换在osdata存taskctx 时钟中断和计时器，硬件提供了settimmer在某个时刻发生中断的功能。 Lect5 物理内存管理12-145-1地址空间逻辑地址：CPU执行指令时的地址，编程地址 LA ——段内存转换——VA——页内存转换——PA 作用：抽象方便；保护安全；共享；更大虚拟化；外存缓存高效；隔离简化 编译-加载-执行三次生成地址，编译时假设base已知，如果未知生成可重定位代码。加载时生成绝对（虚拟）地址 ALU等cpu内部需要逻辑地址，MMU转换PA，总线上是PA请求 MMU地址|权限检查，产生异常 5-2内存分配静态分配——编译时分配，全局or静态变量和代码 动态——运行时分配，局部变量，malloc和free。隐式分配语言编译器会自动帮你释放free掉不同的malloc内存如java。 栈是编译器管理，隐式，拿起来用不用还，编译时确定 堆是程序员需要显式管理的，alloc和free需要等量成对使用 连续内存分配 如malloc内存碎片：外碎片 分配单元间未被使用 内碎片 分配单元内 动态分区分配：分配进程指定大小可变的连续内存块block。操作系统需要维护分配的分区和空闲分区 策略 最先匹配：空闲分区按地址顺序排序；分配时候够了就分配；释放时检查附近的空闲分区合并 简单快；高地址有大块空闲区 很多外碎片；大块分配很慢需要往高检索 最佳匹配：按大小排序组织；查找合适的分区；释放时合并临近分区 小尺寸申请密集，效果好；避免大分区被拆分；减小外碎片；简单 外碎片仍然有；释放分区慢（组织复杂）；无用小碎片多 最差匹配：按大小排序，优先给最大分区；释放时合并相邻并调整顺序 中等大小表现好；小碎片少 释放分区慢；外碎片多；破坏大空闲分区伙伴系统分配 快速分配释放并不产生外碎片，组织成二维数组，其实是每个块标记长度和起始地址，随时被二分。空闲块和分配块各是一个按addr有序的vector 合并条件：等长相邻且合并后对齐 非连续内存分配 即使不连续的物理页也通过页表变成连续的虚拟页，解决碎片 一般申请较大的内存空间，很难连续分配 提高效率和灵活性——非连续；可共享；动态加载链接段式管理：内核管理段表，对应进程 cpu给出逻辑地址包含段号+段内偏移 查找os段表找到该段baseaddr和length，check合法页式管理：内核管理页表，对应进程，需多次访存 TLB+Cache加速 多级页表来减小页表长度 基于hash的反置页表 根据物理地址来生成页表项，每个页表项对应一页物理地址。需要进程号表示地址空间以及存储虚页号。索引通过pid+vpn来哈希找offset 容易产生hash collision，用next字段来解决，一直next直到正确vpn 段页式内存管理：段表找页号，页表找pa 完整例子 usercode malloc userlib会管理内存池？？？ 如果有空间直接分配给app 如果没空间使用syssbrk申请扩展自己的内存池，os申请几片新的物理内存映射到自己的连续虚存然后分配给lib库 5-3 实践地址空间OS ch4 ASOS不同app统一entry addr app地址空间，有关联但不一定连续的逻辑段segment 跳板页app和kernel的跳板部分，VA相同，映射相同，放置trapS 特权级过渡时CPU到alltraps入口切换页表仍然平滑运行，包括restore也换页表但不影响正常运行 这时需要换页表和换栈，通过scratch中转什么？ 如果还是中转两个栈：则换栈之后，在app页表下查内核栈地址错误 中转用户栈和页表base：获取内核栈需要破坏genreg 用户栈/Trapctx：保存regs到ctx？？？需要看实现这里如何在用户地址空间查找ctx，读出内核页表base和traphandler，换页表并跳traphandler 应用地址空间linker的时候base0x10000 虚地址0x0开始text… 注意bss和stack中间有guard防止越界。最高4k是跳板，次高一页是自己的trapcontext，也就是trapctx在内核和用户空间都有映射。 内核地址空间页表中含有所有cpu能看到的内存 80000000-88000000除了内核代码和数据，剩下以页帧形式管理起来，随时分配回收采用连续内存动态分配，alloc SV39三级页表，每个节点在一个物理页中，即单个页表可以4k大小pte为8B下可以控制512个页，即1个页管理512页。两种映射方式，恒等和随机， TCB中保存： MemorySet地址空间 若干MapArea逻辑段 连续VPN范围 VPN-PPN映射kv，属于页表子集 映射类型，恒等or随机 此段的permission PageTable页表，该set中任何vpn对应的ppn的kv rootppn根节点物理页号 实际页表页… 以上set一共占用的位置：此管理结构属于内核数据（被PCB内管理），然后页表占用页+页表管理的已分配页。前者被pagetable释放，后者被maparea释放！ 新建set：创建页表，创建逻辑段向量。新建基本逻辑段压入页表：申请新页-更新页表项-更新maparea映射页帧 实现ASOS 创建内核地址空间、内核页表。但内核地址空间低的几块都是identical映射，涉及不到申请。 内核地址空间的控制数据结构set属于内核的全局数据段，保存在内核vadata也就是padata（identical） 空闲物理内存按照类似heap进行分配管理，？？？区分heap和frameallocator 这之前的操作是直接对物理地址进行操作的 启用内核地址空间即激活satp切换特权级时借助跳板来平滑切换地址空间和栈 跳板代码在全局pa的text段，但是在任何set中都是最高vpn虚页 sp切换到scratch即自己的次高页？Trapcontext 在此ctx中保存regs和status epc 读出kernel satp，va_sp和va_traphandler 切换地址空间，切换内核栈 跳转traphandler（物理页可能还在kernel的某个text段低位置） 此时如果call，因为alltraps和traphandler都在物理内存的text低段。被编译器直接优化为偏移量寻址pc自增。而此时va自增并不对，这里的pa和pa虽然间隔小可以offset寻址但是va相隔很大（text和跳板）Trapctx： 32gen regs status sepc 内核页表pa 需要写入satp app内核栈kernel va traphandler的入口kernel va内核态下sscratch存放的是上次从app切换过来的时候的用户set下用户栈，用户态下存放自己的次高页即traphandler TCB taskctx status memoryset trap context ppnTrap上下文的物理页？？？ base size应用数据大小？？？如何创建PCB即初始化app执行环境 根据elf构造基础的虚拟地址空间，在tcb memset中 建立内核栈？？？在哪建立 建立TCB 在用户地址空间构造Trap上下文？？？所以trapctx并不是在双空间都有映射，只在用户地址空间有。内核态想要访问需要去查用户页表 包括系统调用需要访问用户内存时，都要类似syswrite一样手动查页表找到物理页号，然后在内核页表中翻译为内核态虚地址。之后可以正常访问… Lect6 虚拟存储——虚拟内存和交换空间，缺页6-1 虚拟存储一开始是程序员手动or os以程序为单位自动 虚存：os以页为单位自动换，在小内存上运行很大的程序 覆盖技术：程序分为功能独立的程序段，不要求同时装入内存的程序段组成一组共享主存的同一块区域。常用代码数据常驻，可选的需要时装入，按需求覆盖替换原来的。以模块函数为单位 程序调用关系中，root是最常用的，一个path需要同时驻留——需要程序员划分定覆盖关系，太复杂。时间换空间，装入的时候更慢 交换技术 OS自动换，以程序为单位，整个set都换出换入。考虑时机（内存不足）and重定位（保证正确寻址即可）为swap分区+ 虚存的基础——程序具有局部性 时间：指令数据的多次访问，都集中在某段短时间内 空间：当前指令和一段时间内的指令or数据都在小区域内 分支：跳转的两次执行大概率跳到相同内存位置装载只装载当前指令需要的部分页面段；缺页缺段则os调入；暂时不用的保存到外存；——虚拟页虚拟段来实现 不连续，物理内存分配不连续；虚拟地址空间使用不连续？？？ 用户空间大与实际物理内存 部分交换：只对部分虚拟地址空间调换在页式管理基础上： 装载只装部分页面就启动，需要才调入 需要但不在内存时候发起缺页异常（页表无效）——os调入内存使继续运行 OS查找外存对应内容 物理页有空闲则直接调入 否则用置换算法换出，valid0的ppn为外存的地址 修改页表为有效以及对应物理页映射 返回app重新执行异常指令 内存不足时把部分页换出（页面置换）EAT 有效存储访问时间 = 不缺页率访存t + 缺页率访盘时间（1+写回概率即替换概率，缺页还需要先换出的时候） 6-2 局部页面置换 当前进程的物理页减少换入换出 减少缺页 短期不用的调出，规定空闲内存上下限 下限开始回收，上限停止回收。 frame locking常驻内存的逻辑页，OS关键|要求速度的代码数据|页表中lock bit OPTtar 未来最长时间内不访问的页面； imple 缺页时计算内存逻辑页的下一次访问时间 analysis 理想 不能实现 无法预测 FIFO内存驻留最长被替换 维护内存逻辑页链表即队列，排着进排着出 简单；性能差（调出很经常的）；分配物理页多但缺页不减少（belady小聪明大糊涂）；不怎么用 LRU 最近许久没用记录上一次访问时间，近似最优 维护一个最近一次访问的链表，首节点是刚使用的。每次访存都移动到链表头；开销大 活动页面栈：访问时压入并弹出所有同页号的，栈底为最少访问，开销大 Clock时钟页面置换大致统计访问，是fifo和lru的折中 不调整但做标记，不访问的像LRU一样 imple pte中有acess访问位，页面成环形链表，指针指向最早调入的页面；访问的时候标记access，缺页替换从指针开始查找未被访问的页面，把访问位重置并挪动指针直到找到0的就换，指针也往前挪一个。 改进时钟置换减少修改页的缺页开销，增加dirty修改位，描述写情况。因为dirty位需要写回。dirty了一定access了。这里描述有大问题 即保护a1d1的页面两轮才被置换： a0d0立即置换标记10，指针后移 a1d0 - a0d0 a1d1 - a0d1 - a0d0 LFU最不常用置换置换访问次数最少的 实现访问计数，访问+1，查找最小计数 开销大；开始狂用后面不用的页很难换；LRU关注时间 LFU关注次数 BeladyFIFO与动态特征矛盾，被换出去不一定是近期不用的 LRU动态调整，不存在belady 6-3 全局页面置换 所有可换出的物理页为进程分配可变数目的物理页：进程对内存的需求动态变化；分配给进程的内存也应该变化；全局置换要确定分配给进程的物理页数目 程序运行和cpu利用是反对钩 工作集算法W(t, △) 当前时间和工作集窗口（往前的窗口时间长度，τ为访存次数比如10就往前倒10次访存的逻辑页） 常驻集：实际驻留内存的页面集合 工作集是固有性质，常驻集取决于os分配和置换算法。 工作集是常驻的子集时缺页少；工作集过渡期缺页多；常驻集达到一定数目后缺页率不会明显下降 换出不在工作集中的页面——维护窗口内访存页链表：访存和缺页置换都更新，也就是记录τ次访问的逻辑页，其他都被换出了 缺页率算法缺页/访存 or 缺页间隔时间的倒数 看缺页率来调整进程常驻集，可以用缺页间隔T 访存设置访问标志即access1 缺页时计算上次到这次的缺页间隔，如果大于窗口则只保留last到current闭区间内访问过的页 如果小于等于窗口，则增加缺页到常驻集，直接加页 抖动问题物理页太少不能包含工作集，大量缺页频繁置换，巨慢——因为进程太多物理页不够 高并发和缺页率平衡tradeoff Lect7 16-207-1 进程管理提高开发和执行效率——用户请求来创建执行暂停停止app——刻画os中程序运行的动态规律and管理调度多个程序的执行和资源使用 进程抽象给app：独占cpu，独占addr 资源占用和执行过程 一个程序的执行过程or执行程序的实例；具有一定独立功能的程序在某数据集合上的一次执行和资源使用的动态过程。。。 和Task的不同：simple process is task 进程在过程中创建子进程fork waitpid getpid、用新程序内容覆盖已有内容（加载执行）exec 执行中申请、使用、释放资源的载体进程控制块PCB 进程上下文 trap上下文 任务上下文 地址空间管理 进程内核栈 进程id progress status 父子关系 退出码os结构： forkexec helloworld user_shell（输入forkexec helloworld？） initproc（fork+exec shell waitpid等待shell） OS Kernelfork：复制老爹的所有变量和内存，地址空间，赋值所有寄存器除了 wait属于系统调用，主动放弃处理器并返回子进程exit的值。os处理当有自己成存活时父进程主动放弃，等待结果。子进程exit后唤醒父进程返回给wait 僵尸：exit了但是没被父进程wait回收，wait时会立即返回 孤儿：父进程先退出没人回收了，由root回收 exit释放大部分资源但保留结果的值，检查父进程是否存活，如果没存活定位root父亲变孤儿，否则变僵尸 nice调用指定初始优先级，优先级会随时间降低 ptrace一个控制另一个进程执行，设置breakpoint，查看reg等 sleep的实现？？？ 创建 就绪 运行 等待（sleep和wait） 退出五大状态转换 fork开销大，大部分伴随exec所以复制意义不大——vfork轻量fork让子进程赶紧exec 7-2 单处理器调度算法处理机调度 调度器：挑选就绪队列中进程的内核函数，依据什么准则？ 何时调度？ 进程运行到等待or就绪 进程被kill 进程主动放弃 中断响应完成比较不同调度算法：一般低延迟-高带宽的tradeoff CPU使用率 吞吐量（单位时间完成进程数） 周转时间：进程从初始化到结束（包括等待）的总时间 就绪等待时间：就绪进程在队列中的总时间——高带宽 响应时间：提交请求到响应的总时间（时间和波动） 公平：进程占用等量的资源 先来先服务FCFS进入就绪状态排列成队列，就绪队列下一个进程得到cpu， 指标是周转时间时，明显发现大任务堵在前面平均周转时间变长 简单 平均等待的波动大；短作业排在长进程后面很亏；IO资源和cpu资源利用率低（cpu密集进程导致io_idle也等待） 短作业优先调度SJF选择队列执行时间最短的进程占用cpu，按照时间升序排序 好：最短平均周转时间！ 坏：饥饿不公平，大任务无法获得资源；需要预知未来即任务规模，最简单就直接问用户，不能骗我否则kill你；历史预测：之前n次运行的加权平均，n次时间权重a之后每个都乘1-a的权重….其实是n次时间和上次预估的加权平这图没道理啊 最短剩余时间SRT支持抢占 如果新就绪进程服务时间小于当前剩余时间就转 最高响应比优先算法HRRN高响应比 7-3 实时调度7-4 实践 进程操作系统？？？ 用户态能执行哪些特权级指令？能禁用中断or异常吗 软件中断是什么？ Lab1 20-22 ch2batch 在batch时候内核和用户栈是唯一的，都在kernel的bss部分互相换 ch3多道 每个应用都有自己的内核栈和用户栈了… Lab2 22-24ch4 数据段只存elf，需要load的时候申请物理页创造应用的memoryset 用户程序加载的时候创建app memset时候把elf里面的section都申请并映射了出来，同时申请创建了用户栈，申请创建了TrapCTX专用的页？创建后返回这个地址空间，返回用户栈以及入口地址用来创建PCB 在trapCTX加入 kernel_satp 表示内核地址空间的 token ； kernel_sp 表示当前应用在内核地址空间中的内核栈栈顶的虚拟地址； trap_handler 表示内核中 trap handler 入口点的虚拟地址。 用户栈&lt;-&gt;TrapContext的虚地址 traps 取得TrapCtx虚地址，开存所有regs和sepc status 获取satp 内核handler 换内核栈，换地址空间（刷TLB），jr handler restore（参数为用户trapctx的虚地址次高页+用户地址usersatp） 换用户空间，刷TLB 写入scratch为Trapctx虚地址 sp = trapctx开始回复寄存器 恢复用户栈 sretPCB： taskstatus taskctx regs，ra，内核栈 地址空间 trapctxppn物理页号 应用数据大小 写Lab看课件Ch9 文件系统9-1 文件和文件系统unix文件系统ufs语义： 对打开文件的写入内容，立即对打开文件的其他用户可见。共享文件指针允许多用户同时读取写入 打开文件的维护： 进程级文件描述符表，非负整数获得文件指针。指针中是最近读写位置（文件偏移量） 系统级，当前所有打开的文件表。 打开计数，为0后系统关闭 文件偏移量 状态标志 系统fs级，inode表 指向具体文件内容文件系统：命名，存储（分配、管理、安全、可靠），检索 目录文件特殊文件，数据中包括文件索引表和指向文件的指针 硬链接，多个相同文件项（inode）指向相同数据块 软链接，只存文件名，需要找一遍索引 9-2 文件系统设计实现虚拟文件系统在高层下面可以挂载不同文件系统甚至remote。抽象出所有文件系统相同通用接口。 文件系统的存储： superblock超级块，文件卷控制块。整个文件系统的信息，块大小，剩余块数，block和inode总量等等。挂载，写入，检验等等 inode/dnode bitmap Inode 的占用情况 vnode inode 128B文件控制块，大小，数据块指针。访问控制（群组用户rwx）各种时间信息 dir entry 目录项，在内存中缓存来表示目录，把目录项编码为树形结构 父目录 子目录和文件表，指向他们的inode /home?? 指向自己的inode datablock 4KB数据块 目录的数据块 目录内的东西，给一群inode… 注：文件名在目录的datablock 虚拟页式存储，把文件数据块映射为内存页，直接访问内存即可。 分配方式连续分配 文件头指定起始数据块和长度然后往后写（最先 最佳 最差…高效的顺序和随机读） 碎片多，append开销巨大 链分配 容易创建增加缩小，几乎没碎片；随机访问低效需要循过去。破坏一点后面全丢。inode存头尾块，中间在dnode用指针连 显式连接：直接搞一个FAT文件分配表，连接物理块的指针放在表里常驻内存。根据数据块查到下一块。支持随机访问？？？只需记录文件的起始块 隐式：数据块保存下一块的指针。记录头尾块索引分配：文件头包含索引数据块指针，可以随机访问但是索引开销可能很大（对于大量小文件）。巨大文件可以链式索引inode或者多级inode索引.. 多级索引下，每个Inode可以搞10个dnode加1个一级索引inode 一个2级索引 一个三级索引，再往下… 磁盘分区分卷之后，每个区有独立文件系统 9-3 崩溃一致性的文件系统dbitmap inode dblock三个都要写，崩溃后写一部分 fsck 文件检查，重启的时候修复 检查超级块，超级块多副本。如果不合理可以启用备份回复 扫描位图和inode 的一致性，不一致更信任inode。看起来像是在用的inode一定标记ibitmap 检查inode内的损坏，如果可疑就被清除并更新inode位图 inode链接计数，检查特定文件的引用链接数量 从root开始扫描目录树并为文件系统中每个文件和目录构建链接计数。 如果与inode不一致通常修复inode 如果已分配但没引用则移动到lost found 重复inode，清楚错误inode 检查坏块指针。比如某个指针明显超过有效范围 目录检查，目录的.和..都置顶。每个inode已分配，目录引用不能2次及以上fsck太慢了，可能丢东西 日志文件系统WAL 预写日志，先写点注释。崩溃后查看注释可以重试 开始符号，Inode更新信息，bitmap更新信息，db信息，结束符号 写日志要注意先不写TXB结束符write，等事务内容写入后再写TXEcommit。然后写真数据checkpoint 优化维护日志的超级快journal superblock 批处理更新日志 有限的循环日志一段时间后free日志 正常日志包含元数据和db，如果只记录元数据呢？要求先写data 元数据日志什么时候写入Db？ Data write Journal metadata write journal commit checkpoint metadata free Ch10 进程间通信10-2 支持IPC的OS扩展文件抽象引入Pipe，文件形式交换 0607-0613 Final ReviewLect7 进程管理与单处理器调度 6.77-1 进程管理需求： 动态交互控制 需要命令行和图形界面 提供给程序：控制和数据的独立抽象，独占cpu和内存 包括数据结构+动态操作数据结构，是程序占用资源的集合 进程相对任务的进步：创建子进程、覆盖内容、动态申请释放资源 fork 除了a0之外的所有寄存器和内存、变量 exec exit 释放文件、内存等资源但保留大部分进程相关的数据结构检查父亲存活情况 waitpid / wait getpid nice优先级 ptrace一个进程控制另一个的执行，设置断点与查看寄存器 僵尸进程 孩子exit父亲没有wait 孤儿 父亲先exit孩子由root回收 PCB进程上下文：Trapctx Taskctxmemset 内核栈 状态，父子关系，退出码 下图？？ Processor 有一个 idle 控制流，功能是尝试从任务管理器中选出一个任务来在当前 CPU 核上执行，有自己的CPU启动内核栈上 initproc pid0初始化然后fork exec shell为pid1 进程切换：暂停当前运行进程，调度另一个进程从ready到running，也需要保存恢复上下文 进程状态：创建、就绪、运行、等待wait 不在就绪队列中、退出 fork思考fork的内存复制与fd传递——无用，孩子大部分会exec vfork 轻量级，不复制内存，子进程尽快exec COW fork是事故发明，只有unix还在用并且很长一段时间会用 7-2 单处理器调度挑出下一个占用cpu的进程，挑出使用的cpu 使用率、吞吐量、周转时间（初始化~结束）、就绪等待时间、响应时间、公平 低延迟vs高带宽 FCFS 先来（就绪）排前面的得到服务 公平；简单 波动大；短任务排后面；IO与cpu利用率低（一个密集另一个idle）；平均等待很长（后来就得等） SJF 选最短的 最优平均周转；最优平均等待 大任务饥饿；需精确预知未来困难（询问、欺骗、历史估计。某次估计值等于上次实际值和上次估计值的加权平均） SRT 抢占）最短剩余时间，最快能干完剩下的工作量 改进SJF 但仍饥饿 HRRN 最高响应比优先 是FCFS+SJF 基于SJF，不可抢占 响应比 = w+s / s RR 时间片轮转 辅以其他算法切换进程默认FCFS，每次等待n-1个片 开销大（上下文切换）；时间片过长为FCFS；太小产生大量切换开销；开销1%以内 公平但等的太长 多级队列调度MQ 一堆子队列，同优先级在同队列，每个队列有单独调度方案如前台进程RR后台FCFS。队列间固定优先级（先前台，饿死后台）非均匀RR 高优先级运行，同优先级公平轮转RRorFCFS 多级反馈队列MLFQ 不预知外来但优化周转，降低响应。知识不完备——学习历史 先进最高优先级，时间片结束后降级但中间主动yield不降级（若干次yield后用光也降级）；高级队列时间片小（高级对延迟敏感，低级为慢慢算）；每隔一段时间重新加入最高优先级 cpu密集迅速下降 IO密集持续高优先 CPU密集饥饿，恶意留高优先级 FSS 公平共享调度 控制用户访问系统资源，按用户优先级分配，垃圾用户不垄断，未使用的资源按比例分。 7-3 实时调度实时操作系统：正确性依赖于其时间和功能两方面——实时响应处理外界事件数据、并反作用与生产过程。比如测控、机床 性能最重要是及时，速度和平均吞吐不重要， 特性：时间约束可预测，约束是可预测的，几秒内完成转弯？ 强、硬实时——必须在ddl内完成 周期实时任务：周期p请求 e时间完成 静态：执行时优先级不改变 静态 抢占 速率单调调度 RM Rate Monotonic 周期安排优先级，周期短优先（频率高优先） 有的任务会错过期限！本来能完成被不紧要的任务耽误 动态 最早截止时间 EDF DDL早优先 优先级高一定被先执行？延误！共享资源被占用需先干完一个 动态 最低松弛度优先LLF 任务紧急松弛程度，紧急的优先级高。加入干了多少的概念 松弛 = DDL - 仍需 - 当前 即 相对剩余 - 仍需。假设这个完成能剩下多少时间给别人，剩不下的优先 优先级反置基于优先级的可抢占：高优先级长时间等待低优先级现象 3占用S 1在运行时申请S被挂起 2开始疯狂运行。。。 最低优先级早早占上共享资源导致高优先级拿不到，但最低级的运行机会少导致高优先级一直被挂起，共享资源迟迟不释放 优先级继承占共享资源的低优先级进程继承申请自愿的高优先级进程的优先级。即高优先级因资源被阻塞时候，给占用者高prio 优先级天花板协议占用资源的优先级 = ceiling/max（所有可能申请的进程prio，“可能”不管是否block都提升其优先级） 只要高于所有锁定资源的prio上限，任务甚至不会被阻塞！希望临界区快点释放所以优先级最高 7-4 Lab3 实践对os来说进程是应用程序的一次执行过程（示例），拥有资源 loader分析linkapp.S，用全局只读向量APPNAMES顺序保存了所有app的名字，供exec使用 fork 建立新页表复制地址空间 创建新Trap CTX 内核栈 Task CTX 父子关系 设置fork返回a0 suspend_current_and_run_next 正常放弃、切换被调度出去 Lect8 多处理器调度 6.78-1 对称多处理与多核架构多处理机器超线程 CPU内闲置资源充分调动，寄存器、程序计数器独立，算数计算硬件共用。比如可以同时运行整数运算+浮点运算。 多核处理 纯纯多RF 多ALU 同bus cache一致性SMP or UMA 所有cpu共享bus对资源的访问资格相同、地位相同，访问同一mem 内存冲突多 CPU浪费 NUMA架构 非一致内存访问 多个node，node有自己独立的内存空间，node内共bus 共mem 访问远节点更慢 cpu独有cache 通过监控内存访问来嗅探 作废自己或更新自己 8-2 多处理器调度概述SQMS 单队列多处理器调度复用queue，轮着喂core即可 可扩展性差：cpu多需要调度程序上锁的原子操作，锁和缓存争用增加 缓存亲和性：1在1工作下次被调度到2上工作… 4cpu5任务模型 MQMS 多队列多处理器调度多个不同规则的调度队列 加入时按启发规则放入某个调度队列 cpu调度独立 可扩展：cpu多队列多，锁征用无关 缓存亲和好 负载不均？——支持进程迁移。进程反复横跳？进程少的队列偷看其他队列，显著更多的时候就偷一些过来 8-3 Linux O1调度调度器考虑：数据结构、进程运行时间、判断进程类型、动态优先级、适配多处理器 On调度器遍历整个链表队列，一个大锁Global runnable queue 各个core竞争使用 分成时间片epoch 计算进程动态优先级；进程优先级映射为缺省时间片；选择最高优先级 被调度后不受打扰的运行该epoch 如果没用完，剩下的增加到进程的下一片中进程多性能降低，竞争访问同一个queue没有scalability O1调度器per cpu runnable queue 全局优先级 实时进程0-99 普通100-139 有active 和 expired 数组；一共140种优先级 用长度140bitarray表示这个优先级队列下面有进程，找位图中最高位1的bit即可即leftmost bit；每个优先级都对应一个FIFO queue，新来的插入队尾 pull： 找到最高位对应的x位置 在APA活跃数组找到对应队列APA【x】并pop出一个进程时间片耗尽后push： 执行完的进程计算优先级放入EPA【y】的队列，检查这个expired bitarray如需要置1 如果active bit array全0则和expired bitarray互换多核SMP支持 周期性分析cpu负载，负载轻的多pull拉取新的而不是push扔回去旧的 8-4 Linux CFS调度 Completely Fair Scheduler划分每个调度周期确定的固定时间片，结束被重新分配epoch O1本质是MLFQ 根据进程运行判断是计算orIO密集再奖励or惩罚——动态时间片，每次调度的时间片都变化 每个进程nice值，共40等级每个差10%是静态prio 把CPU视为资源，记录进程使用情况——调度时调度器选择消耗资源最少的运行 按照权重分配CPU资源 运行时间 = 调度周期 * 进程权重 / 所有进程权重和 周期：所有running态都调度一遍的时间 后面是权重占比 虚拟时间vruntime：记录进程已经运行的时间 vruntime = 实际运行 * 1024 / 权重 = 调度周期 * 进程权重 / 所有进程权重和 * 1024 / 权重 = 调度周期 * 1024 / 所有进程权重和 nice0的标准权重1024，从[-20,20) nice正的进程vruntime是缩小实际时间的 所以vruntime在所有进程都相同，与权重无关。实际运行不一致但在vruntime下是完全公平的。 vruntime较小占用太短，下一个选他运行 CFS实现红黑树记录vruntime，多核的就多个红黑树，找最小的vruntime节点即logN 40个nice对应权重，大nice小权重，有prio_to_weight转换 新权重的vruntime？为0则狂跑不公平 维护min_vruntime 新进程的值 休眠进程？休眠进程以min再给予补偿；休眠后有能力抢占cpu是大概率且符合目标，交互式进程等待用户输入总休眠，然后快速响应 主动休眠进程也有补偿但不要求快速响应，如果总抢占影响整体性能。WAKEUP_PREEMPT标识标识禁用唤醒抢占 进程cpu迁移？每个cpu的min vruntime不同，作为自己的基准值。出来的时候减自己然后加上另一个core的基准值 uint32溢出回0？比较的时候同时减去某个数再比，让0的回到那个大数 8-5 Linux FressBSD BFS调度Brain Fuck Scheduler 脑残调度器 RR变种 多处理机共享一个就绪队列（双向链表）增加互斥访问开销但减少负载均衡开销 103个prio：100个静态实时优先 3个普通优先级（交互、普通、低优先） 按优先级排队，同优先级的每个进程有时间片长度和虚拟截止时间 固定时间片默认6ms，找虚拟截止VDDL。进程等待长这个ddl就早 时间片用尽后重新计算截止时间后插入队列 事件等待结束后vddl不变以抢占，or插入就绪队列 亲和：不同cpu的vddl加一个权重 VDDL = 当前时间niffies + rr_interval * prioratio[prio] * scaling factor nice小 prioratio小 VDDL早 使用O1的bitarray有103个queue。如果queue bit 1则遍历queue找vddl最小的在核少时效果不错 Lect9 文件系统 6.89-1 文件和文件系统文件系统存储设备上组织文件的方法和数据结构 一切皆文件，字符设备，网络也都是文件，统一接口 读文件：数据块内对应部分 写文件：获取数据块，修改并写回 数据块是基本操作单位 用户|组|所有人 RWX Unix FS：对打开的文件写入，立即对其他打开同文件用户可见，共享文件指针允许多用户同时读取和写入 UFS中进程有文件描述符表，然后所有进程共享系统文件表。只有先打开文件再fork的会文件偏移量指针。其他情况都出现覆盖（独立的偏移量）？？ 文件描述符 VFS虚拟文件系统，抽象统一接口下面是一堆其他fs和其他IO驱动 分层文件系统：目录是特殊的文件，存文件索引表&lt;文件名 - 指向文件的指针&gt; 指向inode吗？ 目录实现线性表太慢；哈希表？有冲突 链接 硬 多个文件项指向同一个inode！别名！ 软 存储名称然后现解析目录循环？允许链接文件但不允许链接子目录，增加链接时用检测算法 9-2 文件系统设计与实现inode叫索引节点 数据块中有目录项有传统文件项 层级：硬盘驱动 实际文件系统 虚拟文件系统 内核抽象 用户库 用户程序 数据结构超级块文件系统信息，块大小，剩余块，block总量inode总量挂载时间，最近a w fsck检验的时间 Inode | DataBlock Bitmap i d的使用情况，用来分配 128B索引节点Inodes大小 位置 管理若干db，访问控制，拥有群组|用户，时间信息，链接数，文件名在目录的db 数据块4KB？？在我们的easyfs中：目录项、正常文件项 目录数据块固定有. ..的inode号，然后一堆文件名hash值与inode号，每一项叫dir_entry。就是文件名+inode号 文件缓存 可能预读 读过的块被缓存，写操作可能被缓存和延时写入 页式缓存: 统一缓存数据块和内存页。在应用地址虚拟空间中，虚拟页面映射到本地的外存中。即一个虚拟页对应外存，需要时和主存对换上来。页置换需要考虑虚拟存储和页缓存 fd table - sys open file table - inode 文件分配连续 策略；高效的顺序和随机读 碎片多 写开销大 链式容易增删改；没碎片；随机访问慢；依赖强，一个坏后全坏 隐链接：inode存第一个和最后一个块号，数据块每个末尾向后指针 显链接：FAT表，每个块一项对应下一块号索引inode指向文件头，头块为索引块指各个后续数据块指针。增删容易；几乎没碎片；随机访问也行；文件小的时候索引开销太大！ 链式索引，索引块之间链表 多级索引，索引块分级 inode直接指：直接索引 指向索引块再指向数据：1级间接索引 找空闲块扫描数目： 总数/空闲块 操作最终以写inode结尾！ 5次已有open 读到inode即可，不写 3次read 读inode 读dnode 写inode 创建open 读到目录项之后，读inode bitmap 然后写ibitmap 写inode 写目录项 写目录项inode，共写四个东西，此时未分配dnode write 读写dbitmap 分区多个分区，有独立的文件系统 9-3 支持崩溃一致性的文件系统需要原子性的状态变迁 但硬盘一次提交一个写入，更新间可能断电 write本来也被os延迟在内存，必要时才写磁盘 新加dnode场景需要write三个，崩溃场景讨论： only dnode 没人管理 找不到 未曾写入 only inode 读dnode的垃圾数据 only dmap 空间泄露，占用但没人管理 dmap &amp; inode 垃圾数据 inode dnode 和位图不一致导致被覆盖等 dmap dnode 无人管理 fsck fscheck发生不一致然后重启后修复，慢的一比也可能丢数据 检查superblock，是否启用备用老版本块 imap inode一致性检查，信任inode 检查inode是否损坏，inode如果无法修复则删除，更新imap 链接计数检查，从头计数修复indoe。如果计数为0移动到lost found目录 重复inode指针，两个inode引用同一个块：明显错误 坏块（坏指针）检查，超出自己的有效范围则删除 目录检查，。和。。都在前面，引用的inode已经分配。目录引用小于等于一次 日志文件系统WAL | journaling 注记指示如何恢复错误，增加更新工作量，大大减小恢复工作 Data journaling TxB开始 Inode更新 Dmap更新 Dblock更新 TxE结束 先写数据日志，然后写真实数据，但注意TxE标识日志项的完结，所以需要检查前面写完成才发出最终TxE Commit。即TxE一定是最终安全状态的日志 1 写日志 2 提交日志 3 checkpoint写真正更新内容（先data再metadata） 在3崩溃会导致W太多慢 日志优化 journal superblock 单独存储、批处理日志更新、循环日志回收复用 加一个4free 更新日记账，标记为空闲 Metadata Journaling 仅包含元数据的日志记录，不包含dnode （ordered mode）1 datawrite 2 journal metadata write 3 commit 4 checkpoint metadata 5 free 先写数据块保证永远不指向垃圾，数据块在日志提交前写入。 writeback mode 不保证顺序，快 9-4 Lab4 FSOS 霸王龙OSuserapp userlib userfs?? kernel_syscall VFS EasyFS syscall OSInode VFS easyfs BlockCache BlockDrive fdtable是OSInode数据 OSInode对操作系统的Inode最高层抽象，可读可写标识和偏移位置、下层Inode Inode DiskInode getblockid获取自己的第blockid个数据块编号 size 直接索引 一级间接索引 二级间接索引BlockCache 512B字节缓存，某个blockid，记录脏位 Lect10 进程间通信 6.8-6.910-1 IPC概述共享内存是直接通信不需要通过内核 管道 消息队列 信号 套接字 文件 都是间接通信 缓冲方式：无限buffer发送方不等；有限链路缓冲队列满了就不能发；0容量无缓冲，发送方必须等待接收方接受 匿名管道有方向有大小的字节队列，不同fd表示，读写分别的fd+一段内核空间内存，单向通信！ 仅支持有关系的进程通信，比如父子兄弟，父进程创建管道子进程继承fd后执行。一般约定两进程各关闭一个fd mkfifo创建命名管道（阻塞单向），支持任何两个进程。然后用open打开，同时有读打开和写打开才会正常工作 任何一方可读写，半双工？需要读写同时打开命名管道才能写入和读取 消息队列FIFO规则的结构化数据的队列，有专门类型标识 按照类型标识划分队列，同类同队 ftok，通过进程PID获得唯一标识，消息队列名字key msgget通过key flag尝试获取队列标识符msgid，创建消息队列 msgsnd通过标识符msgid发送数据，flg控制。msg前面要有4B的type字段，size不包含这个type msgrcv type可以简单接受，0队列第一条 &gt;0消息等于type的消息 &lt;0 小于等于abstype .msgctl可以溶质删除 共享内存快速方便但需要同步机制 ftok() shmget创建key size flg返回shm id shmat映射到进程空间，可以手动指定地址，返回一个指向该共享空间的指针 shmdt取消映射 shmctl控制 信号signal 异步通知B在内核注册信号（主要是注册信号处理函数） A给B发送信号内核中转，在返回用户栈前发现有信号处理，压入用户栈sighandler，修改返回地址。 B返回用户态直接跳到handler处理中断处理信号 ，handler返回到B恢复中断继续 KILL(pid_t signal_id) 是发送信号的 SIGKILL 内核杀进程 SIGPIPE 读管道出错，读关闭fd SIGINT ctrl C终止外设中断 SIGHUP 断开shell连接 SIGQUIT 产生core的错误退出 SIGABRT abort函数 10-2 IPCOS实践扩展文件抽象：Pipe，Stdout, Stdin pipe、signal是进程控制块的资源 pipe设计实现基于文件抽象 维护在PipeRingBuffer Pipe是？？ exec修改为可以获取args，a0指示参数个数argc，a1是argv[0]的栈上地址 sys_dup 重定向，纯纯分配新fd然后复制文件描述符 对A|B ？？ 信号设计实现sigaction 设置信号处理程序？？读一读 信号，新老action*，oldaction是用来送回去的。 signalaction包含handler地址和信号掩码sigprocmask 设置阻止？？的信号 kill 发送信号 sigreturn 清除堆栈从信号处理func返回 TCB中含 signals 等待响应信号 mask屏蔽信号 正在处理的信号 信号处理表，各个信号跳哪里，一堆action bool杀死 bool冰冻 打断的backup trapctx Lect11 线程与协程（协程不考）6.911-1 线程进程难以并发；难IPC，地址隔离；还是粒度太大——将程序分解成可并行运行的多个顺序控制流，多条控制流一起。性能高，共享数据方便，管理方便 对比进程： 线程是cpu调度单位，独享寄存器和栈；拥有就绪 阻塞 执行基本状态；减少并发的开销；共享地址空间和文件（堆共享）；C系一个线程崩溃进程崩溃。。。 线程概念进程用来分配资源；线程用来调度执行； pthread_create(pthread_t , const attr, void start从哪开始,void *传参)成功ret0， pthread_join pid，**retval 线程设计实现实现方式 用户态管理用户态运行，内核不可见、绿色、有栈、纤线程，内核空间只有PCB。用户级的线程库函数完成管理。 控制简单，内核无要求，控制开销小，允许进程自定义线程调度灵活，线程利用的表空间和堆栈更多，只有一个线程能运行 线程仍然会单阻塞；不支持抢占；按进程分配时间；多处理机下线程只能时分复用没有真正并行 内核态管理用户态运行，内核可见 内核系统调用实现，维护内核TCB，单线程不阻塞其他线程。Linux单进程只有单线程，Win core都支持多线程 线程切换开销大类似进程切换；传统进程管理矛盾如fork 多线程fork： race condition 共享资源变量，同时写同一个文件？ 死锁，子进程无法获得锁。fork只复制某个线程时，等待锁而死 内存占用，子进程复制父进程相同的内存、寄存器等 性能巨慢，大量子进程时 内核态管理内核态运行，内核线程 Linux内核线程，内核的分身，维护PCB等，常并行处理周期性任务BufferCache定期写回；虚页交换；FS事务日志 混合管理运行，混合线程，轻量进程LWP 一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持——像独立进程一样享有专门的中断！ 与用户线程关系，用户线程由用户线程管理库管理，内核只识别内核线程|进程调度 与用户线程管理库交互 1：1 Linux JVM 用户态不管理，内核管理 N：1 多个用户线程，内核态管理包含多线程的进程；用户态线程运行时管理线程 与OS无关的Green Thread M:N 协同管理 Solaris OS, Go runtime 最灵活最复杂同进程内线程上下文切换，虚拟内存共享，只切换私有资源 11-2 协程 stackless 是普通函数的泛化类似用户线程，操作系统不可见，随意切换的多个执行点？即协程函数中间可以随时yield来正常执行其他函数，等IO阻塞结束后切回来？ 进程：页表，堆，栈，寄存器 线程：栈，寄存器 协程：寄存器，不换栈 大规模并发IO下：大量线程占内存总量大 管理开销大 共享数据易错 异步函数 相比普通函数，协程的函数体可以挂起并在任意时刻恢复执行，是普通函数的泛化 与线程 内存小，多线程下明显；不需要锁，没有写冲突，只需判断状态，高效 协程的核心思想：控制流的主动让出与恢复 11-3 实践用户态管理的用户线程，类似老的简略TCB 有pid stack taskctx state等 state Available特指tcb没用了？？, Running, Ready, Runtime？？::new 多线程找RUNTIME全局量获取线程相关数据 设置主线程running 设置调度队列 设置当前线程id 0调用spawn创建新用户线程 查找TCB有无available的控制块，初始化其上下文 x1为老返回地址guard函数——意味着f已经返回，线程已经完成，标注available nx1新返回地址 f x2新栈地址runtime.t_yield 切换线程 找一个ready，把状态改掉，current改掉 调用switch 切换pc 换栈 换regs线程|进程资源回收？？cyk bilibili 子线程退出 主线程waitpid回收 清空PCB 全部清空线程资源 主线程退出，进程回收创建线程 用户、内核栈 跳板页 线程上下文 Lect12 同步互斥 6.1012-1 同步互斥概述临界区：进入section 临界section需要互斥的代码 退出sec 剩余sec 等待进入临界区的线程不能无限期等待 不能进入临界区的线程，应释放CPU（如转换到阻塞状态） 禁用硬件中断 没有打断，没有并发，延迟处理到启用之后。 线程无法停止，其他饥饿，临界区很长，不适多核 基于软件 全局变量控制，如果某个不需要进入则无法给后面创造 两个flag——全卡or全进 peterson turn+flag，我进了flag，该你了。等待条件是该他且他进了 dekkers N线程：turn和N个flags 更高级抽象 锁 原子操作TestandSet TAS来lock Compare and Swap 如果是old就换ret true否则不换ret false 用CAS改共享变量存在ABA问题，即被改了多次恰巧满足原来条件——增加版本号 12-2 信号量P为减少，可能阻塞。默认有wait queue 对应生产者消费者问题，单个时刻只有一个生产、消费者访问缓存区。空时等生产；满了等消费； 用信号量描述每个约束 二进制信号量mutex 二进制信号量 计数信号量fullBuffers 0 计数信号量emptyBuffers n 评价 忘记占用信号 忘记释放 死锁 12-3 管程与条件变量条件变量配合mutex 管程不好读，不好改，正确性难；死锁——面向对象的程序结构，任何时刻最多一个线程执行管程代码 模块化，是基本程序单位 有数据有代码，特殊的数据类型 半透明管程中的共享变量在管程外部是不可见的 管程操作：进入enter, 离开leave, 等待wait, 唤醒signal 入口等待队列：只有一个线程能在管程中 条件等待队列：为资源占用等待 紧急等待队列：唤醒使用，T1唤醒T2转移访问权限？T1挂起进入紧急等待队列，优先于条件变量等待队列T.enter过程：线程T在进入管程之前要获得互斥访问权(lock) T.leave过程：当线程T离开管程时，如果紧急队列不为空，唤醒紧急队列中的线程，并将T所持锁赋予唤醒的线程；如果紧急队列为空，释放lock，唤醒入口等待队列某个线程 T.wait(c)：1)阻塞线程T自己，将T自己挂到条件变量c的等待队列； 2)释放所持锁； 3)唤醒入口等待队列的一个或者多个线程； T.signal(c)：1)把条件变量c的等待队列某个线程唤醒； 被唤醒的先执行 Hoare T1 进入管程monitor T1 等待资源 (进入等待队列wait queue) T2 进入管程monitor T2 资源可用 ，通知T1恢复执行， 并把自己转移到紧急等待队列 T1 重新进入管程monitor并执行 T1 离开monitor T2 重新进入管程monitor并执行 T2 离开管程monitor 其他在entry queue中的线程通过竞争 进入管程monitor 唤醒者先执行 Mesa重新竞争访问权限真实os java Hansen2)把线程T所持lock给被唤醒的线程； 3)把线程T自己挂在紧急等待队列 12-4 同步互斥实例哲学家就餐 直观用信号量，在就餐前尝试拿左右叉子？——死锁 拿叉子前用mutex锁上，然后尝试——每次只有一个人吃 奇偶分左右，避免死锁 and型信号量，两个叉子都在才能进餐——一个原语中申请整段代码需要的多个临界资源 没有死锁 最大并行度 饥饿是试图拿叉子的状态 读者写者问题 信号量方案 设置读写互斥mutex和读者计数变量，以及读者计数互斥修改——读者优先 管程 Condition okToRead okToWrite 活跃and等待的读写者数量 12-5 死锁可重用资源（Reusable Resource） 一个线程使用，释放后立即其他重用——死锁：占用一部分请求其他资源 可消耗资源：中断信号消息等；互相等对方的消息 死锁条件：互斥；持有等待；非抢占（只能自愿释放）；循环等待 预防：不会进入 破坏互斥；只有同时获得才分配，不许先分配（） 释放原有资源；按顺序请求资源 避免：只允许不死锁进程请求 声明最大数目；限制资源数量；动态检查分配状态 检测恢复 通常OS忽略死锁，app负责 Rcore银行家？？ 12-6 Lab5 实践总结内容进程控制块PCB pidhandle //kernel_stack inner: trap ctx ppn user stack sp(base_size) task ctx task status memory set parent children exit code //tasks //task_res_allocator RecycleAllocator 通用分配器分配PID和Kstack线程控制块TCB process 弱连接PCB kstack 线程内核栈 inner Task User res 线程用户态资源？？ trap ppn task ctx task status exit code 所有资源与回收总结 PCB 父进程回收后释放所有上下文、存储位置与切换时机总结 临界区访问规则 空闲则入 忙则等待 有限等待 让权等待 死锁必要条件 互斥 非抢占 循环等待 持有并等待 两个线程可以访问同⼀个栈上的变量 线程中访问临界资源的⼀段需要互斥执⾏的代码","link":"/2023/06/13/2023Spring-os-final/"},{"title":"2023春季学期 计算机系统结构 期末复习笔记","text":"W1 4-215出勤 10作业 15大作业 60期末考试 计算机技术的发展永远不能满足增长应用对计算的需求 CISC问题：二八定律，20的复杂指令占据了80的处理时间 处理器频率陷入停滞，开始进入多核并行处理的时代，功耗成问题 指令内部并行、指令级并行、线程级并行——功耗问题；进一步开发数据级和指令并行性很难；储存器访问速度很慢 两方面的技术——计算机制造技术and系统结构 现代计算机系统结构的6个伟大思想：层次架构；摩尔定律；局部性原理（层次存储器）；并行；性能测量&amp;提升；可信性via冗余 1.1 基本概念微程序-传统机器语言-OS-汇编-高级语言-应用语言 翻译 程序整个转换为等效程序，然后再运行。常用于上三层 解释 每一条都对应过去并执行，然后再取下一条。更灵活，不利于优化，更低效 微程序每条机器指令编写成若干微指令，对应微操作来解释执行。硬件电路简单，指令规整，可维护更灵活；执行慢 虚拟机：OS及以上都属于部分由软件实现的机器 Firmware固件，固化软件或者软件功能的硬件，把程序写入EEPROM只读。比如驱动，通过修改固件软件代码可以改变功能，比硬连更灵活。但速度更慢 计算机系统结构广义定义指令级结构+计算机组织+计算机实现 经典定义 传统机器程序员看到的计算机属性，概念性结构和功能特性。 实质 确定界面，以上是软件功能，以下是硬件和固件功能 Flynn弗林分类法指令流和数据流的多倍（在系统最受限的部件上同时处于同执行阶段的指令or数据的最大数目）性质 SISD SIMD MISD MIMD 并行趋势：指令级-线程级-数据级 并行vs同时 同时刻or同时间间隔 隐藏指令问题 不存在于手册里但是对硬件有操作or手册里的功能并没有写出来，危险也不允许 在层次架构中最好有一一映射，保证层次之间的安全鲁棒。很多加速器就是突破层次的直连 计算机系统设计的定量原理 经常性事件原则，以经常性事件为重点Common Case，优化占比最大的指令 Amdahl 评估方案优化效果，加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比 可改进比例Fe 部件加速比Se 一般大于1 仅仅对计算任务中的一部分做性能改进，改进越多总体性能提升约受限？？加速比有上界 运行时间 = ICCPI时钟周期长度 有时候两种CPU执行的指令并不一样，比如分支+比较和没有比较指令。可能影响CPU运行时间的计算。 自顶向下现在更流行rather than自下而上（软硬件脱节，软件太被动）这两种软硬件都脱节 或者middle out 先确定软硬件分配 性能评测指标M FLO P S 百万次浮点操作 TOPS 每秒钟万亿次操作 唯一可靠的性能标准就是真实程序的执行时间。 用户关心单个程序时间；数据处理中心管理员关心吞吐率（在单位时间内完成的更多的任务） 区分CPU时间和操作系统开销（系统CPU时间），CPU时间专指用户程序耗费的CPU时间 W2 4-2W3 4-2xx编址 按x访问 字节编址按字访问：浪费地址空间但是有利于符号处理，浪费储存空间，读写复杂，endian 定位方式： 直接（装入前）、静态（装入中）、动态定位（执行中） 控制器的微指令，把事实指令再拆解成微指令.. 定制化processor大多是cisc 更通用就是risc 微架构：对软件不可见、Cache不可见但是os有对其控制的趋势；分支预测；指令周期；流水线 标量和向量流水线：对数据对象分类 非线性流水线的调度 非线性流水线必须使用连接图和预约表（预约表理解成时空图）共同表示。预约表只是流水线的一种工作方式，线性流水线一定是唯一的。 向量流水线和SIMD的区别在哪？ 基本概念三阶段指令：3n 2n+1 n+2 时空图，时间-阶段指令 连接图每个stage，流水划分尽量平均，最长阶段为瓶颈 设计连续的同类任务 分类单多功能：各段可以通过不同的连接组合实现不同功能 静态动态：同一时间各段按照固定连接or不同方式连接，在时空图看两种任务时间是否相交 线性or非线性：串行or有反馈回路 线性用时空图唯一表示，非线性用连接图和预约表（时间-流水段打×）一起。比如1323 12323分别为前馈和反馈。前馈就是跳到后面，反馈跳前面 顺序乱序：流入留出相同，顺序流动 or 可以不同，后进可以先出 区别于乱序执行：允许多条指令不按顺序发给电路单元 标量向量流水：向量类似SIMD 流水线的性能指标吞吐率，单位时间能够完成的任务数量。最大吞吐即无穷任务。总时间：一条指令完全执行+n-1条的流动单元 细分|重复设置（并行）瓶颈段。中间结果也算结果？ 加速比：顺序时间比流水后时间。段数多任务需要多 效率：设备利用率，时空图上n任务占用时空区与功能段总时空区的比 静态流水：同时间只能固定连接，所以所有加减都出去才能开始计算乘法。 非线性流水调度启动循环算法 禁止集合：各功能段的禁止启动组合一起，无序 冲突向量：哪一位禁止就是1，其他是0 流水线状态图：冲突向量为初始状态，右移m次。如果移出1不管，移0则按位或初始向量形成新状态，构造转移图。每个状态都有m+1以上的移位，自然都回到初始状态。 找可用启动距离和平均启动距离：从初始出发，找所有简单循环（无重复路径）先从一步回；多步回；不回循环；单循环；绝对安全循环等。找到平均最小的循环 找出平均启动距离最小的启动循环or恒定循环（循环节为长度1）最小平均启动距离：大于等于任意行中最多的X（瓶颈段），任何一个简单循环都是上限，上限是冲突向量中1的个数加1. 预留算法 以最优调度，插入非计算delay段。如果理论最优为2，则通过插入Delay把每个x后面2的位置都预留出来。当瓶颈段一直忙碌，就实现了最优调度 动态调度启动循环推出的启动间隔集合Gc，即所有可能的间隔。为C中的间隔任意连续相加。 多功能非线性流水线调度多个冲突向量，对应下一个任务功能是AorB。多个初始节点对应第一个任务类型。双功能有四类冲突向量AA AB BB BA 重叠预约矩阵求初始MatrixA和B，转移边有任务类型和右移次数。 相关与冲突一般约定写操作在前半周期，读在后半周期 相关真数据相关RAW名相关寄存器or存储器单元名称相关，但没有数据流动。如WAR，WAW。——编译器or硬件来换名 控制相关由if 等引出的指令顺序相关 流水线冲突WAR和WAW冲突只有乱序发生，建议换名 定向技术：旁路、短路 编译器重调度解决 尽早判断和计算目标地址，假设到ID段完成 延迟分支 即插入延迟槽，无论是否成功都执行指令，掩盖暂停周期。编译器可以从前面、目标和失败的地方调度延迟槽 实现性价比：最大吞吐/价格，单位任务时间为寄存器延迟+任务/段数，价格为整个流水价格+寄存器*段数，有最佳段数求导 问题P66为什么挤上时空图？ 预约表中同时刻占两个阶段如何理解？ W4 4-2相关：数据（真）相关 名相关 控制相关 名相关：寄存器重命名 Load延迟槽，调度解决 编译器延迟分支：分支指令后面n个延迟槽，无论分支与否，一定被执行。从前调度、从目标调度，从失败处调度 W5 4-2向量数据表示等间距向量表示：向量从0开始计算，向量间距就是其中每个单元的位置，比如64*64bit就是8B的间距，向量长度是64（即维数） 带位移量的向量：从位移量开始，有效长度减去位移量。带位移后实现可变增量，能表示稀疏向量。向量长度L 位移f 有效长度L-f，甚至负数变正 稀疏向量表示：记录非0值，以及bitmap 向量处理方式按行写一排同样形式的算式，然后按行（按算式结果）or按列（按阶段） 横向，一行行加工。每个分量都写读相关，频繁的流水线切换。向量机不适合 纵向：同种运算这一列同时全部执行，然后下一列 纵横：分组，分级按列处理。向量长度超过向量寄存器长度、 向量机结构多个独立存储模块并发访问（纵向） or 多寄存器-寄存器（分组）结构复杂，寄存器多，对存储访问要求低 储存器-储存器：每拍读两个写一个 存储器源源不断提供操作数并不断接受结果，要求存储器带宽和通信带宽 n个储存模块并不正比提升n倍：转移指令and数据随机性（比如跳跃访问，一半冲突） 冲突解决：存储体质数&gt;=向量长度，则位移量与n互质，冲突不存在。如向量16取寄存器17 多次运算后分布改变，仍存在访问冲突 二维数组的行列对角线无冲突：顺序列冲突 顺移错位对角线冲突 一、错开法设同一列相邻元素在并行存储器中错开d1个存储体存放，同一行相邻元素在并行存储器中错开d2个存储体存放。当m＝2^2p＋1（p为任意自然数）时，能够同时实现按行、按列、按对角线和按反对角线无冲突访问的充要条件是：d1＝2P，d2＝1即同行相邻，同列错开2^p 存储体5 17 65等 2^p*i + j + k mod m 体中第i号 有浪费，实现简单 二、紧凑找到n = 2^2p的p，即可用n个并行存储体无冲突 体号地址：2(iL xor jH)＋(iH xor iL xor jL) 体内地址：j 无浪费，并行读写需要比较复杂的对准网络 上图引入A的2周期输入缓冲和 C的输出4周期缓冲，这样冲突的AB同时到流水线。且写入也可以不耽误流水线的连续运行（下一轮数据读出进入） 寄存器-寄存器分组向量，缓冲为向量寄存器，操作数从寄存器读取并写入。向量寄存器：保存一堆标量并顺序访问，降低存储流量 0608-0615 Final ReviewD.S. Wang“尽可能量大一点，简单一点” 填空 判断对错 单选 计算题 都是量化的计算 题目很多很简单，两个实验都考 每章都要有，性能评价 L1 层级架构 Flynn分类法 amdahl定律 cpu性能公式 访存占xxx时，xx加速后最后加速比xxx benchmark 执行时间吞吐率 L2数据表示 寻址方式（立即数 变址）编址 定位… huffman编码 L3 分类 静态动态 线性非线性 加速比（效率、资源利用率） 单功能非线性流水线调度，解决冲突且性能高，相关：指令固有的属性，由于相关会造成冲突 目标是相关指令不造成流水线冲突，多功能调度不要求 L4 向量处理机？ 数据集并行，三种向量处理方式，两种架构 多个技术：链接、编队、循环开采 性能评价方法 L5 掌握动态Tomasulo+ROB实现精确中断，预测失败的正确返回 记分牌不要求 动态分支预测技术 come from总线 vs goto总线 L6 只要求循环展开知道基本概念 EPIC不考 L7 存储 考试重点，基本概念为主 局部性原理 四个问题（策略）：放置（全 直接 组）、查找、替换、写策略（through back） cache缺失原因：强制（冷启动缺失） 容量 冲突 一致性（不重要） 性能：miss少 miss代价小 hit更快 L9 互联函数 参数（规模 度 直径） 静态、动态的互连网络 L10 线程并行？多核处理器，必然，单核频率 UMA &amp; NUMA下的一致性问题 多线程要细粒度才有意义 15 + 10 + 15 + 60 L1 基础 6.8计算机技术的发展永远满足不了不断增长应用对计算的需求 CISC的二八定律：20%的指令占了80%的时间，剩下80只占20%时间 单核频率停滞，功耗成为大问题，存储器访问速度的提高pang慢；有效开发数据和指令并行难 计算机制造技术&amp;系统结构 层次结构 应用+算法 编程语言 OS ISA 微架构 RTL 电路 设备 物理 应用 高级语言 汇编 操作系统级 【虚拟】|【物理】 机器语言 微程序 微程序一条机器指令包含若干微指令，硬件解释执行微操作 微程序：硬件简单 规整 灵活 可维护 慢 不使用：快 指令简单 复杂指令的逻辑电路复杂 经典定义：传统机器程序员看到的计算机属性，按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性 广义定义： 指令集结构（Instruction Set Architecture） ＋ 计 算 机 组 织（Organization） ＋计 算 机 实 现（Implementation） Flynn分类法SISD 单核单数据 SIMD 经常数据并行，向量机 MISD 没什么，脉动阵列TPU MIMD 经常性事件原则：多优化经常事件，阿姆达尔 加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。可改进比例Fe 部件加速比Se 不可改进比例+可改进的变化 cpu时间 = InstrCount * CPI * 时钟周期长度 设计方法 自顶向下 先确定最高应用级特征，也容易脱节 自底向上 软件完全被动，硬件软件脱节，很少采用 中间开始 软硬件交界面开始分配软硬功能 性能评测MIPS 每秒百万条指令 MFLOPS 每秒百万次浮点操作 TOPS 每秒T次操作 执行时间：全部时间orcpu时间（用户cpu时间和系统cpu时间） benchmark测试 是否允许修改？ 用户执行时间 服务器吞吐率 加权调和平均执行时间，上面是权重和 标准化执行时间，先归一化到某个机器上，然后计算平均（算数或者几何）Am Gm 几何平均值的比等于比的几何平均值 几何平均值的加权是乘方 系统结构发展模拟，一般“解释”实现 仿真，宿主机的微程序实现目标机的指令级，更快但差别不能大 并行发展同时：两个及以上时间同时刻发生 并发：两个及以上事件同时间间隔发生 字并》位并》字串位串 时间重叠，高性能单处理机，部件专用化；资源重复，多搞一些；资源共享 阵列处理机：SIMD？ 指令内部并行；指令级；线程级；过程级；作业程序级 紧密耦合共享主存，松散耦合共享外存 L2 指令系统 6.8软硬交界面 新型指令系统，比如mac指令乘加AxB+C = D 结构分类cpu中存储单元: 堆栈结构 累加器结构 通用寄存器结构 堆栈：简单；指令短；隐式给操作数 累加器（专门数逻运算）：减少状态；指令短；隐式操作数 通用reg：增加内部寄存器数，降低存储器通信开销；更少的地址寻址减小目标代码；编译器更有效的使用寄存器 但均需显示命名给出，指令长 寄存器-存储器 ：ALU来源一个reg一个mem 寄存器-寄存器：两个regx操作数指令 RR结构也是loadstore结构，只有LS访存。 指令字长固定，简洁简单；各种指令周期数相仿； 指令条多，不够紧凑，程序占用空间大 寻址方式主存宽度8B 任意存 不能跨主存行，速度快但空间浪费。指令格式，对于操作数来说 直接方式，操作数在指令中 间接，操作码+地址码寻址方式，由操作码决定适合简单LSor专门指出寻址方式的字段适合多种访存多种寻址 立即数 给出操作数 直接 给出操作数地址 寄存器 给出寄存器符号 寄存器间接 给出寄存器-地址-数据 寄存器相对（偏移） 寄存器-地址-偏移-数据 基址变址 寄存器-寄存器-地址-数据 相对基址变址寻址 寄存器-寄存器-地址-偏移-数据 指令系统设计优化转移地址一般：pc相对立即数寻址 指令操作码优化 Huffman编码理论平均最短编码长度 -plogp求和 把叶节点从左到右在底下一行，然后左1右0 平均位数小但变长编码不利于处理 扩展码 有限码长 比如2-4扩展3+4=7个等长扩展码，比如15/15/15法即4位一扩展，等长15个 8/64/512法，四位扩展但头一致。保证头是若干1一个0 定长码也不错，便于处理 编码格式可变长编码：复杂效果好，各条字长和时间都差很大 固定长度编码：RISC 译码简单 混合编码：若干固定字长 指令系统发展演进——CISCcisc——RISC软件复杂性指数上涨 面向目标程序，高频指令组合 面向高级语言优化，缩小语义差距 面向操作系统优化RISC cisc二八，不利于流水 操作数类型大小类型 操作数类型由操作码指定如ADDDU 数据赋硬件解释标记，带标识符的数据表示；指令系统简单硬件检测；简化编译器；动态开销大操作 数据传送 数逻 控制转移 L3 流水线技术基本概念控制复杂 利用率高 时间并行：分时使用一个部件的不同部分 空间并行：多个不同部件共同完成 时空图 横坐标时间，纵坐标阶段 通过时间，第一个任务进入到流出 排空时间，最后一个任务… 连接图 单指令从输入到输出，中间latch流水寄存 连续同类任务，流水段尽可能时间相等 部件级（某种运算操作）；（指令）处理器级；（任务）系统级 单功能、多功能（静态、动态，各段不同连接，同一时间内各段连接方式分为静态动态。同时间只一种功能为静态，即虽然能变但是需要前一种任务排空才进下一种任务） 顺序乱序：流入流出顺序相同？ 标量向量 线性or非线性（反馈回路） 非线性需要连接图+预约表，前馈为forward 性能指标吞吐率，单位时间的任务量（指令数），实际吞吐和最大吞吐（指令数n趋于无穷） 瓶颈段影响吞吐？细分瓶颈段，冗余设置并行瓶颈段（允许多条指令同时位于此段） 加速比 约为m 段数多需要任务更多 算时间一般算一条指令完整通过+ n-1 * 瓶颈节拍 效率 占用时空区/总时空区，在时空图上看面积/矩形 画时空图求解问题！看静态动态！ 非线性流水线调度禁止启动距离：引起流水线冲突的启动距离， 不发生冲突的启动序列启动循环（1,7）也有恒定循环（5） 禁止集合 每行的任何两个x距离如2 4 6 行内多个√就都算 冲突向量 禁止项为1，如101010 状态图不断逻辑右移，和初始向量或 移1不管 所以只有1 3 5 7*或者7+ 移0 按位或 找到可用启动距离即回到初始的循环 找到最小平均启动距离定理：理想下限是任意行内x的最多个数 上限是冲突向量的1个数再加1 状态图简单循环的平均启动都是上限 如何达成理想最小的恒定循环 x的个数？ 预留算法 插入非计算延迟段，每一行与x距离为2的倍数都留下来 动态调度 启动间隔集合 从启动循环推导出各个任务可能的启动间隔，先在原循环按1相连2相连…？？ 相关与冲突真相关|数据相关 真对角线方向，RAW 且可传递 名相关 名字一样但没有数据流动 反相关WAR 先读后写 输出相关WAW 两次写 换名技术，寄存器换名可以编译or硬件。把所有后面的同名寄存器换成S控制相关 if 流水线hazard 结构冲突：硬件不够 流水or更多硬件资源 如IF和MEM都读指令——分开I和D的mem；插气泡 数据冲突：需要用到前面结果还没出来 WAR和WAW只有乱序才发生 换名 RAW 专用路径（前馈、旁路、定向技术） stall，解决ALU MEM？stall or 编译器重新组织 控制冲突：分支指令or改PC指令 stall3个周期直到pc在mem改变再IF 尽早分支——在ID分支只有1周期延迟 静态预测（软件） 预测失败，正常IF i+1 i+2 预测成功，没什么好处，由于在ID才能算出target所以还是要延迟一周期 延迟分支（软件）：分支+延迟槽，分支成功与否都要执行slot指令，掩盖暂停周期——多由编译器完成 从前调度，找一个必执行的放slot里 从target调度：保证失败时这条slot instr不会产生错误。有可能需要复制指令？？==预测成功 从失败处调度：保证xxx ==预测失败 如果延迟预测错误就把该slot指令除了IF全idle（设为空指令） 流水线实现尽可能各段相等，段数多（深度）性能高 成本？ L4 向量处理机SIMD 三种并行 指令级并行，多个指令同时执行：流水线；超标量；VLIW；乱序 向量数据并行SIMD：MMX SSE TPUGOOGLE 脉动阵列 GPU ADDV Cray1 线程级并行，多指令流MIMD？？ 多处理机多核 多线程 向量表示和处理方式一般向量机是大型机，有辅助的高性能标量处理器 微机+向量协处理器 向量平衡点 向量标量利用率相等，向量代码比例（我跑一秒你也一秒） 把问题转换为向量 等间距向量表示，从头，多少个多长的元素起始A 长度L 表示有多少个单元（元素） 间距f 表示元素间距 A+nf, n&lt;L 带位移量的向量表示起始A 长度L 位移量f 有效长度L-f 起始地址A+f 即从A开始，下标从f到L的这么多元素 默认间距为32即字长 再加上个控制Vector表示真正执行操作的字 稀疏向量表示法表示向量为val向量+01位向量 可以展开计算，也可以压缩着计算 向量处理方式 循环展开语义下 假设向量为列向量 横向处理按循环体中横向处理，都有RAW相关效率低，不适合 频繁切换流水线 纵向处理展开循环之后算出所有中间结果，然后算最终结果 适合向量机，不同运算只切换1次 纵横处理 分组处理组内纵向，组间横向。比如向量长度100大于向量寄存器字长4？分组N = k*n + r 每组两条指令，功能切换2次，相关1次 向量机结构一般相比于向量计算，忽略取指开销？ 存储器存储器 纵向采用，多个独立存储器并行工作，结构简单；对存储的延迟、带宽要求很高 高带宽要求？多体交叉并行存储器 or 缓冲技术 15/2.167约等于7 * 32*6 =1344 无冲突访存存储器 bank conflict问题 存储体选质数且&gt;=向量长度，一维数组不可能冲突 多次运算后分布改变，无法克服 操作数和写结果的可变缓冲器目标是Ai Bi同时到，可以更加规整的读写？？ n*n在行列对角线访问都不冲突？？ 设同一列相邻元素在并行存储器中错开d1个存储体存放，同一行相邻元素在并行存储器中错开d2个存储体存放。当m＝2^2p＋1（p为任意自然数）时，能够同时实现按行、按列、按对角线和按反对角线无冲突访问的充要条件是：d1＝2^p，d2＝1 浪费但简单 找到满足n = 2^2p的p则n个就可以无冲突访问 体号地址：2(iL Å jH)＋(iH Å iL Å jL) 体内地址：j 寄存器寄存器 分组采用；高带宽的告诉寄存器，需要大量寄存器；对存储系统要求低 T存储器类似cache但需要手动管理 向量冲突（使用相同的Vi，RAR也不行因为向量长度不一定一样。即指令commit之前占用R和W的reg） 功能部件冲突，连续两个乘法 常用技术 多个功能部件并行工作 链接技术 针对RAW&amp;&amp;没有src冲突和功能冲突，连起来刘水处理。即前一步作为中间结果 计算公式一般为 第一条指令完整通过时间+向量长度-1 第一条（访存指令）是不要 V到部件的1拍时间的，但store指令需要前后各一拍 分段开采 超过机器向量长度的需要分段开采，算迭代次数和余数处理等。 条件执行 屏蔽向量，为0的不操作.. 多处理机 性能评价单条长度为n的向量指令处理时间T_vp 部件建立setup+通过时间exec+n-1时钟周期c 启动时间start 开始执行到还差一个周期就流出的周期数，意义是start+n = 时间，即把-1分配过去了 编队 一个周期内开始执行的几条向量指令，一定不存在功能和数据冲突，总时间为编队执行时间之和 循环开采计算 大循环，整个指令的循环，每次加T_loop即可 200 / 64， start和loop每次循环都要有 无链接的编队start计算是各个编队时间相加-1，如12+12+12+6-1 = 41 例4.5 和 4.6自相矛盾 链接之后的启动时间？直接相加即可，虽然不对！12+7 最大性能 峰值R无穷 频率*浮点次数/周期数 如200M * 2n / 3n+… 半性能长度 n1/2 最大性能一半时所需的向量长度，向上取整 长度临界值 优于串行的速度， L5 指令级并行开发，硬件对程序员透明 数据流动不变 | 异常行为不变 IR阶段划分为IR，I译码并发射，R读regfile 显式动态寄存器重命名？？把后面所有寄存器全都换掉名字！ 硬件维护映射表，结构寄存器Ri分配物理寄存器Pi，查找映射表最近一次写寄存器 缺点：要求物理比结构寄存器多， Tomasulo 隐式寄存器重命名消除WAR和WAW功能部件保留站：保留已经发射等待执行的指令，操作码 操作数等信息 操作Op 保留站号QjQk 操作数VjVk 有效位busy load store中需要A，立即数或者有效地址 load缓冲 计算地址分量 记录正在load的地址，等待结果 暂存结果store缓冲 计算地址分量 记录正在store的地址，等待数据到达 保存数据和地址知道memory ok指令队列 先进先出的顺序发射寄存器状态表 寄存器就绪状态，发射rd指令则标记非就绪并记录此指令 Qi寄存器状态表运行规则 如果保留站空则可以发射——结构冲突 隐式换名发射时如果没结果则换名成保留站部件标识，产生后可能换成了数据本身，反正不再和寄存器号有关了。WAR 预约rd，消除WAW 记得标记R【F2】或者M【A1|80】 浮点：设置busy，记录op，处理rsrt和rd 保留站操作数就绪后开始执行，结束后发射cdb Load只能exec头部指令，即即使多保留站也要按顺序执行 Store就绪 写rd需要cdb来写等待的寄存器和保留站，并释放busy 写入延迟 某个操作完成后需要下一个周期才写成结果，不管是regfile的结果还是cdb等待的结果。 如果数据准备好则同时开始运行计数，5就绪7完成exec comp 8清除并且各个地方收到数据 顺序发射 乱序执行和完成 因保留站满而不发射时，保留站需要滞空一周期，考虑边缘写入规则？ 假设循环控制时SUBI和BNEZ不发射，一周期完成？？总线CDB comefrom 总线，发射广播，正常goto是dest+data，这里是data+src 不支持精确中断！引入ROB重排序缓存保证顺序提交！ CDB连接ROB而非regfile，指令从ROB读数据是个FIFO队列？？发射入队，提交出队 编号取代保留站编号，记录整个指令instr 运行情况分为issue发射周期，啥也不干 - exec1234执行计数周期，write已经writeback等待commit，awake所有等待的保留站但不提交寄存器。commit（nobusy） dest 目的寄存器 value最终结果 发射到ROB和保留站里 分支预测缓冲器BHT 历史表局部指令 2bit第一次在中立态？？ 需要判定分支成功时间》确定分支地址时间，五段经典流水线这里啷个过程都在ID段，不会有好处 m n预测器前m此其他条件转移指令，选择2^m个nbit预测器？？ BTB分支目标缓冲 即Branch Target Buffer （cache）存上目标地址。找得到就branch否则顺序执行 或者结合BHT，把2bitBHT放在BTB里 结合ROB和tomasuloROB的分支指令提交？ 提交为预测正确时，正常提交正常执行 提交为预测错误时，清除后续所有ROB和相关的保留站等。寄存器状态回退为上一个ROB依赖。 多指令发射超标量 n发射编译器静态，也可以tomasulo动态调度 对程序员透明 可以发射一条整数+1浮点。load和分支延迟 超长指令字VLIW发射固定条数，构成超长指令，并行，指令调度静态 指令字中很多个操作slot，独立控制功能部件。靠编译器 L6 指令级并行开发，软件静态方法1 指令调度循环展开避免空转的编译器静态调度 循环展开后调度 循环展开+改变次序减少空转+寄存器换名，把名相关的换大的 2 跨基本块的静态调度（全局调度）多发射下：缩短关键路径长度；单发射减少指令数 全局调度非常复杂 踪迹调度踪迹多个基本块组成的一组序列，可以分支但一定没有循环。 优化高频踪迹，减少开销，非常适合多发射处理器，需加补偿代码 超块调度超块只能有一个入口，多个出口 “尾复制技术” 3 静态多指令发射VLIW需要很智能的编译器 多发射适应场景》向量处理器，不规则也能挖掘并行。对存储没要求，cache便宜 6.4-6.6 自学不考 L7 存储系统性能评价：延迟、带宽 1 basics速度 容量 价格 访问效率理论最快时间/实际时间 额外开销：请求M2并把M2的数据写入高级存储M1的时间 放置、查找、替换、写策略2 Cache basics以 块 为单位调入调出cache 区分块地址——已经抛掉比block更低位的地址了 直接映射唯一位置，简单，速度快；空间低效，冲突多 tag index block_offset 全相连任一块，利用好，冲突少；复杂，代价高，慢 tag block_offset n-way组相连 CAM内容寻址存储器tag index offset 指令cache 直接映射 数据cache 组相连 FIFO 装入替换时其他+1，换最大的 LRU 装入替换时其他+1 命中时候比他小的+1，他回0 写策略 hit 写直达 直接写回主存，可靠，慢（写停顿） 写回 惰性，脏的时候替换的时候才写回主存。读操作也会产生写指令 MISS 写不分配 直接写入主存，不管cache。配合直达 写分配 写入主存和cache，结合写回 3 cache miss rate乱序处理器cache要求低，可以串行访问cache，低功耗高频率 强制性——增加块大小，预取 容量缺失——增加容量，成本高，命中慢 冲突缺失——某个组太多、直接映像。两路组相连一般容量和正常容量的直接相连差不多块大小和缺失率，是对钩函数，块大：强制缺失少，但块少冲突缺失多，不灵活。cache大，最优块也大 相连度大命中慢 伪相连 两路的话用一位bit预测在哪，只需比较一个tag。命中时间不一致，适合离cpu更远的cache 编译器预取：循环是预取的主要对象，缺失开销越大展开越多；执行指令和读数据同时执行；开销不要超过 编译器优化局部性：数组合并；循环交换、融合；分块 牺牲cache Victimcache，减少冲突缺失不影响时钟频率 cache和底层设置全相连小cache，用于存放被替换出去的牺牲者块。小容量的直接映射很有用。 4 cache miss cost多级cache 局部缺失、全局缺失：到这的请求还是全部请求 平均停顿时间是相对于最快hit时间来说的 低级cache用更高的相连度，多为强制、冲突缺失；更大的块大小； 读缺失优先写缺失 写缓冲器带来的复杂，读缺失想读的内容还没被写进去？ 推迟读缺失处理or检查写缓冲器。 写回法中先读缓冲器，之后再考虑写 写缓冲合并 匹配写缓冲器如果有则合并，之后写入 请求字 只立即需要一个word 从请求字读起，提早发送给cpu等 非阻塞cache miss时还能让cpu正常hit其他地址 5 cache hit cost硬件简单、小；物理地址PIPT cache 虚拟地址VIVT cache 还有什么狗几把VIPT等 访问流水化 L1 cache流水组织 踪迹cache 存放cpu执行的动态指令序列，包含分支预测指令。 6 parallel main memory单体多字存储器 每个周期m个cpuword 简单，效率低 多体交叉存储区 多个单字存储，如何编址？ 高位交叉编址？按高位区分存储体，适合行优先的按列读出，即存储矩阵列优先 低位交叉？低位区分存储体，行优先 避免冲突c存储体素数，循环交换，扩展数组大小为非2幂 L9 互联网络循环表示法( 1 2 3 4)输出左移一位 互联函数2交换|方体 Cubex或者Ex都是x位地址取反 3均匀洗牌σ 循环左移1，子函数下标取右边，超函数上标取左边 混洗交换：cube0+均匀洗牌 左右能换大范围也能换 4蝶式函数β 高低互换 5反位序函数ρ 整个颠倒 6移数函数α +-k mod N 错开连接 7PM2I函数 +-2^i mod N 求连接，正反求两次，自己作为x和y 网络结构参数、性能指标网络直径D，任意两个节点距离最大值 等分宽度b，N个节点等分切开沿切口边数的最小值 等分带宽：沿着切边的带宽 通信延时：软件开销+通道时延+选路+竞争 网络延时：通道+选路 端口带宽 聚集带宽：一半到另一半的最大信息传输带宽，对称除二 静态互连网络运行中不能改变，固定连接通路 1 线性阵列 vs总线：总线独占而线性阵列可以复用 2 环、带弦环： 全连接 3 循环移数：2的整数幂加一条边 16的话度为7 直径2 一般直径为log/2 度为2n-1 4 树、星 5 胖树 6 二维网格 网络直径为对角线，等分宽度为边长 k维？ 2k内部度 直径k(n-1) illiac 二维网列相连，行尾连下一行头 直径n-1 环网 列、行都是封闭自相连 直径2*fl(n/2) 7 超立方体 n-立方体由2^n节点构成，4立方体共24+8 8 带环立方体3ccc 每个节点变成3元环 9 k元n立方体 动态互联网络交换开关，可以动态变化 2 交叉开关网络，类似可编程逻辑一堆交叉点，全置换 3 多级互联网络 staran网络 级（交换）和部分级（移数）控制 x组y元交换，交换都是全部倒过来 简介二进制n方体 单元控制 Omega logN级 每个N/2个开关 消息传递机制消息-包-片 线路交换，先建立线路时间开销打。适合动态突发大规模并行数据传输。先发一个L1/B模拟传输速度，先传输 存储转发 分组交换 L(D+1)/B 虚拟直通 包头到了就决定转发不用接全包， 虫蚀方式，切片流水，缓冲器小，延迟小，共享好；片会阻塞在节点占用资源 利用虚拟通道减少死锁 流控制策略？ 包冲突：暂存缓冲区；阻塞；丢弃；绕道 确定or自适应寻经 xy寻径，先横后纵 n方体寻径，先低位后高维 单、选播 广播 会议 L10 多处理机只考基本概念 SMP UMA 单存储器单IO 总线连接 分布式存储器 ，延迟小带宽要求小；缺点通信复杂，跨域延迟大 NUMA DSM分布式共享地址空间， 消息传递的硬件简单，通信显式|共享存储器易于编程，编译器简单 并行性能常依赖app的高层特性 2 对称式共享存储器cache一致性问题 目录协议 监听协议 写作废 作废其他副本 针对块 谢更新 其他人都update 针对word | byte 3 分布式共享目录记录block状态以及哪些cache持有副本 由于M= K×N， K是每个处理机中存储块的数量，所以如果K保持不变，则目录中的信息量（M×N =K×N2）就与N2成正比。 没缓冲|share|独占 本地；宿主；远程（拥有副本） 全映像目录每个目录都N位|有限映像m*logN即m个机器地址|链式目录 5 同步性能细粒度线程：每个周期都切换；荫蔽吞吐损失；减慢单个线程，可以优先来缓解 粗粒度：短停顿还是会停顿 同时多线程SMT 多发射动态调度，只有细粒度有意义 8threads 6 PVP并行向量 高带宽交叉网络 不cache 对称式共享存储器多处理机和分布式共享存储器多处理机 大规模并行处理机 非共享存储器；专门地址空间；消息传递 可扩放性 机群计算机 每个节点都完整","link":"/2023/06/15/2023Spring-ca-final/"}],"tags":[],"categories":[{"name":"Course","slug":"Course","link":"/categories/Course/"},{"name":"Daily","slug":"Daily","link":"/categories/Daily/"},{"name":"Auto","slug":"Auto","link":"/categories/Auto/"}],"pages":[{"title":"","text":"2024 SYT QQ聊天の年度报告What’s This?这是一份早就有过想法的，也和你提起过的基于QQ聊天记录的数据统计报告。 很遗憾最终还是没用上你给我找的那两个项目，但是那天我吐槽这件事之后，你非常卖力地帮我在Github以及其他平台上搜索教程，希望能有所帮助的举动，十分打动我。 我是一个喜欢胡思乱想，喜欢顺着想法去尝试的人。但是最近经常碰壁，所以你耳边免不了很多抱怨和吐槽。感谢你一如既往地认真聆听和耐心陪伴。也“感谢永远有歌 把心境道破”。 原来我才是最依赖的人我需要你比你需要我深 谢谢你的照顾你的体贴给我一个美好的世界我把幸福看得太简单了点你有多用心我却没有发觉 谢谢你的照顾你的离开让我对爱有更多了解现在才说也许太晚了一点失去过的人会更珍惜一点 ——《谢谢》 by 陈奕迅 问世界上任何一个人，11103公里的异地恋是不是一件容易的事，答案必然是一致的。但无论如何，这都会是我们最精彩的人生故事之一。 你已经开始在代码中把我的生日作为一些随机种子了，你还感叹无论结局如何，我已经成为了你的一部分。那就具象地看看，这930天的爱情，以及八个秋天，七个春天的友谊，在我们交流的主要媒介中，都留下了什么痕迹。 这个迟到的“年度报告”也作为你今年情人节的礼物，不耽误巧克力。 祝你情人节快乐，天天都是节，天天都快乐。 First Moments &amp; Special Words第一次出现“晚安”在2020年8月18号，晚上11点34分57秒，你发来很正式的”晚安“，我在一分钟不到后回复了”晚安啊鸟“。这之外，我们还互相发了2377个晚安，很可惜是个奇数，不怎么漂亮。 其实”孙老师“这个称呼第一次出现也非常早，在2021年2月8日，你说给某个亲戚补课还是什么，我在11:57:41发了一句”孙老师！”。与之对应的，你在考虑叫我什么。同年3月24日晚上11点48分1秒，你若有所思地跟我说“要不我叫你杨先生吧🤔”。这名字现在听着，怎么有点脸红呢？ 总会有更害羞的事情的，“老公”一词在聊天记录中出现了98次，其实也不是很多。“老婆”则出现了224次，这说明我比你更加不要脸吗..真没想到。第一次“老公”出现在21年4月6日，我说“你是选择给老公打电话接你还是找个男的去给你当司机把你送回家”，你应该是蛮羞涩地回复道“给老公qwq”。 而二周目最常见的称呼“宝宝”一共出现了1343次，但是总会有些奇怪的东西混进去，给这个次数注水。比如前几次提到“宝宝”前面都缀着“海绵”二字。值得考证的有指代意义的第一次，在2021年3月16日晚上9点1分0秒，我说“打游戏也不符合你乖宝宝的设定鸭”。然后你就说要和妈妈去看电影了，在家看《李焕英》。 最近的“宝宝”二字基本都带着你的“爱你”，而“爱你”的第一次出现在2021年3月14日，晚上20点13分19秒，一周目的不到一个月时间。我用半开玩笑的语气说了一句，“谢谢璇妹，爱你！”好像是因为你旁敲侧击，夸我是帅哥来着？没想到第一次说起“爱”字竟然如此之早。这之后，我们又说了1616次爱你。几乎要把“爱”挂在嘴边了。 与之经常相伴的，❤出现了2154次，❤️出现了2379次，给你半分钟时间，分辨一下哪个心是谁的发送习惯。 更为轻度表达感情的“喜欢”，不管是喜欢事还是喜欢人还是喜欢彼此，出现了3314次。除了“喜欢”的高昂状态，我们还有其他各种各样的感情。这四年半的聊天中，我们发了253次“很烦”，321次“问题不大”，575次“难受”，781次“开心”，1345次“累”，3185个“爽”字，光是直接连着中文感叹号的就有82次。看来，虽然生活很累很难受，但“问题不大”，”开心“才应该是我们的主旋律。 民以食为天，何况孙雨璇。我们提到了12110次”吃“字，不光是1479次的”吃饭“，还有957次的”吃瓜“，802次”吃完“。而”吃不下“和”吃不了“等只占其中的212次，看来大部分都吃到肚子里了，肉肉三百斤，斤斤不负其名。 hyr出现了668次，你真的很爱她。与之对应的，lmc只出现了102次，即使算上”成哥“，”阿成“等其他称呼，也不过三四百次的出场。和胡女士在你心中的地位，实在是小巫见大胡。 ”舞“字出现了639次，你确实是个很爱跳舞的小女孩，可惜还是比不过981次”作业“。当然还有5203个”玩“字，抵不上8947次的”学“字，甚至329次“熬”字，悲！还好有9806次“睡”字，永远要记得好好休息，看来是比玩和学都重要了。 3469个“明天”，1657个“昨天，1580个“日”和638个“夜”。我们还会走过多少个昨天，期待多少个明天，经历过多少个日日夜夜呢？或者再过254个春，171个夏，188个秋和202个冬天？希望我们能活那么久，在一起那么久，实在不行就埋一起凑那么久吧，不过现在20年的墓地产权已经越来越贵了。 Big Numbers在我们的统计范围中，2020年7月8日 晚上22点12分3秒，你给我发了第一个表情包，后面是“头像变彩了”和一个傲娇表情。我回复“是！”，“快乐了”。 2025年2月13日 下午14点24分53秒，我发了最后一条消息。给你分享了一个王源现场真唱的实录视频，随着一句“啊？”，希望能得到你的反馈。 在这期间，我们一共互相发送了506827条消息，约3277475个字。在A4纸上用五号字打印出来，需要张1910纸。接在一起约长567米。 其中，你发送了其中的1442688个字，我发送了1834787个字，约占其中的**56%**。我可真是个小话痨呢！ 值得一提的是，二周目以来，我发送了1036496个字中的634157个字，使得我的话痨占比上升到61.2%。好消息是，消息条数上，我只占到了54%，85247条消息，看来我的习惯更倾向于一条消息中多打点字。 WordCloud全部词云图 去掉一些无意义词汇之后的词云图。 Time Travelling[TODO] Last Never Least孙老师，情人节快乐。这是我们认识之后的第8个情人节了，很庆幸你仍然是我的情人。 Others关于提取qqnt聊天记录的工作，后续会整理出一份(未完成)文档和代码 唛头羊2025年2月13日A Gift for Savannah Sun.","link":"/Valentine.html"},{"title":"杨天傲 (Tianao Yang)","text":"联系信息北京市双清路30号清华大学，东主楼8-207房间 电子邮箱: yta20@mails.tsinghua.edu.cn (学业) | matteoyang0425@gmail.com (个人) 联系电话: (+86) 18801163623 关于我我叫杨天傲，是一名清华大学计算机科学与技术系的大四学生，长期居住在北京。我目前在清华大学存储研究组进行科研实习，我的导师是陆游游教授和舒继武教授。 学业之外，我也喜欢很多电子游戏，包括守望先锋（暴雪你还我国服），空洞骑士（过不去四锁五门但是爱玩），超级马里奥系列以及一些其他有趣的游戏。我也喜欢打羽毛球，数码产品以及旅行。我希望能见更多的人，体验更多的事，探索更多的领域，以及持续的进步（和摸鱼）。 欢迎来到我的个人博客，我也没什么好招待的，随便逛逛！ 论文发表 Understanding In-Situ Programming for Smart Home Automation.Liu, X., Shi, Y., Yu, C., Gao, C., Yang, T., Liang, C., &amp; Shi, Y.Proceedings of the ACM on Interactive, Mobile, Wearable and Ubiquitous Technologies (IMWUT’23), 2023[文章] [网页] 教育经历 本科2020 - 现在清华大学|计算机科学与技术系 大学前2017 - 2020唐山市第一中学2014 - 2017唐山市第九中学","link":"/about_Chinese.html"},{"title":"Resources Download 资源下载","text":"我也不知道会有什么但是总会有些什么的下载页面","link":"/download.html"},{"title":"Tianao Yang (杨天傲)","text":"Senior Undergraduate Student Research Internship at Tsinghua Storage Research Group Department of Computer Science and Technology, Tsinghua University Room 8-207, East Main Building, Tsinghua University, Beijing, China Email: yta20@mails.tsinghua.edu.cn (Academic) | matteoyang0425@gmail.com (Personal) Phone: (+86) 18801163623 About MEHi, my name is Tianao Yang (杨天傲). I’m a fourth-year undergraduate student in the Department of Computer Science and Technology, Tsinghua University. I’m doing my research internship at Tsinghua Storage Research Group, advised by Prof. Youyou Lu and Prof. Jiwu Shu. Beyond my studies, I enjoy playing Overwatch, Hollow Knight, Super Mario Series and other various games. I also have a passion for Badminton, Digital Technology and Travelling. I hope to meet more people, experience new things, explore different paths, and strive for continuous improvement. I prefer writing in Chinese rather than English T.T. So there’re mostly Chinese passages in this blog except for academic related. Publications Understanding In-Situ Programming for Smart Home Automation.Liu, X., Shi, Y., Yu, C., Gao, C., Yang, T., Liang, C., &amp; Shi, Y.Proceedings of the ACM on Interactive, Mobile, Wearable and Ubiquitous Technologies (IMWUT’23), 2023[Paper] [ACM Page] CalibRead: Unobtrusive Eye Tracking Calibration from Natural Reading BehaviorLiu, C., Yu, C., Wang, X., Jiang, J., Yang, T., Tang, B., Shi, Y., Liang, C., &amp; Shi, Y.Proceedings of the ACM on Interactive, Mobile, Wearable and Ubiquitous Technologies (IMWUT’23), 2024 Education B.Eng.2020 - PresentDepartment of Computer Science and Technology, Tsinghua University Before College2017 - 2020Tangshan No.1 High School2014 - 2017Tangshan No.9 Middle School","link":"/about_English.html"},{"title":"","text":"Feel Free to Contact Me via WeChat…","link":"/contact_wechat.html"}]}